// Generated by the protocol buffer compiler.
// source: sentencepiece_model.proto
// Protobuf Java Version: 4.26.1

// Manually edited to avoid warnings

package huplay.tokenizer.sentencePiece;

import com.google.protobuf.*;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serial;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

@SuppressWarnings("unused")
public final class SentencePieceModel
{
    private SentencePieceModel()
    {
    }

    static
    {
        RuntimeVersion.validateProtobufGencodeVersion(
                RuntimeVersion.RuntimeDomain.PUBLIC,
                /* major= */ 4,
                /* minor= */ 26,
                /* patch= */ 1,
                /* suffix= */ "",
                SentencePieceModel.class.getName());
    }

    public static void registerAllExtensions(ExtensionRegistryLite registry)
    {
    }

    public static void registerAllExtensions(ExtensionRegistry registry)
    {
        registerAllExtensions((ExtensionRegistryLite) registry);
    }

    public interface TrainerSpecOrBuilder extends GeneratedMessage.ExtendableMessageOrBuilder<TrainerSpec>
    {

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * General parameters
         *
         * Input corpus files.
         * Trainer accepts the following two formats:
         * A) Monolingual: plain text, one sentence per line.
         * B) Bilingual:   TSV, source sentence &lt;tab&gt; target sentence
         * When bilingual data is passed, shared vocabulary model is built.
         * Note that the input file must be raw corpus, not a preprocessed corpus.
         * Trainer only loads the first `input_sentence_size` sentences specified
         * with this parameter.
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         *
         * @return A list containing the input.
         */
        List<String> getInputList();

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * General parameters
         *
         * Input corpus files.
         * Trainer accepts the following two formats:
         * A) Monolingual: plain text, one sentence per line.
         * B) Bilingual:   TSV, source sentence &lt;tab&gt; target sentence
         * When bilingual data is passed, shared vocabulary model is built.
         * Note that the input file must be raw corpus, not a preprocessed corpus.
         * Trainer only loads the first `input_sentence_size` sentences specified
         * with this parameter.
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         *
         * @return The count of input.
         */
        int getInputCount();

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * General parameters
         *
         * Input corpus files.
         * Trainer accepts the following two formats:
         * A) Monolingual: plain text, one sentence per line.
         * B) Bilingual:   TSV, source sentence &lt;tab&gt; target sentence
         * When bilingual data is passed, shared vocabulary model is built.
         * Note that the input file must be raw corpus, not a preprocessed corpus.
         * Trainer only loads the first `input_sentence_size` sentences specified
         * with this parameter.
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         *
         * @param index The index of the element to return.
         * @return The input at the given index.
         */
        String getInput(int index);

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * General parameters
         *
         * Input corpus files.
         * Trainer accepts the following two formats:
         * A) Monolingual: plain text, one sentence per line.
         * B) Bilingual:   TSV, source sentence &lt;tab&gt; target sentence
         * When bilingual data is passed, shared vocabulary model is built.
         * Note that the input file must be raw corpus, not a preprocessed corpus.
         * Trainer only loads the first `input_sentence_size` sentences specified
         * with this parameter.
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         *
         * @param index The index of the value to return.
         * @return The bytes of the input at the given index.
         */
        ByteString getInputBytes(int index);

        /**
         * <pre>
         * Input corpus format:
         * "text": one-sentence-per-line text format (default)
         * "tsv":  sentence &lt;tab&gt; freq
         * </pre>
         *
         * <code>optional string input_format = 7;</code>
         *
         * @return Whether the inputFormat field is set.
         */
        boolean hasInputFormat();

        /**
         * <pre>
         * Input corpus format:
         * "text": one-sentence-per-line text format (default)
         * "tsv":  sentence &lt;tab&gt; freq
         * </pre>
         *
         * <code>optional string input_format = 7;</code>
         *
         * @return The inputFormat.
         */
        String getInputFormat();

        /**
         * <pre>
         * Input corpus format:
         * "text": one-sentence-per-line text format (default)
         * "tsv":  sentence &lt;tab&gt; freq
         * </pre>
         *
         * <code>optional string input_format = 7;</code>
         *
         * @return The bytes for inputFormat.
         */
        ByteString getInputFormatBytes();

        /**
         * <pre>
         * Output model file prefix.
         * &lt;model_prefix&gt;.model and &lt;model_prefix&gt;.vocab are generated.
         * </pre>
         *
         * <code>optional string model_prefix = 2;</code>
         *
         * @return Whether the modelPrefix field is set.
         */
        boolean hasModelPrefix();

        /**
         * <pre>
         * Output model file prefix.
         * &lt;model_prefix&gt;.model and &lt;model_prefix&gt;.vocab are generated.
         * </pre>
         *
         * <code>optional string model_prefix = 2;</code>
         *
         * @return The modelPrefix.
         */
        String getModelPrefix();

        /**
         * <pre>
         * Output model file prefix.
         * &lt;model_prefix&gt;.model and &lt;model_prefix&gt;.vocab are generated.
         * </pre>
         *
         * <code>optional string model_prefix = 2;</code>
         *
         * @return The bytes for modelPrefix.
         */
        ByteString getModelPrefixBytes();

        /**
         * <code>optional .sentencepiece.TrainerSpec.ModelType model_type = 3 [default = UNIGRAM];</code>
         *
         * @return Whether the modelType field is set.
         */
        boolean hasModelType();

        /**
         * <code>optional .sentencepiece.TrainerSpec.ModelType model_type = 3 [default = UNIGRAM];</code>
         *
         * @return The modelType.
         */
        TrainerSpec.ModelType getModelType();

        /**
         * <pre>
         * Vocabulary size. 8k is the default size.
         * </pre>
         *
         * <code>optional int32 vocab_size = 4 [default = 8000];</code>
         *
         * @return Whether the vocabSize field is set.
         */
        boolean hasVocabSize();

        /**
         * <pre>
         * Vocabulary size. 8k is the default size.
         * </pre>
         *
         * <code>optional int32 vocab_size = 4 [default = 8000];</code>
         *
         * @return The vocabSize.
         */
        int getVocabSize();

        /**
         * <pre>
         * List of the languages this model can accept.
         * Since the model is language-agnostic, this field is used as a reference.
         * </pre>
         *
         * <code>repeated string accept_language = 5;</code>
         *
         * @return A list containing the acceptLanguage.
         */
        List<String> getAcceptLanguageList();

        /**
         * <pre>
         * List of the languages this model can accept.
         * Since the model is language-agnostic, this field is used as a reference.
         * </pre>
         *
         * <code>repeated string accept_language = 5;</code>
         *
         * @return The count of acceptLanguage.
         */
        int getAcceptLanguageCount();

        /**
         * <pre>
         * List of the languages this model can accept.
         * Since the model is language-agnostic, this field is used as a reference.
         * </pre>
         *
         * <code>repeated string accept_language = 5;</code>
         *
         * @param index The index of the element to return.
         * @return The acceptLanguage at the given index.
         */
        String getAcceptLanguage(int index);

        /**
         * <pre>
         * List of the languages this model can accept.
         * Since the model is language-agnostic, this field is used as a reference.
         * </pre>
         *
         * <code>repeated string accept_language = 5;</code>
         *
         * @param index The index of the value to return.
         * @return The bytes of the acceptLanguage at the given index.
         */
        ByteString getAcceptLanguageBytes(int index);

        /**
         * <pre>
         * Size of self-test samples, which are encoded in the model file.
         * </pre>
         *
         * <code>optional int32 self_test_sample_size = 6 [default = 0];</code>
         *
         * @return Whether the selfTestSampleSize field is set.
         */
        boolean hasSelfTestSampleSize();

        /**
         * <pre>
         * Size of self-test samples, which are encoded in the model file.
         * </pre>
         *
         * <code>optional int32 self_test_sample_size = 6 [default = 0];</code>
         *
         * @return The selfTestSampleSize.
         */
        int getSelfTestSampleSize();

        /**
         * <pre>
         * Whether to use DP version of sentencepiece. Use it with TSV input format
         * (requires precomputed word tab counts to work).
         * </pre>
         *
         * <code>optional bool enable_differential_privacy = 50 [default = false];</code>
         *
         * @return Whether the enableDifferentialPrivacy field is set.
         */
        boolean hasEnableDifferentialPrivacy();

        /**
         * <pre>
         * Whether to use DP version of sentencepiece. Use it with TSV input format
         * (requires precomputed word tab counts to work).
         * </pre>
         *
         * <code>optional bool enable_differential_privacy = 50 [default = false];</code>
         *
         * @return The enableDifferentialPrivacy.
         */
        boolean getEnableDifferentialPrivacy();

        /**
         * <pre>
         * Set these parameters if you need DP version of sentencepiece.
         * std of noise to add.
         * </pre>
         *
         * <code>optional float differential_privacy_noise_level = 51 [default = 0];</code>
         *
         * @return Whether the differentialPrivacyNoiseLevel field is set.
         */
        boolean hasDifferentialPrivacyNoiseLevel();

        /**
         * <pre>
         * Set these parameters if you need DP version of sentencepiece.
         * std of noise to add.
         * </pre>
         *
         * <code>optional float differential_privacy_noise_level = 51 [default = 0];</code>
         *
         * @return The differentialPrivacyNoiseLevel.
         */
        float getDifferentialPrivacyNoiseLevel();

        /**
         * <pre>
         * Clipping threshold to apply after adding noise. All the words with
         * frequency less than this value are dropped.
         * </pre>
         *
         * <code>optional uint64 differential_privacy_clipping_threshold = 52 [default = 0];</code>
         *
         * @return Whether the differentialPrivacyClippingThreshold field is set.
         */
        boolean hasDifferentialPrivacyClippingThreshold();

        /**
         * <pre>
         * Clipping threshold to apply after adding noise. All the words with
         * frequency less than this value are dropped.
         * </pre>
         *
         * <code>optional uint64 differential_privacy_clipping_threshold = 52 [default = 0];</code>
         *
         * @return The differentialPrivacyClippingThreshold.
         */
        long getDifferentialPrivacyClippingThreshold();

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * Training parameters.
         *
         * Uses characters which cover the corpus with the ratio of `chars_coverage`.
         * This parameter determines the set of basic Alphabet of sentence piece.
         * 1.0 - `chars_coverage` characters are treated as UNK.
         * See also required_chars field.
         * </pre>
         *
         * <code>optional float character_coverage = 10 [default = 0.9995];</code>
         *
         * @return Whether the characterCoverage field is set.
         */
        boolean hasCharacterCoverage();

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * Training parameters.
         *
         * Uses characters which cover the corpus with the ratio of `chars_coverage`.
         * This parameter determines the set of basic Alphabet of sentence piece.
         * 1.0 - `chars_coverage` characters are treated as UNK.
         * See also required_chars field.
         * </pre>
         *
         * <code>optional float character_coverage = 10 [default = 0.9995];</code>
         *
         * @return The characterCoverage.
         */
        float getCharacterCoverage();

        /**
         * <pre>
         * Maximum size of sentences the trainer loads from `input` parameter.
         * Trainer simply loads the `input` files in sequence.
         * It is better to shuffle the input corpus randomly.
         * </pre>
         *
         * <code>optional uint64 input_sentence_size = 11 [default = 0];</code>
         *
         * @return Whether the inputSentenceSize field is set.
         */
        boolean hasInputSentenceSize();

        /**
         * <pre>
         * Maximum size of sentences the trainer loads from `input` parameter.
         * Trainer simply loads the `input` files in sequence.
         * It is better to shuffle the input corpus randomly.
         * </pre>
         *
         * <code>optional uint64 input_sentence_size = 11 [default = 0];</code>
         *
         * @return The inputSentenceSize.
         */
        long getInputSentenceSize();

        /**
         * <code>optional bool shuffle_input_sentence = 19 [default = true];</code>
         *
         * @return Whether the shuffleInputSentence field is set.
         */
        boolean hasShuffleInputSentence();

        /**
         * <code>optional bool shuffle_input_sentence = 19 [default = true];</code>
         *
         * @return The shuffleInputSentence.
         */
        boolean getShuffleInputSentence();

        /**
         * <pre>
         * Maximum size of sentences to make seed sentence pieces.
         * Extended suffix array is constructed to extract frequent
         * sub-strings from the corpus. This uses 20N working space,
         * where N is the size of corpus.
         * </pre>
         *
         * <code>optional int32 mining_sentence_size = 12 [deprecated = true];</code>
         *
         * @return Whether the miningSentenceSize field is set.
         * @deprecated sentencepiece.TrainerSpec.mining_sentence_size is deprecated.
         * See sentencepiece_model.proto;l=94
         */
        @Deprecated
        boolean hasMiningSentenceSize();

        /**
         * <pre>
         * Maximum size of sentences to make seed sentence pieces.
         * Extended suffix array is constructed to extract frequent
         * sub-strings from the corpus. This uses 20N working space,
         * where N is the size of corpus.
         * </pre>
         *
         * <code>optional int32 mining_sentence_size = 12 [deprecated = true];</code>
         *
         * @return The miningSentenceSize.
         * @deprecated sentencepiece.TrainerSpec.mining_sentence_size is deprecated.
         * See sentencepiece_model.proto;l=94
         */
        @Deprecated
        int getMiningSentenceSize();

        /**
         * <pre>
         * Maximum size of sentences to train sentence pieces.
         * </pre>
         *
         * <code>optional int32 training_sentence_size = 13 [deprecated = true];</code>
         *
         * @return Whether the trainingSentenceSize field is set.
         * @deprecated sentencepiece.TrainerSpec.training_sentence_size is deprecated.
         * See sentencepiece_model.proto;l=97
         */
        @Deprecated
        boolean hasTrainingSentenceSize();

        /**
         * <pre>
         * Maximum size of sentences to train sentence pieces.
         * </pre>
         *
         * <code>optional int32 training_sentence_size = 13 [deprecated = true];</code>
         *
         * @return The trainingSentenceSize.
         * @deprecated sentencepiece.TrainerSpec.training_sentence_size is deprecated.
         * See sentencepiece_model.proto;l=97
         */
        @Deprecated
        int getTrainingSentenceSize();

        /**
         * <pre>
         * The size of seed sentencepieces.
         * `seed_sentencepiece_size` must be larger than `vocab_size`.
         * </pre>
         *
         * <code>optional int32 seed_sentencepiece_size = 14 [default = 1000000];</code>
         *
         * @return Whether the seedSentencepieceSize field is set.
         */
        boolean hasSeedSentencepieceSize();

        /**
         * <pre>
         * The size of seed sentencepieces.
         * `seed_sentencepiece_size` must be larger than `vocab_size`.
         * </pre>
         *
         * <code>optional int32 seed_sentencepiece_size = 14 [default = 1000000];</code>
         *
         * @return The seedSentencepieceSize.
         */
        int getSeedSentencepieceSize();

        /**
         * <pre>
         * In every EM sub-iterations, keeps top
         * `shrinking_factor` * `current sentencepieces size` with respect to
         * the loss of the sentence piece. This value should be smaller than 1.0.
         * </pre>
         *
         * <code>optional float shrinking_factor = 15 [default = 0.75];</code>
         *
         * @return Whether the shrinkingFactor field is set.
         */
        boolean hasShrinkingFactor();

        /**
         * <pre>
         * In every EM sub-iterations, keeps top
         * `shrinking_factor` * `current sentencepieces size` with respect to
         * the loss of the sentence piece. This value should be smaller than 1.0.
         * </pre>
         *
         * <code>optional float shrinking_factor = 15 [default = 0.75];</code>
         *
         * @return The shrinkingFactor.
         */
        float getShrinkingFactor();

        /**
         * <pre>
         * The maximum sentence length in byte. The sentences with the length
         * larger than `max_sentence_length` is simply ignored.
         * Longer input tends to bring the following risks:
         * * Overflow during EM training (unigram language model only)
         * * Performance drop because of O(n log n) cost in BPE.
         * </pre>
         *
         * <code>optional int32 max_sentence_length = 18 [default = 4192];</code>
         *
         * @return Whether the maxSentenceLength field is set.
         */
        boolean hasMaxSentenceLength();

        /**
         * <pre>
         * The maximum sentence length in byte. The sentences with the length
         * larger than `max_sentence_length` is simply ignored.
         * Longer input tends to bring the following risks:
         * * Overflow during EM training (unigram language model only)
         * * Performance drop because of O(n log n) cost in BPE.
         * </pre>
         *
         * <code>optional int32 max_sentence_length = 18 [default = 4192];</code>
         *
         * @return The maxSentenceLength.
         */
        int getMaxSentenceLength();

        /**
         * <pre>
         * Number of threads in the training.
         * </pre>
         *
         * <code>optional int32 num_threads = 16 [default = 16];</code>
         *
         * @return Whether the numThreads field is set.
         */
        boolean hasNumThreads();

        /**
         * <pre>
         * Number of threads in the training.
         * </pre>
         *
         * <code>optional int32 num_threads = 16 [default = 16];</code>
         *
         * @return The numThreads.
         */
        int getNumThreads();

        /**
         * <pre>
         * Number of EM sub iterations.
         * </pre>
         *
         * <code>optional int32 num_sub_iterations = 17 [default = 2];</code>
         *
         * @return Whether the numSubIterations field is set.
         */
        boolean hasNumSubIterations();

        /**
         * <pre>
         * Number of EM sub iterations.
         * </pre>
         *
         * <code>optional int32 num_sub_iterations = 17 [default = 2];</code>
         *
         * @return The numSubIterations.
         */
        int getNumSubIterations();

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * SentencePiece parameters which control the shapes of sentence piece.
         *
         * Maximum length of sentencepiece.
         * </pre>
         *
         * <code>optional int32 max_sentencepiece_length = 20 [default = 16];</code>
         *
         * @return Whether the maxSentencepieceLength field is set.
         */
        boolean hasMaxSentencepieceLength();

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * SentencePiece parameters which control the shapes of sentence piece.
         *
         * Maximum length of sentencepiece.
         * </pre>
         *
         * <code>optional int32 max_sentencepiece_length = 20 [default = 16];</code>
         *
         * @return The maxSentencepieceLength.
         */
        int getMaxSentencepieceLength();

        /**
         * <pre>
         * Uses Unicode script to split sentence pieces.
         * When `split_by_unicode_script` is true, we do not allow sentence piece to
         * include multiple Unicode scripts, e.g. "F1" is not a valid piece.
         * Exception: CJ characters (Hiragana/Katakana/Han) are all handled
         * as one script type, since Japanese word can consist of multiple scripts.
         * This exception is always applied regardless of the accept-language
         * parameter.
         * </pre>
         *
         * <code>optional bool split_by_unicode_script = 21 [default = true];</code>
         *
         * @return Whether the splitByUnicodeScript field is set.
         */
        boolean hasSplitByUnicodeScript();

        /**
         * <pre>
         * Uses Unicode script to split sentence pieces.
         * When `split_by_unicode_script` is true, we do not allow sentence piece to
         * include multiple Unicode scripts, e.g. "F1" is not a valid piece.
         * Exception: CJ characters (Hiragana/Katakana/Han) are all handled
         * as one script type, since Japanese word can consist of multiple scripts.
         * This exception is always applied regardless of the accept-language
         * parameter.
         * </pre>
         *
         * <code>optional bool split_by_unicode_script = 21 [default = true];</code>
         *
         * @return The splitByUnicodeScript.
         */
        boolean getSplitByUnicodeScript();

        /**
         * <pre>
         * When `split_by_number` is true, put a boundary between number and
         * non-number transition. If we want to treat "F1" is one token, set this flag
         * to be false.
         * </pre>
         *
         * <code>optional bool split_by_number = 23 [default = true];</code>
         *
         * @return Whether the splitByNumber field is set.
         */
        boolean hasSplitByNumber();

        /**
         * <pre>
         * When `split_by_number` is true, put a boundary between number and
         * non-number transition. If we want to treat "F1" is one token, set this flag
         * to be false.
         * </pre>
         *
         * <code>optional bool split_by_number = 23 [default = true];</code>
         *
         * @return The splitByNumber.
         */
        boolean getSplitByNumber();

        /**
         * <pre>
         * Use a white space to split sentence pieces.
         * When `split_by_whitespace` is false, we may have the piece containing
         * a white space in the middle. e.g., "in_the".
         * </pre>
         *
         * <code>optional bool split_by_whitespace = 22 [default = true];</code>
         *
         * @return Whether the splitByWhitespace field is set.
         */
        boolean hasSplitByWhitespace();

        /**
         * <pre>
         * Use a white space to split sentence pieces.
         * When `split_by_whitespace` is false, we may have the piece containing
         * a white space in the middle. e.g., "in_the".
         * </pre>
         *
         * <code>optional bool split_by_whitespace = 22 [default = true];</code>
         *
         * @return The splitByWhitespace.
         */
        boolean getSplitByWhitespace();

        /**
         * <pre>
         * Adds whitespace symbol (_) as a suffix instead of prefix. e.g., _hello =&gt;
         * hello_. When `treat_whitespace_as_suffix` is true,
         * NormalizerSpec::add_dummy_prefix will add the dummy whitespace to the end
         * of sentence.
         * </pre>
         *
         * <code>optional bool treat_whitespace_as_suffix = 24 [default = false];</code>
         *
         * @return Whether the treatWhitespaceAsSuffix field is set.
         */
        boolean hasTreatWhitespaceAsSuffix();

        /**
         * <pre>
         * Adds whitespace symbol (_) as a suffix instead of prefix. e.g., _hello =&gt;
         * hello_. When `treat_whitespace_as_suffix` is true,
         * NormalizerSpec::add_dummy_prefix will add the dummy whitespace to the end
         * of sentence.
         * </pre>
         *
         * <code>optional bool treat_whitespace_as_suffix = 24 [default = false];</code>
         *
         * @return The treatWhitespaceAsSuffix.
         */
        boolean getTreatWhitespaceAsSuffix();

        /**
         * <pre>
         * Allows pieces that only contain whitespaces instead of appearing only as
         * prefix or suffix of other pieces.
         * </pre>
         *
         * <code>optional bool allow_whitespace_only_pieces = 26 [default = false];</code>
         *
         * @return Whether the allowWhitespaceOnlyPieces field is set.
         */
        boolean hasAllowWhitespaceOnlyPieces();

        /**
         * <pre>
         * Allows pieces that only contain whitespaces instead of appearing only as
         * prefix or suffix of other pieces.
         * </pre>
         *
         * <code>optional bool allow_whitespace_only_pieces = 26 [default = false];</code>
         *
         * @return The allowWhitespaceOnlyPieces.
         */
        boolean getAllowWhitespaceOnlyPieces();

        /**
         * <pre>
         * Split all digits (0-9) into separate pieces.
         * </pre>
         *
         * <code>optional bool split_digits = 25 [default = false];</code>
         *
         * @return Whether the splitDigits field is set.
         */
        boolean hasSplitDigits();

        /**
         * <pre>
         * Split all digits (0-9) into separate pieces.
         * </pre>
         *
         * <code>optional bool split_digits = 25 [default = false];</code>
         *
         * @return The splitDigits.
         */
        boolean getSplitDigits();

        /**
         * <pre>
         * Defines the pre-tokenization delimiter.
         * When specified, no pieces crossing this delimiter is not included
         * in the vocab. Then the delimiter string is virtually ignored
         * during the training. This field can allows constraints on the vocabulary
         * selection. Note that this field is available on unigram mode.
         * </pre>
         *
         * <code>optional string pretokenization_delimiter = 53 [default = ""];</code>
         *
         * @return Whether the pretokenizationDelimiter field is set.
         */
        boolean hasPretokenizationDelimiter();

        /**
         * <pre>
         * Defines the pre-tokenization delimiter.
         * When specified, no pieces crossing this delimiter is not included
         * in the vocab. Then the delimiter string is virtually ignored
         * during the training. This field can allows constraints on the vocabulary
         * selection. Note that this field is available on unigram mode.
         * </pre>
         *
         * <code>optional string pretokenization_delimiter = 53 [default = ""];</code>
         *
         * @return The pretokenizationDelimiter.
         */
        String getPretokenizationDelimiter();

        /**
         * <pre>
         * Defines the pre-tokenization delimiter.
         * When specified, no pieces crossing this delimiter is not included
         * in the vocab. Then the delimiter string is virtually ignored
         * during the training. This field can allows constraints on the vocabulary
         * selection. Note that this field is available on unigram mode.
         * </pre>
         *
         * <code>optional string pretokenization_delimiter = 53 [default = ""];</code>
         *
         * @return The bytes for pretokenizationDelimiter.
         */
        ByteString
        getPretokenizationDelimiterBytes();

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * Vocabulary management
         *
         * Defines control symbols used as an indicator to
         * change the behavior of the decoder. &lt;s&gt; and &lt;/s&gt; are pre-defined.
         * We can use this field to encode various meta information,
         * including language indicator in multilingual model.
         * These symbols are not visible to users, but visible to
         * the decoder. Note that when the input sentence contains control symbols,
         * they are not treated as one token, but segmented into normal pieces.
         * Control symbols must be inserted independently from the segmentation.
         * </pre>
         *
         * <code>repeated string control_symbols = 30;</code>
         *
         * @return A list containing the controlSymbols.
         */
        List<String>
        getControlSymbolsList();

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * Vocabulary management
         *
         * Defines control symbols used as an indicator to
         * change the behavior of the decoder. &lt;s&gt; and &lt;/s&gt; are pre-defined.
         * We can use this field to encode various meta information,
         * including language indicator in multilingual model.
         * These symbols are not visible to users, but visible to
         * the decoder. Note that when the input sentence contains control symbols,
         * they are not treated as one token, but segmented into normal pieces.
         * Control symbols must be inserted independently from the segmentation.
         * </pre>
         *
         * <code>repeated string control_symbols = 30;</code>
         *
         * @return The count of controlSymbols.
         */
        int getControlSymbolsCount();

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * Vocabulary management
         *
         * Defines control symbols used as an indicator to
         * change the behavior of the decoder. &lt;s&gt; and &lt;/s&gt; are pre-defined.
         * We can use this field to encode various meta information,
         * including language indicator in multilingual model.
         * These symbols are not visible to users, but visible to
         * the decoder. Note that when the input sentence contains control symbols,
         * they are not treated as one token, but segmented into normal pieces.
         * Control symbols must be inserted independently from the segmentation.
         * </pre>
         *
         * <code>repeated string control_symbols = 30;</code>
         *
         * @param index The index of the element to return.
         * @return The controlSymbols at the given index.
         */
        String getControlSymbols(int index);

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * Vocabulary management
         *
         * Defines control symbols used as an indicator to
         * change the behavior of the decoder. &lt;s&gt; and &lt;/s&gt; are pre-defined.
         * We can use this field to encode various meta information,
         * including language indicator in multilingual model.
         * These symbols are not visible to users, but visible to
         * the decoder. Note that when the input sentence contains control symbols,
         * they are not treated as one token, but segmented into normal pieces.
         * Control symbols must be inserted independently from the segmentation.
         * </pre>
         *
         * <code>repeated string control_symbols = 30;</code>
         *
         * @param index The index of the value to return.
         * @return The bytes of the controlSymbols at the given index.
         */
        ByteString getControlSymbolsBytes(int index);

        /**
         * <pre>
         * Defines user defined symbols.
         * These symbols are added with extremely high score
         * so they are always treated as one unique symbol in any context.
         * Typical usage of user_defined_symbols is placeholder for named entities.
         * </pre>
         *
         * <code>repeated string user_defined_symbols = 31;</code>
         *
         * @return A list containing the userDefinedSymbols.
         */
        List<String> getUserDefinedSymbolsList();

        /**
         * <pre>
         * Defines user defined symbols.
         * These symbols are added with extremely high score
         * so they are always treated as one unique symbol in any context.
         * Typical usage of user_defined_symbols is placeholder for named entities.
         * </pre>
         *
         * <code>repeated string user_defined_symbols = 31;</code>
         *
         * @return The count of userDefinedSymbols.
         */
        int getUserDefinedSymbolsCount();

        /**
         * <pre>
         * Defines user defined symbols.
         * These symbols are added with extremely high score
         * so they are always treated as one unique symbol in any context.
         * Typical usage of user_defined_symbols is placeholder for named entities.
         * </pre>
         *
         * <code>repeated string user_defined_symbols = 31;</code>
         *
         * @param index The index of the element to return.
         * @return The userDefinedSymbols at the given index.
         */
        String getUserDefinedSymbols(int index);

        /**
         * <pre>
         * Defines user defined symbols.
         * These symbols are added with extremely high score
         * so they are always treated as one unique symbol in any context.
         * Typical usage of user_defined_symbols is placeholder for named entities.
         * </pre>
         *
         * <code>repeated string user_defined_symbols = 31;</code>
         *
         * @param index The index of the value to return.
         * @return The bytes of the userDefinedSymbols at the given index.
         */
        ByteString getUserDefinedSymbolsBytes(int index);

        /**
         * <pre>
         * Defines required characters. Each UTF8 character in this string is included
         * in the character set regardless of character_coverage value. Unlike
         * user_defined_symbols, these characters have scores based on the frequency
         * on input sentences, and the model can form subwords using characters
         * in this field.
         * </pre>
         *
         * <code>optional string required_chars = 36;</code>
         *
         * @return Whether the requiredChars field is set.
         */
        boolean hasRequiredChars();

        /**
         * <pre>
         * Defines required characters. Each UTF8 character in this string is included
         * in the character set regardless of character_coverage value. Unlike
         * user_defined_symbols, these characters have scores based on the frequency
         * on input sentences, and the model can form subwords using characters
         * in this field.
         * </pre>
         *
         * <code>optional string required_chars = 36;</code>
         *
         * @return The requiredChars.
         */
        String getRequiredChars();

        /**
         * <pre>
         * Defines required characters. Each UTF8 character in this string is included
         * in the character set regardless of character_coverage value. Unlike
         * user_defined_symbols, these characters have scores based on the frequency
         * on input sentences, and the model can form subwords using characters
         * in this field.
         * </pre>
         *
         * <code>optional string required_chars = 36;</code>
         *
         * @return The bytes for requiredChars.
         */
        ByteString getRequiredCharsBytes();

        /**
         * <pre>
         * Decomposes unknown pieces into UTF-8 bytes.
         * </pre>
         *
         * <code>optional bool byte_fallback = 35 [default = false];</code>
         *
         * @return Whether the byteFallback field is set.
         */
        boolean hasByteFallback();

        /**
         * <pre>
         * Decomposes unknown pieces into UTF-8 bytes.
         * </pre>
         *
         * <code>optional bool byte_fallback = 35 [default = false];</code>
         *
         * @return The byteFallback.
         */
        boolean getByteFallback();

        /**
         * <pre>
         * When creating the vocabulary file, defines whether or not to additionally
         * output the score for each piece.
         * </pre>
         *
         * <code>optional bool vocabulary_output_piece_score = 32 [default = true];</code>
         *
         * @return Whether the vocabularyOutputPieceScore field is set.
         */
        boolean hasVocabularyOutputPieceScore();

        /**
         * <pre>
         * When creating the vocabulary file, defines whether or not to additionally
         * output the score for each piece.
         * </pre>
         *
         * <code>optional bool vocabulary_output_piece_score = 32 [default = true];</code>
         *
         * @return The vocabularyOutputPieceScore.
         */
        boolean getVocabularyOutputPieceScore();

        /**
         * <pre>
         * `vocab_size` is treated as hard limit. Crash if
         * the model can not produce the vocab of size `vocab_size`,
         * When `hard_vocab_limit` is false, vocab_size is treated
         * as soft limit. Note that when model_type=char,
         * always assumes hard_vocab_limit = false.
         * </pre>
         *
         * <code>optional bool hard_vocab_limit = 33 [default = true];</code>
         *
         * @return Whether the hardVocabLimit field is set.
         */
        boolean hasHardVocabLimit();

        /**
         * <pre>
         * `vocab_size` is treated as hard limit. Crash if
         * the model can not produce the vocab of size `vocab_size`,
         * When `hard_vocab_limit` is false, vocab_size is treated
         * as soft limit. Note that when model_type=char,
         * always assumes hard_vocab_limit = false.
         * </pre>
         *
         * <code>optional bool hard_vocab_limit = 33 [default = true];</code>
         *
         * @return The hardVocabLimit.
         */
        boolean getHardVocabLimit();

        /**
         * <pre>
         * use all symbols for vocab extraction. This flag is valid
         * if model type is either CHAR or WORD
         * </pre>
         *
         * <code>optional bool use_all_vocab = 34 [default = false];</code>
         *
         * @return Whether the useAllVocab field is set.
         */
        boolean hasUseAllVocab();

        /**
         * <pre>
         * use all symbols for vocab extraction. This flag is valid
         * if model type is either CHAR or WORD
         * </pre>
         *
         * <code>optional bool use_all_vocab = 34 [default = false];</code>
         *
         * @return The useAllVocab.
         */
        boolean getUseAllVocab();

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * Reserved special meta tokens.
         * * -1 is not used.
         * * unk_id must not be -1.
         * Id must starts with 0 and be contigous.
         * </pre>
         *
         * <code>optional int32 unk_id = 40 [default = 0];</code>
         *
         * @return Whether the unkId field is set.
         */
        boolean hasUnkId();

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * Reserved special meta tokens.
         * * -1 is not used.
         * * unk_id must not be -1.
         * Id must starts with 0 and be contigous.
         * </pre>
         *
         * <code>optional int32 unk_id = 40 [default = 0];</code>
         *
         * @return The unkId.
         */
        int getUnkId();

        /**
         * <pre>
         * &lt;s&gt;
         * </pre>
         *
         * <code>optional int32 bos_id = 41 [default = 1];</code>
         *
         * @return Whether the bosId field is set.
         */
        boolean hasBosId();

        /**
         * <pre>
         * &lt;s&gt;
         * </pre>
         *
         * <code>optional int32 bos_id = 41 [default = 1];</code>
         *
         * @return The bosId.
         */
        int getBosId();

        /**
         * <pre>
         * &lt;/s&gt;
         * </pre>
         *
         * <code>optional int32 eos_id = 42 [default = 2];</code>
         *
         * @return Whether the eosId field is set.
         */
        boolean hasEosId();

        /**
         * <pre>
         * &lt;/s&gt;
         * </pre>
         *
         * <code>optional int32 eos_id = 42 [default = 2];</code>
         *
         * @return The eosId.
         */
        int getEosId();

        /**
         * <pre>
         * &lt;pad&gt; (padding)
         * </pre>
         *
         * <code>optional int32 pad_id = 43 [default = -1];</code>
         *
         * @return Whether the padId field is set.
         */
        boolean hasPadId();

        /**
         * <pre>
         * &lt;pad&gt; (padding)
         * </pre>
         *
         * <code>optional int32 pad_id = 43 [default = -1];</code>
         *
         * @return The padId.
         */
        int getPadId();

        /**
         * <code>optional string unk_piece = 45 [default = "&lt;unk&gt;"];</code>
         *
         * @return Whether the unkPiece field is set.
         */
        boolean hasUnkPiece();

        /**
         * <code>optional string unk_piece = 45 [default = "&lt;unk&gt;"];</code>
         *
         * @return The unkPiece.
         */
        String getUnkPiece();

        /**
         * <code>optional string unk_piece = 45 [default = "&lt;unk&gt;"];</code>
         *
         * @return The bytes for unkPiece.
         */
        ByteString getUnkPieceBytes();

        /**
         * <code>optional string bos_piece = 46 [default = "&lt;s&gt;"];</code>
         *
         * @return Whether the bosPiece field is set.
         */
        boolean hasBosPiece();

        /**
         * <code>optional string bos_piece = 46 [default = "&lt;s&gt;"];</code>
         *
         * @return The bosPiece.
         */
        String getBosPiece();

        /**
         * <code>optional string bos_piece = 46 [default = "&lt;s&gt;"];</code>
         *
         * @return The bytes for bosPiece.
         */
        ByteString getBosPieceBytes();

        /**
         * <code>optional string eos_piece = 47 [default = "&lt;/s&gt;"];</code>
         *
         * @return Whether the eosPiece field is set.
         */
        boolean hasEosPiece();

        /**
         * <code>optional string eos_piece = 47 [default = "&lt;/s&gt;"];</code>
         *
         * @return The eosPiece.
         */
        String getEosPiece();

        /**
         * <code>optional string eos_piece = 47 [default = "&lt;/s&gt;"];</code>
         *
         * @return The bytes for eosPiece.
         */
        ByteString getEosPieceBytes();

        /**
         * <code>optional string pad_piece = 48 [default = "&lt;pad&gt;"];</code>
         *
         * @return Whether the padPiece field is set.
         */
        boolean hasPadPiece();

        /**
         * <code>optional string pad_piece = 48 [default = "&lt;pad&gt;"];</code>
         *
         * @return The padPiece.
         */
        String getPadPiece();

        /**
         * <code>optional string pad_piece = 48 [default = "&lt;pad&gt;"];</code>
         *
         * @return The bytes for padPiece.
         */
        ByteString getPadPieceBytes();

        /**
         * <pre>
         * Encodes &lt;unk&gt; into U+2047 (DOUBLE QUESTION MARK),
         * since this character can be useful both for user and
         * developer. We can easily figure out that &lt;unk&gt; is emitted.
         * </pre>
         *
         * <code>optional string unk_surface = 44 [default = " &#92;342&#92;201&#92;207 "];</code>
         *
         * @return Whether the unkSurface field is set.
         */
        boolean hasUnkSurface();

        /**
         * <pre>
         * Encodes &lt;unk&gt; into U+2047 (DOUBLE QUESTION MARK),
         * since this character can be useful both for user and
         * developer. We can easily figure out that &lt;unk&gt; is emitted.
         * </pre>
         *
         * <code>optional string unk_surface = 44 [default = " &#92;342&#92;201&#92;207 "];</code>
         *
         * @return The unkSurface.
         */
        String getUnkSurface();

        /**
         * <pre>
         * Encodes &lt;unk&gt; into U+2047 (DOUBLE QUESTION MARK),
         * since this character can be useful both for user and
         * developer. We can easily figure out that &lt;unk&gt; is emitted.
         * </pre>
         *
         * <code>optional string unk_surface = 44 [default = " &#92;342&#92;201&#92;207 "];</code>
         *
         * @return The bytes for unkSurface.
         */
        ByteString getUnkSurfaceBytes();

        /**
         * <pre>
         * Increase bit depth to allow unigram model training on large
         * (&gt;10M sentences) corpora. A Side-effect of enabling this flag
         * is increased memory usage.
         * </pre>
         *
         * <code>optional bool train_extremely_large_corpus = 49 [default = false];</code>
         *
         * @return Whether the trainExtremelyLargeCorpus field is set.
         */
        boolean hasTrainExtremelyLargeCorpus();

        /**
         * <pre>
         * Increase bit depth to allow unigram model training on large
         * (&gt;10M sentences) corpora. A Side-effect of enabling this flag
         * is increased memory usage.
         * </pre>
         *
         * <code>optional bool train_extremely_large_corpus = 49 [default = false];</code>
         *
         * @return The trainExtremelyLargeCorpus.
         */
        boolean getTrainExtremelyLargeCorpus();

        /**
         * <pre>
         * Path to a seed sentencepieces file, with one tab-separated
         * seed sentencepiece &lt;tab&gt; frequency per line.
         * </pre>
         *
         * <code>optional string seed_sentencepieces_file = 54 [default = ""];</code>
         *
         * @return Whether the seedSentencepiecesFile field is set.
         */
        boolean hasSeedSentencepiecesFile();

        /**
         * <pre>
         * Path to a seed sentencepieces file, with one tab-separated
         * seed sentencepiece &lt;tab&gt; frequency per line.
         * </pre>
         *
         * <code>optional string seed_sentencepieces_file = 54 [default = ""];</code>
         *
         * @return The seedSentencepiecesFile.
         */
        String getSeedSentencepiecesFile();

        /**
         * <pre>
         * Path to a seed sentencepieces file, with one tab-separated
         * seed sentencepiece &lt;tab&gt; frequency per line.
         * </pre>
         *
         * <code>optional string seed_sentencepieces_file = 54 [default = ""];</code>
         *
         * @return The bytes for seedSentencepiecesFile.
         */
        ByteString getSeedSentencepiecesFileBytes();
    }

    /**
     * <pre>
     * TrainerSpec encodes a various parameters for SentencePiece training.
     * Next id: 55
     * </pre>
     * <p>
     * Protobuf type {@code sentencepiece.TrainerSpec}
     */
    public static final class TrainerSpec extends
            GeneratedMessage.ExtendableMessage<TrainerSpec> implements
            // @@protoc_insertion_point(message_implements:sentencepiece.TrainerSpec)
            TrainerSpecOrBuilder
    {
        @Serial
        private static final long serialVersionUID = 0L;

        static
        {
            RuntimeVersion.validateProtobufGencodeVersion(
                    RuntimeVersion.RuntimeDomain.PUBLIC,
                    /* major= */ 4,
                    /* minor= */ 26,
                    /* patch= */ 1,
                    /* suffix= */ "",
                    TrainerSpec.class.getName());
        }

        // Use TrainerSpec.newBuilder() to construct.
        private TrainerSpec(ExtendableBuilder<TrainerSpec, ?> builder)
        {
            super(builder);
        }

        private TrainerSpec()
        {
            input_ = LazyStringArrayList.emptyList();
            inputFormat_ = "";
            modelPrefix_ = "";
            modelType_ = 1;
            vocabSize_ = 8000;
            acceptLanguage_ = LazyStringArrayList.emptyList();
            characterCoverage_ = 0.9995F;
            shuffleInputSentence_ = true;
            seedSentencepieceSize_ = 1000000;
            shrinkingFactor_ = 0.75F;
            maxSentenceLength_ = 4192;
            numThreads_ = 16;
            numSubIterations_ = 2;
            maxSentencepieceLength_ = 16;
            splitByUnicodeScript_ = true;
            splitByNumber_ = true;
            splitByWhitespace_ = true;
            pretokenizationDelimiter_ = "";
            controlSymbols_ = LazyStringArrayList.emptyList();
            userDefinedSymbols_ = LazyStringArrayList.emptyList();
            requiredChars_ = "";
            vocabularyOutputPieceScore_ = true;
            hardVocabLimit_ = true;
            bosId_ = 1;
            eosId_ = 2;
            padId_ = -1;
            unkPiece_ = "<unk>";
            bosPiece_ = "<s>";
            eosPiece_ = "</s>";
            padPiece_ = "<pad>";
            unkSurface_ = Internal.stringDefaultValue(" \342\201\207 ");
            seedSentencepiecesFile_ = "";
        }

        public static Descriptors.Descriptor getDescriptor()
        {
            return internal_static_sentencepiece_TrainerSpec_descriptor;
        }

        @Override
        protected FieldAccessorTable internalGetFieldAccessorTable()
        {
            return internal_static_sentencepiece_TrainerSpec_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(TrainerSpec.class, Builder.class);
        }

        /**
         * <pre>
         * Model type. only have UNIGRAM now.
         * </pre>
         * <p>
         * Protobuf enum {@code sentencepiece.TrainerSpec.ModelType}
         */
        public enum ModelType implements ProtocolMessageEnum
        {
            /**
             * <pre>
             * Unigram language model with dynamic algorithm
             * </pre>
             *
             * <code>UNIGRAM = 1;</code>
             */
            UNIGRAM(1),
            /**
             * <pre>
             * Byte Pair Encoding
             * </pre>
             *
             * <code>BPE = 2;</code>
             */
            BPE(2),
            /**
             * <pre>
             * Delimitered by whitespace.
             * </pre>
             *
             * <code>WORD = 3;</code>
             */
            WORD(3),
            /**
             * <pre>
             * tokenizes into character sequence
             * </pre>
             *
             * <code>CHAR = 4;</code>
             */
            CHAR(4);

            static
            {
                RuntimeVersion.validateProtobufGencodeVersion(
                        RuntimeVersion.RuntimeDomain.PUBLIC,
                        /* major= */ 4,
                        /* minor= */ 26,
                        /* patch= */ 1,
                        /* suffix= */ "",
                        ModelType.class.getName());
            }

            /**
             * <pre>
             * Unigram language model with dynamic algorithm
             * </pre>
             *
             * <code>UNIGRAM = 1;</code>
             */
            public static final int UNIGRAM_VALUE = 1;
            /**
             * <pre>
             * Byte Pair Encoding
             * </pre>
             *
             * <code>BPE = 2;</code>
             */
            public static final int BPE_VALUE = 2;
            /**
             * <pre>
             * Delimitered by whitespace.
             * </pre>
             *
             * <code>WORD = 3;</code>
             */
            public static final int WORD_VALUE = 3;
            /**
             * <pre>
             * tokenizes into character sequence
             * </pre>
             *
             * <code>CHAR = 4;</code>
             */
            public static final int CHAR_VALUE = 4;

            public final int getNumber()
            {
                return value;
            }

            /**
             * @param value The numeric wire value of the corresponding enum entry.
             * @return The enum associated with the given numeric wire value.
             * @deprecated Use {@link #forNumber(int)} instead.
             */
            @Deprecated
            public static ModelType valueOf(int value)
            {
                return forNumber(value);
            }

            /**
             * @param value The numeric wire value of the corresponding enum entry.
             * @return The enum associated with the given numeric wire value.
             */
            public static ModelType forNumber(int value)
            {
                return switch (value)
                {
                    case 1 -> UNIGRAM;
                    case 2 -> BPE;
                    case 3 -> WORD;
                    case 4 -> CHAR;
                    default -> null;
                };
            }

            public static Internal.EnumLiteMap<ModelType> internalGetValueMap()
            {
                return internalValueMap;
            }

            private static final Internal.EnumLiteMap<ModelType> internalValueMap = ModelType::forNumber;

            public final Descriptors.EnumValueDescriptor getValueDescriptor()
            {
                return getDescriptor().getValues().get(ordinal());
            }

            public final Descriptors.EnumDescriptor getDescriptorForType()
            {
                return getDescriptor();
            }

            public static Descriptors.EnumDescriptor getDescriptor()
            {
                return TrainerSpec.getDescriptor().getEnumTypes().getFirst();
            }

            private static final ModelType[] VALUES = values();

            public static ModelType valueOf(Descriptors.EnumValueDescriptor desc)
            {
                if (desc.getType() != getDescriptor())
                {
                    throw new IllegalArgumentException("EnumValueDescriptor is not for this type.");
                }
                return VALUES[desc.getIndex()];
            }

            private final int value;

            ModelType(int value)
            {
                this.value = value;
            }

            // @@protoc_insertion_point(enum_scope:sentencepiece.TrainerSpec.ModelType)
        }

        private int bitField0_;
        private int bitField1_;
        public static final int INPUT_FIELD_NUMBER = 1;

        private LazyStringArrayList input_ =
                LazyStringArrayList.emptyList();

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * General parameters
         *
         * Input corpus files.
         * Trainer accepts the following two formats:
         * A) Monolingual: plain text, one sentence per line.
         * B) Bilingual:   TSV, source sentence &lt;tab&gt; target sentence
         * When bilingual data is passed, shared vocabulary model is built.
         * Note that the input file must be raw corpus, not a preprocessed corpus.
         * Trainer only loads the first `input_sentence_size` sentences specified
         * with this parameter.
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         *
         * @return A list containing the input.
         */
        public ProtocolStringList
        getInputList()
        {
            return input_;
        }

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * General parameters
         *
         * Input corpus files.
         * Trainer accepts the following two formats:
         * A) Monolingual: plain text, one sentence per line.
         * B) Bilingual:   TSV, source sentence &lt;tab&gt; target sentence
         * When bilingual data is passed, shared vocabulary model is built.
         * Note that the input file must be raw corpus, not a preprocessed corpus.
         * Trainer only loads the first `input_sentence_size` sentences specified
         * with this parameter.
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         *
         * @return The count of input.
         */
        public int getInputCount()
        {
            return input_.size();
        }

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * General parameters
         *
         * Input corpus files.
         * Trainer accepts the following two formats:
         * A) Monolingual: plain text, one sentence per line.
         * B) Bilingual:   TSV, source sentence &lt;tab&gt; target sentence
         * When bilingual data is passed, shared vocabulary model is built.
         * Note that the input file must be raw corpus, not a preprocessed corpus.
         * Trainer only loads the first `input_sentence_size` sentences specified
         * with this parameter.
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         *
         * @param index The index of the element to return.
         * @return The input at the given index.
         */
        public String getInput(int index)
        {
            return input_.get(index);
        }

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * General parameters
         *
         * Input corpus files.
         * Trainer accepts the following two formats:
         * A) Monolingual: plain text, one sentence per line.
         * B) Bilingual:   TSV, source sentence &lt;tab&gt; target sentence
         * When bilingual data is passed, shared vocabulary model is built.
         * Note that the input file must be raw corpus, not a preprocessed corpus.
         * Trainer only loads the first `input_sentence_size` sentences specified
         * with this parameter.
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         *
         * @param index The index of the value to return.
         * @return The bytes of the input at the given index.
         */
        public ByteString getInputBytes(int index)
        {
            return input_.getByteString(index);
        }

        public static final int INPUT_FORMAT_FIELD_NUMBER = 7;

        private volatile Object inputFormat_ = "";

        /**
         * <pre>
         * Input corpus format:
         * "text": one-sentence-per-line text format (default)
         * "tsv":  sentence &lt;tab&gt; freq
         * </pre>
         *
         * <code>optional string input_format = 7;</code>
         *
         * @return Whether the inputFormat field is set.
         */
        @Override
        public boolean hasInputFormat()
        {
            return ((bitField0_ & 0x00000001) != 0);
        }

        /**
         * <pre>
         * Input corpus format:
         * "text": one-sentence-per-line text format (default)
         * "tsv":  sentence &lt;tab&gt; freq
         * </pre>
         *
         * <code>optional string input_format = 7;</code>
         *
         * @return The inputFormat.
         */
        @Override
        public String getInputFormat()
        {
            Object ref = inputFormat_;
            if (ref instanceof String)
            {
                return (String) ref;
            }
            else
            {
                ByteString bs =
                        (ByteString) ref;
                String s = bs.toStringUtf8();
                if (bs.isValidUtf8())
                {
                    inputFormat_ = s;
                }
                return s;
            }
        }

        /**
         * <pre>
         * Input corpus format:
         * "text": one-sentence-per-line text format (default)
         * "tsv":  sentence &lt;tab&gt; freq
         * </pre>
         *
         * <code>optional string input_format = 7;</code>
         *
         * @return The bytes for inputFormat.
         */
        @Override
        public ByteString
        getInputFormatBytes()
        {
            Object ref = inputFormat_;
            if (ref instanceof String)
            {
                ByteString b =
                        ByteString.copyFromUtf8(
                                (String) ref);
                inputFormat_ = b;
                return b;
            }
            else
            {
                return (ByteString) ref;
            }
        }

        public static final int MODEL_PREFIX_FIELD_NUMBER = 2;

        private volatile Object modelPrefix_ = "";

        /**
         * <pre>
         * Output model file prefix.
         * &lt;model_prefix&gt;.model and &lt;model_prefix&gt;.vocab are generated.
         * </pre>
         *
         * <code>optional string model_prefix = 2;</code>
         *
         * @return Whether the modelPrefix field is set.
         */
        @Override
        public boolean hasModelPrefix()
        {
            return ((bitField0_ & 0x00000002) != 0);
        }

        /**
         * <pre>
         * Output model file prefix.
         * &lt;model_prefix&gt;.model and &lt;model_prefix&gt;.vocab are generated.
         * </pre>
         *
         * <code>optional string model_prefix = 2;</code>
         *
         * @return The modelPrefix.
         */
        @Override
        public String getModelPrefix()
        {
            Object ref = modelPrefix_;
            if (ref instanceof String)
            {
                return (String) ref;
            }
            else
            {
                ByteString bs =
                        (ByteString) ref;
                String s = bs.toStringUtf8();
                if (bs.isValidUtf8())
                {
                    modelPrefix_ = s;
                }
                return s;
            }
        }

        /**
         * <pre>
         * Output model file prefix.
         * &lt;model_prefix&gt;.model and &lt;model_prefix&gt;.vocab are generated.
         * </pre>
         *
         * <code>optional string model_prefix = 2;</code>
         *
         * @return The bytes for modelPrefix.
         */
        @Override
        public ByteString
        getModelPrefixBytes()
        {
            Object ref = modelPrefix_;
            if (ref instanceof String)
            {
                ByteString b =
                        ByteString.copyFromUtf8(
                                (String) ref);
                modelPrefix_ = b;
                return b;
            }
            else
            {
                return (ByteString) ref;
            }
        }

        public static final int MODEL_TYPE_FIELD_NUMBER = 3;
        private int modelType_ = 1;

        /**
         * <code>optional .sentencepiece.TrainerSpec.ModelType model_type = 3 [default = UNIGRAM];</code>
         *
         * @return Whether the modelType field is set.
         */
        @Override
        public boolean hasModelType()
        {
            return ((bitField0_ & 0x00000004) != 0);
        }

        /**
         * <code>optional .sentencepiece.TrainerSpec.ModelType model_type = 3 [default = UNIGRAM];</code>
         *
         * @return The modelType.
         */
        @Override
        public ModelType getModelType()
        {
            ModelType result = ModelType.forNumber(modelType_);
            return result == null ? ModelType.UNIGRAM : result;
        }

        public static final int VOCAB_SIZE_FIELD_NUMBER = 4;
        private int vocabSize_ = 8000;

        /**
         * <pre>
         * Vocabulary size. 8k is the default size.
         * </pre>
         *
         * <code>optional int32 vocab_size = 4 [default = 8000];</code>
         *
         * @return Whether the vocabSize field is set.
         */
        @Override
        public boolean hasVocabSize()
        {
            return ((bitField0_ & 0x00000008) != 0);
        }

        /**
         * <pre>
         * Vocabulary size. 8k is the default size.
         * </pre>
         *
         * <code>optional int32 vocab_size = 4 [default = 8000];</code>
         *
         * @return The vocabSize.
         */
        @Override
        public int getVocabSize()
        {
            return vocabSize_;
        }

        public static final int ACCEPT_LANGUAGE_FIELD_NUMBER = 5;

        private LazyStringArrayList acceptLanguage_ =
                LazyStringArrayList.emptyList();

        /**
         * <pre>
         * List of the languages this model can accept.
         * Since the model is language-agnostic, this field is used as a reference.
         * </pre>
         *
         * <code>repeated string accept_language = 5;</code>
         *
         * @return A list containing the acceptLanguage.
         */
        public ProtocolStringList
        getAcceptLanguageList()
        {
            return acceptLanguage_;
        }

        /**
         * <pre>
         * List of the languages this model can accept.
         * Since the model is language-agnostic, this field is used as a reference.
         * </pre>
         *
         * <code>repeated string accept_language = 5;</code>
         *
         * @return The count of acceptLanguage.
         */
        public int getAcceptLanguageCount()
        {
            return acceptLanguage_.size();
        }

        /**
         * <pre>
         * List of the languages this model can accept.
         * Since the model is language-agnostic, this field is used as a reference.
         * </pre>
         *
         * <code>repeated string accept_language = 5;</code>
         *
         * @param index The index of the element to return.
         * @return The acceptLanguage at the given index.
         */
        public String getAcceptLanguage(int index)
        {
            return acceptLanguage_.get(index);
        }

        /**
         * <pre>
         * List of the languages this model can accept.
         * Since the model is language-agnostic, this field is used as a reference.
         * </pre>
         *
         * <code>repeated string accept_language = 5;</code>
         *
         * @param index The index of the value to return.
         * @return The bytes of the acceptLanguage at the given index.
         */
        public ByteString
        getAcceptLanguageBytes(int index)
        {
            return acceptLanguage_.getByteString(index);
        }

        public static final int SELF_TEST_SAMPLE_SIZE_FIELD_NUMBER = 6;
        private int selfTestSampleSize_ = 0;

        /**
         * <pre>
         * Size of self-test samples, which are encoded in the model file.
         * </pre>
         *
         * <code>optional int32 self_test_sample_size = 6 [default = 0];</code>
         *
         * @return Whether the selfTestSampleSize field is set.
         */
        @Override
        public boolean hasSelfTestSampleSize()
        {
            return ((bitField0_ & 0x00000010) != 0);
        }

        /**
         * <pre>
         * Size of self-test samples, which are encoded in the model file.
         * </pre>
         *
         * <code>optional int32 self_test_sample_size = 6 [default = 0];</code>
         *
         * @return The selfTestSampleSize.
         */
        @Override
        public int getSelfTestSampleSize()
        {
            return selfTestSampleSize_;
        }

        public static final int ENABLE_DIFFERENTIAL_PRIVACY_FIELD_NUMBER = 50;
        private boolean enableDifferentialPrivacy_ = false;

        /**
         * <pre>
         * Whether to use DP version of sentencepiece. Use it with TSV input format
         * (requires precomputed word tab counts to work).
         * </pre>
         *
         * <code>optional bool enable_differential_privacy = 50 [default = false];</code>
         *
         * @return Whether the enableDifferentialPrivacy field is set.
         */
        @Override
        public boolean hasEnableDifferentialPrivacy()
        {
            return ((bitField0_ & 0x00000020) != 0);
        }

        /**
         * <pre>
         * Whether to use DP version of sentencepiece. Use it with TSV input format
         * (requires precomputed word tab counts to work).
         * </pre>
         *
         * <code>optional bool enable_differential_privacy = 50 [default = false];</code>
         *
         * @return The enableDifferentialPrivacy.
         */
        @Override
        public boolean getEnableDifferentialPrivacy()
        {
            return enableDifferentialPrivacy_;
        }

        public static final int DIFFERENTIAL_PRIVACY_NOISE_LEVEL_FIELD_NUMBER = 51;
        private float differentialPrivacyNoiseLevel_ = 0F;

        /**
         * <pre>
         * Set these parameters if you need DP version of sentencepiece.
         * std of noise to add.
         * </pre>
         *
         * <code>optional float differential_privacy_noise_level = 51 [default = 0];</code>
         *
         * @return Whether the differentialPrivacyNoiseLevel field is set.
         */
        @Override
        public boolean hasDifferentialPrivacyNoiseLevel()
        {
            return ((bitField0_ & 0x00000040) != 0);
        }

        /**
         * <pre>
         * Set these parameters if you need DP version of sentencepiece.
         * std of noise to add.
         * </pre>
         *
         * <code>optional float differential_privacy_noise_level = 51 [default = 0];</code>
         *
         * @return The differentialPrivacyNoiseLevel.
         */
        @Override
        public float getDifferentialPrivacyNoiseLevel()
        {
            return differentialPrivacyNoiseLevel_;
        }

        public static final int DIFFERENTIAL_PRIVACY_CLIPPING_THRESHOLD_FIELD_NUMBER = 52;
        private long differentialPrivacyClippingThreshold_ = 0L;

        /**
         * <pre>
         * Clipping threshold to apply after adding noise. All the words with
         * frequency less than this value are dropped.
         * </pre>
         *
         * <code>optional uint64 differential_privacy_clipping_threshold = 52 [default = 0];</code>
         *
         * @return Whether the differentialPrivacyClippingThreshold field is set.
         */
        @Override
        public boolean hasDifferentialPrivacyClippingThreshold()
        {
            return ((bitField0_ & 0x00000080) != 0);
        }

        /**
         * <pre>
         * Clipping threshold to apply after adding noise. All the words with
         * frequency less than this value are dropped.
         * </pre>
         *
         * <code>optional uint64 differential_privacy_clipping_threshold = 52 [default = 0];</code>
         *
         * @return The differentialPrivacyClippingThreshold.
         */
        @Override
        public long getDifferentialPrivacyClippingThreshold()
        {
            return differentialPrivacyClippingThreshold_;
        }

        public static final int CHARACTER_COVERAGE_FIELD_NUMBER = 10;
        private float characterCoverage_ = 0.9995F;

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * Training parameters.
         *
         * Uses characters which cover the corpus with the ratio of `chars_coverage`.
         * This parameter determines the set of basic Alphabet of sentence piece.
         * 1.0 - `chars_coverage` characters are treated as UNK.
         * See also required_chars field.
         * </pre>
         *
         * <code>optional float character_coverage = 10 [default = 0.9995];</code>
         *
         * @return Whether the characterCoverage field is set.
         */
        @Override
        public boolean hasCharacterCoverage()
        {
            return ((bitField0_ & 0x00000100) != 0);
        }

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * Training parameters.
         *
         * Uses characters which cover the corpus with the ratio of `chars_coverage`.
         * This parameter determines the set of basic Alphabet of sentence piece.
         * 1.0 - `chars_coverage` characters are treated as UNK.
         * See also required_chars field.
         * </pre>
         *
         * <code>optional float character_coverage = 10 [default = 0.9995];</code>
         *
         * @return The characterCoverage.
         */
        @Override
        public float getCharacterCoverage()
        {
            return characterCoverage_;
        }

        public static final int INPUT_SENTENCE_SIZE_FIELD_NUMBER = 11;
        private long inputSentenceSize_ = 0L;

        /**
         * <pre>
         * Maximum size of sentences the trainer loads from `input` parameter.
         * Trainer simply loads the `input` files in sequence.
         * It is better to shuffle the input corpus randomly.
         * </pre>
         *
         * <code>optional uint64 input_sentence_size = 11 [default = 0];</code>
         *
         * @return Whether the inputSentenceSize field is set.
         */
        @Override
        public boolean hasInputSentenceSize()
        {
            return ((bitField0_ & 0x00000200) != 0);
        }

        /**
         * <pre>
         * Maximum size of sentences the trainer loads from `input` parameter.
         * Trainer simply loads the `input` files in sequence.
         * It is better to shuffle the input corpus randomly.
         * </pre>
         *
         * <code>optional uint64 input_sentence_size = 11 [default = 0];</code>
         *
         * @return The inputSentenceSize.
         */
        @Override
        public long getInputSentenceSize()
        {
            return inputSentenceSize_;
        }

        public static final int SHUFFLE_INPUT_SENTENCE_FIELD_NUMBER = 19;
        private boolean shuffleInputSentence_ = true;

        /**
         * <code>optional bool shuffle_input_sentence = 19 [default = true];</code>
         *
         * @return Whether the shuffleInputSentence field is set.
         */
        @Override
        public boolean hasShuffleInputSentence()
        {
            return ((bitField0_ & 0x00000400) != 0);
        }

        /**
         * <code>optional bool shuffle_input_sentence = 19 [default = true];</code>
         *
         * @return The shuffleInputSentence.
         */
        @Override
        public boolean getShuffleInputSentence()
        {
            return shuffleInputSentence_;
        }

        public static final int MINING_SENTENCE_SIZE_FIELD_NUMBER = 12;
        private int miningSentenceSize_ = 0;

        /**
         * <pre>
         * Maximum size of sentences to make seed sentence pieces.
         * Extended suffix array is constructed to extract frequent
         * sub-strings from the corpus. This uses 20N working space,
         * where N is the size of corpus.
         * </pre>
         *
         * <code>optional int32 mining_sentence_size = 12 [deprecated = true];</code>
         *
         * @return Whether the miningSentenceSize field is set.
         * @deprecated sentencepiece.TrainerSpec.mining_sentence_size is deprecated.
         * See sentencepiece_model.proto;l=94
         */
        @Override
        @Deprecated
        public boolean hasMiningSentenceSize()
        {
            return ((bitField0_ & 0x00000800) != 0);
        }

        /**
         * <pre>
         * Maximum size of sentences to make seed sentence pieces.
         * Extended suffix array is constructed to extract frequent
         * sub-strings from the corpus. This uses 20N working space,
         * where N is the size of corpus.
         * </pre>
         *
         * <code>optional int32 mining_sentence_size = 12 [deprecated = true];</code>
         *
         * @return The miningSentenceSize.
         * @deprecated sentencepiece.TrainerSpec.mining_sentence_size is deprecated.
         * See sentencepiece_model.proto;l=94
         */
        @Override
        @Deprecated
        public int getMiningSentenceSize()
        {
            return miningSentenceSize_;
        }

        public static final int TRAINING_SENTENCE_SIZE_FIELD_NUMBER = 13;
        private int trainingSentenceSize_ = 0;

        /**
         * <pre>
         * Maximum size of sentences to train sentence pieces.
         * </pre>
         *
         * <code>optional int32 training_sentence_size = 13 [deprecated = true];</code>
         *
         * @return Whether the trainingSentenceSize field is set.
         * @deprecated sentencepiece.TrainerSpec.training_sentence_size is deprecated.
         * See sentencepiece_model.proto;l=97
         */
        @Override
        @Deprecated
        public boolean hasTrainingSentenceSize()
        {
            return ((bitField0_ & 0x00001000) != 0);
        }

        /**
         * <pre>
         * Maximum size of sentences to train sentence pieces.
         * </pre>
         *
         * <code>optional int32 training_sentence_size = 13 [deprecated = true];</code>
         *
         * @return The trainingSentenceSize.
         * @deprecated sentencepiece.TrainerSpec.training_sentence_size is deprecated.
         * See sentencepiece_model.proto;l=97
         */
        @Override
        @Deprecated
        public int getTrainingSentenceSize()
        {
            return trainingSentenceSize_;
        }

        public static final int SEED_SENTENCEPIECE_SIZE_FIELD_NUMBER = 14;
        private int seedSentencepieceSize_ = 1000000;

        /**
         * <pre>
         * The size of seed sentencepieces.
         * `seed_sentencepiece_size` must be larger than `vocab_size`.
         * </pre>
         *
         * <code>optional int32 seed_sentencepiece_size = 14 [default = 1000000];</code>
         *
         * @return Whether the seedSentencepieceSize field is set.
         */
        @Override
        public boolean hasSeedSentencepieceSize()
        {
            return ((bitField0_ & 0x00002000) != 0);
        }

        /**
         * <pre>
         * The size of seed sentencepieces.
         * `seed_sentencepiece_size` must be larger than `vocab_size`.
         * </pre>
         *
         * <code>optional int32 seed_sentencepiece_size = 14 [default = 1000000];</code>
         *
         * @return The seedSentencepieceSize.
         */
        @Override
        public int getSeedSentencepieceSize()
        {
            return seedSentencepieceSize_;
        }

        public static final int SHRINKING_FACTOR_FIELD_NUMBER = 15;
        private float shrinkingFactor_ = 0.75F;

        /**
         * <pre>
         * In every EM sub-iterations, keeps top
         * `shrinking_factor` * `current sentencepieces size` with respect to
         * the loss of the sentence piece. This value should be smaller than 1.0.
         * </pre>
         *
         * <code>optional float shrinking_factor = 15 [default = 0.75];</code>
         *
         * @return Whether the shrinkingFactor field is set.
         */
        @Override
        public boolean hasShrinkingFactor()
        {
            return ((bitField0_ & 0x00004000) != 0);
        }

        /**
         * <pre>
         * In every EM sub-iterations, keeps top
         * `shrinking_factor` * `current sentencepieces size` with respect to
         * the loss of the sentence piece. This value should be smaller than 1.0.
         * </pre>
         *
         * <code>optional float shrinking_factor = 15 [default = 0.75];</code>
         *
         * @return The shrinkingFactor.
         */
        @Override
        public float getShrinkingFactor()
        {
            return shrinkingFactor_;
        }

        public static final int MAX_SENTENCE_LENGTH_FIELD_NUMBER = 18;
        private int maxSentenceLength_ = 4192;

        /**
         * <pre>
         * The maximum sentence length in byte. The sentences with the length
         * larger than `max_sentence_length` is simply ignored.
         * Longer input tends to bring the following risks:
         * * Overflow during EM training (unigram language model only)
         * * Performance drop because of O(n log n) cost in BPE.
         * </pre>
         *
         * <code>optional int32 max_sentence_length = 18 [default = 4192];</code>
         *
         * @return Whether the maxSentenceLength field is set.
         */
        @Override
        public boolean hasMaxSentenceLength()
        {
            return ((bitField0_ & 0x00008000) != 0);
        }

        /**
         * <pre>
         * The maximum sentence length in byte. The sentences with the length
         * larger than `max_sentence_length` is simply ignored.
         * Longer input tends to bring the following risks:
         * * Overflow during EM training (unigram language model only)
         * * Performance drop because of O(n log n) cost in BPE.
         * </pre>
         *
         * <code>optional int32 max_sentence_length = 18 [default = 4192];</code>
         *
         * @return The maxSentenceLength.
         */
        @Override
        public int getMaxSentenceLength()
        {
            return maxSentenceLength_;
        }

        public static final int NUM_THREADS_FIELD_NUMBER = 16;
        private int numThreads_ = 16;

        /**
         * <pre>
         * Number of threads in the training.
         * </pre>
         *
         * <code>optional int32 num_threads = 16 [default = 16];</code>
         *
         * @return Whether the numThreads field is set.
         */
        @Override
        public boolean hasNumThreads()
        {
            return ((bitField0_ & 0x00010000) != 0);
        }

        /**
         * <pre>
         * Number of threads in the training.
         * </pre>
         *
         * <code>optional int32 num_threads = 16 [default = 16];</code>
         *
         * @return The numThreads.
         */
        @Override
        public int getNumThreads()
        {
            return numThreads_;
        }

        public static final int NUM_SUB_ITERATIONS_FIELD_NUMBER = 17;
        private int numSubIterations_ = 2;

        /**
         * <pre>
         * Number of EM sub iterations.
         * </pre>
         *
         * <code>optional int32 num_sub_iterations = 17 [default = 2];</code>
         *
         * @return Whether the numSubIterations field is set.
         */
        @Override
        public boolean hasNumSubIterations()
        {
            return ((bitField0_ & 0x00020000) != 0);
        }

        /**
         * <pre>
         * Number of EM sub iterations.
         * </pre>
         *
         * <code>optional int32 num_sub_iterations = 17 [default = 2];</code>
         *
         * @return The numSubIterations.
         */
        @Override
        public int getNumSubIterations()
        {
            return numSubIterations_;
        }

        public static final int MAX_SENTENCEPIECE_LENGTH_FIELD_NUMBER = 20;
        private int maxSentencepieceLength_ = 16;

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * SentencePiece parameters which control the shapes of sentence piece.
         *
         * Maximum length of sentencepiece.
         * </pre>
         *
         * <code>optional int32 max_sentencepiece_length = 20 [default = 16];</code>
         *
         * @return Whether the maxSentencepieceLength field is set.
         */
        @Override
        public boolean hasMaxSentencepieceLength()
        {
            return ((bitField0_ & 0x00040000) != 0);
        }

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * SentencePiece parameters which control the shapes of sentence piece.
         *
         * Maximum length of sentencepiece.
         * </pre>
         *
         * <code>optional int32 max_sentencepiece_length = 20 [default = 16];</code>
         *
         * @return The maxSentencepieceLength.
         */
        @Override
        public int getMaxSentencepieceLength()
        {
            return maxSentencepieceLength_;
        }

        public static final int SPLIT_BY_UNICODE_SCRIPT_FIELD_NUMBER = 21;
        private boolean splitByUnicodeScript_ = true;

        /**
         * <pre>
         * Uses Unicode script to split sentence pieces.
         * When `split_by_unicode_script` is true, we do not allow sentence piece to
         * include multiple Unicode scripts, e.g. "F1" is not a valid piece.
         * Exception: CJ characters (Hiragana/Katakana/Han) are all handled
         * as one script type, since Japanese word can consist of multiple scripts.
         * This exception is always applied regardless of the accept-language
         * parameter.
         * </pre>
         *
         * <code>optional bool split_by_unicode_script = 21 [default = true];</code>
         *
         * @return Whether the splitByUnicodeScript field is set.
         */
        @Override
        public boolean hasSplitByUnicodeScript()
        {
            return ((bitField0_ & 0x00080000) != 0);
        }

        /**
         * <pre>
         * Uses Unicode script to split sentence pieces.
         * When `split_by_unicode_script` is true, we do not allow sentence piece to
         * include multiple Unicode scripts, e.g. "F1" is not a valid piece.
         * Exception: CJ characters (Hiragana/Katakana/Han) are all handled
         * as one script type, since Japanese word can consist of multiple scripts.
         * This exception is always applied regardless of the accept-language
         * parameter.
         * </pre>
         *
         * <code>optional bool split_by_unicode_script = 21 [default = true];</code>
         *
         * @return The splitByUnicodeScript.
         */
        @Override
        public boolean getSplitByUnicodeScript()
        {
            return splitByUnicodeScript_;
        }

        public static final int SPLIT_BY_NUMBER_FIELD_NUMBER = 23;
        private boolean splitByNumber_ = true;

        /**
         * <pre>
         * When `split_by_number` is true, put a boundary between number and
         * non-number transition. If we want to treat "F1" is one token, set this flag
         * to be false.
         * </pre>
         *
         * <code>optional bool split_by_number = 23 [default = true];</code>
         *
         * @return Whether the splitByNumber field is set.
         */
        @Override
        public boolean hasSplitByNumber()
        {
            return ((bitField0_ & 0x00100000) != 0);
        }

        /**
         * <pre>
         * When `split_by_number` is true, put a boundary between number and
         * non-number transition. If we want to treat "F1" is one token, set this flag
         * to be false.
         * </pre>
         *
         * <code>optional bool split_by_number = 23 [default = true];</code>
         *
         * @return The splitByNumber.
         */
        @Override
        public boolean getSplitByNumber()
        {
            return splitByNumber_;
        }

        public static final int SPLIT_BY_WHITESPACE_FIELD_NUMBER = 22;
        private boolean splitByWhitespace_ = true;

        /**
         * <pre>
         * Use a white space to split sentence pieces.
         * When `split_by_whitespace` is false, we may have the piece containing
         * a white space in the middle. e.g., "in_the".
         * </pre>
         *
         * <code>optional bool split_by_whitespace = 22 [default = true];</code>
         *
         * @return Whether the splitByWhitespace field is set.
         */
        @Override
        public boolean hasSplitByWhitespace()
        {
            return ((bitField0_ & 0x00200000) != 0);
        }

        /**
         * <pre>
         * Use a white space to split sentence pieces.
         * When `split_by_whitespace` is false, we may have the piece containing
         * a white space in the middle. e.g., "in_the".
         * </pre>
         *
         * <code>optional bool split_by_whitespace = 22 [default = true];</code>
         *
         * @return The splitByWhitespace.
         */
        @Override
        public boolean getSplitByWhitespace()
        {
            return splitByWhitespace_;
        }

        public static final int TREAT_WHITESPACE_AS_SUFFIX_FIELD_NUMBER = 24;
        private boolean treatWhitespaceAsSuffix_ = false;

        /**
         * <pre>
         * Adds whitespace symbol (_) as a suffix instead of prefix. e.g., _hello =&gt;
         * hello_. When `treat_whitespace_as_suffix` is true,
         * NormalizerSpec::add_dummy_prefix will add the dummy whitespace to the end
         * of sentence.
         * </pre>
         *
         * <code>optional bool treat_whitespace_as_suffix = 24 [default = false];</code>
         *
         * @return Whether the treatWhitespaceAsSuffix field is set.
         */
        @Override
        public boolean hasTreatWhitespaceAsSuffix()
        {
            return ((bitField0_ & 0x00400000) != 0);
        }

        /**
         * <pre>
         * Adds whitespace symbol (_) as a suffix instead of prefix. e.g., _hello =&gt;
         * hello_. When `treat_whitespace_as_suffix` is true,
         * NormalizerSpec::add_dummy_prefix will add the dummy whitespace to the end
         * of sentence.
         * </pre>
         *
         * <code>optional bool treat_whitespace_as_suffix = 24 [default = false];</code>
         *
         * @return The treatWhitespaceAsSuffix.
         */
        @Override
        public boolean getTreatWhitespaceAsSuffix()
        {
            return treatWhitespaceAsSuffix_;
        }

        public static final int ALLOW_WHITESPACE_ONLY_PIECES_FIELD_NUMBER = 26;
        private boolean allowWhitespaceOnlyPieces_ = false;

        /**
         * <pre>
         * Allows pieces that only contain whitespaces instead of appearing only as
         * prefix or suffix of other pieces.
         * </pre>
         *
         * <code>optional bool allow_whitespace_only_pieces = 26 [default = false];</code>
         *
         * @return Whether the allowWhitespaceOnlyPieces field is set.
         */
        @Override
        public boolean hasAllowWhitespaceOnlyPieces()
        {
            return ((bitField0_ & 0x00800000) != 0);
        }

        /**
         * <pre>
         * Allows pieces that only contain whitespaces instead of appearing only as
         * prefix or suffix of other pieces.
         * </pre>
         *
         * <code>optional bool allow_whitespace_only_pieces = 26 [default = false];</code>
         *
         * @return The allowWhitespaceOnlyPieces.
         */
        @Override
        public boolean getAllowWhitespaceOnlyPieces()
        {
            return allowWhitespaceOnlyPieces_;
        }

        public static final int SPLIT_DIGITS_FIELD_NUMBER = 25;
        private boolean splitDigits_ = false;

        /**
         * <pre>
         * Split all digits (0-9) into separate pieces.
         * </pre>
         *
         * <code>optional bool split_digits = 25 [default = false];</code>
         *
         * @return Whether the splitDigits field is set.
         */
        @Override
        public boolean hasSplitDigits()
        {
            return ((bitField0_ & 0x01000000) != 0);
        }

        /**
         * <pre>
         * Split all digits (0-9) into separate pieces.
         * </pre>
         *
         * <code>optional bool split_digits = 25 [default = false];</code>
         *
         * @return The splitDigits.
         */
        @Override
        public boolean getSplitDigits()
        {
            return splitDigits_;
        }

        public static final int PRETOKENIZATION_DELIMITER_FIELD_NUMBER = 53;

        private volatile Object pretokenizationDelimiter_ = "";

        /**
         * <pre>
         * Defines the pre-tokenization delimiter.
         * When specified, no pieces crossing this delimiter is not included
         * in the vocab. Then the delimiter string is virtually ignored
         * during the training. This field can allows constraints on the vocabulary
         * selection. Note that this field is available on unigram mode.
         * </pre>
         *
         * <code>optional string pretokenization_delimiter = 53 [default = ""];</code>
         *
         * @return Whether the pretokenizationDelimiter field is set.
         */
        @Override
        public boolean hasPretokenizationDelimiter()
        {
            return ((bitField0_ & 0x02000000) != 0);
        }

        /**
         * <pre>
         * Defines the pre-tokenization delimiter.
         * When specified, no pieces crossing this delimiter is not included
         * in the vocab. Then the delimiter string is virtually ignored
         * during the training. This field can allows constraints on the vocabulary
         * selection. Note that this field is available on unigram mode.
         * </pre>
         *
         * <code>optional string pretokenization_delimiter = 53 [default = ""];</code>
         *
         * @return The pretokenizationDelimiter.
         */
        @Override
        public String getPretokenizationDelimiter()
        {
            Object ref = pretokenizationDelimiter_;
            if (ref instanceof String)
            {
                return (String) ref;
            }
            else
            {
                ByteString bs = (ByteString) ref;
                String s = bs.toStringUtf8();
                if (bs.isValidUtf8())
                {
                    pretokenizationDelimiter_ = s;
                }
                return s;
            }
        }

        /**
         * <pre>
         * Defines the pre-tokenization delimiter.
         * When specified, no pieces crossing this delimiter is not included
         * in the vocab. Then the delimiter string is virtually ignored
         * during the training. This field can allows constraints on the vocabulary
         * selection. Note that this field is available on unigram mode.
         * </pre>
         *
         * <code>optional string pretokenization_delimiter = 53 [default = ""];</code>
         *
         * @return The bytes for pretokenizationDelimiter.
         */
        @Override
        public ByteString
        getPretokenizationDelimiterBytes()
        {
            Object ref = pretokenizationDelimiter_;
            if (ref instanceof String)
            {
                ByteString b =
                        ByteString.copyFromUtf8(
                                (String) ref);
                pretokenizationDelimiter_ = b;
                return b;
            }
            else
            {
                return (ByteString) ref;
            }
        }

        public static final int CONTROL_SYMBOLS_FIELD_NUMBER = 30;

        private LazyStringArrayList controlSymbols_ =
                LazyStringArrayList.emptyList();

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * Vocabulary management
         *
         * Defines control symbols used as an indicator to
         * change the behavior of the decoder. &lt;s&gt; and &lt;/s&gt; are pre-defined.
         * We can use this field to encode various meta information,
         * including language indicator in multilingual model.
         * These symbols are not visible to users, but visible to
         * the decoder. Note that when the input sentence contains control symbols,
         * they are not treated as one token, but segmented into normal pieces.
         * Control symbols must be inserted independently from the segmentation.
         * </pre>
         *
         * <code>repeated string control_symbols = 30;</code>
         *
         * @return A list containing the controlSymbols.
         */
        public ProtocolStringList
        getControlSymbolsList()
        {
            return controlSymbols_;
        }

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * Vocabulary management
         *
         * Defines control symbols used as an indicator to
         * change the behavior of the decoder. &lt;s&gt; and &lt;/s&gt; are pre-defined.
         * We can use this field to encode various meta information,
         * including language indicator in multilingual model.
         * These symbols are not visible to users, but visible to
         * the decoder. Note that when the input sentence contains control symbols,
         * they are not treated as one token, but segmented into normal pieces.
         * Control symbols must be inserted independently from the segmentation.
         * </pre>
         *
         * <code>repeated string control_symbols = 30;</code>
         *
         * @return The count of controlSymbols.
         */
        public int getControlSymbolsCount()
        {
            return controlSymbols_.size();
        }

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * Vocabulary management
         *
         * Defines control symbols used as an indicator to
         * change the behavior of the decoder. &lt;s&gt; and &lt;/s&gt; are pre-defined.
         * We can use this field to encode various meta information,
         * including language indicator in multilingual model.
         * These symbols are not visible to users, but visible to
         * the decoder. Note that when the input sentence contains control symbols,
         * they are not treated as one token, but segmented into normal pieces.
         * Control symbols must be inserted independently from the segmentation.
         * </pre>
         *
         * <code>repeated string control_symbols = 30;</code>
         *
         * @param index The index of the element to return.
         * @return The controlSymbols at the given index.
         */
        public String getControlSymbols(int index)
        {
            return controlSymbols_.get(index);
        }

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * Vocabulary management
         *
         * Defines control symbols used as an indicator to
         * change the behavior of the decoder. &lt;s&gt; and &lt;/s&gt; are pre-defined.
         * We can use this field to encode various meta information,
         * including language indicator in multilingual model.
         * These symbols are not visible to users, but visible to
         * the decoder. Note that when the input sentence contains control symbols,
         * they are not treated as one token, but segmented into normal pieces.
         * Control symbols must be inserted independently from the segmentation.
         * </pre>
         *
         * <code>repeated string control_symbols = 30;</code>
         *
         * @param index The index of the value to return.
         * @return The bytes of the controlSymbols at the given index.
         */
        public ByteString
        getControlSymbolsBytes(int index)
        {
            return controlSymbols_.getByteString(index);
        }

        public static final int USER_DEFINED_SYMBOLS_FIELD_NUMBER = 31;

        private LazyStringArrayList userDefinedSymbols_ =
                LazyStringArrayList.emptyList();

        /**
         * <pre>
         * Defines user defined symbols.
         * These symbols are added with extremely high score
         * so they are always treated as one unique symbol in any context.
         * Typical usage of user_defined_symbols is placeholder for named entities.
         * </pre>
         *
         * <code>repeated string user_defined_symbols = 31;</code>
         *
         * @return A list containing the userDefinedSymbols.
         */
        public ProtocolStringList
        getUserDefinedSymbolsList()
        {
            return userDefinedSymbols_;
        }

        /**
         * <pre>
         * Defines user defined symbols.
         * These symbols are added with extremely high score
         * so they are always treated as one unique symbol in any context.
         * Typical usage of user_defined_symbols is placeholder for named entities.
         * </pre>
         *
         * <code>repeated string user_defined_symbols = 31;</code>
         *
         * @return The count of userDefinedSymbols.
         */
        public int getUserDefinedSymbolsCount()
        {
            return userDefinedSymbols_.size();
        }

        /**
         * <pre>
         * Defines user defined symbols.
         * These symbols are added with extremely high score
         * so they are always treated as one unique symbol in any context.
         * Typical usage of user_defined_symbols is placeholder for named entities.
         * </pre>
         *
         * <code>repeated string user_defined_symbols = 31;</code>
         *
         * @param index The index of the element to return.
         * @return The userDefinedSymbols at the given index.
         */
        public String getUserDefinedSymbols(int index)
        {
            return userDefinedSymbols_.get(index);
        }

        /**
         * <pre>
         * Defines user defined symbols.
         * These symbols are added with extremely high score
         * so they are always treated as one unique symbol in any context.
         * Typical usage of user_defined_symbols is placeholder for named entities.
         * </pre>
         *
         * <code>repeated string user_defined_symbols = 31;</code>
         *
         * @param index The index of the value to return.
         * @return The bytes of the userDefinedSymbols at the given index.
         */
        public ByteString
        getUserDefinedSymbolsBytes(int index)
        {
            return userDefinedSymbols_.getByteString(index);
        }

        public static final int REQUIRED_CHARS_FIELD_NUMBER = 36;

        private volatile Object requiredChars_ = "";

        /**
         * <pre>
         * Defines required characters. Each UTF8 character in this string is included
         * in the character set regardless of character_coverage value. Unlike
         * user_defined_symbols, these characters have scores based on the frequency
         * on input sentences, and the model can form subwords using characters
         * in this field.
         * </pre>
         *
         * <code>optional string required_chars = 36;</code>
         *
         * @return Whether the requiredChars field is set.
         */
        @Override
        public boolean hasRequiredChars()
        {
            return ((bitField0_ & 0x04000000) != 0);
        }

        /**
         * <pre>
         * Defines required characters. Each UTF8 character in this string is included
         * in the character set regardless of character_coverage value. Unlike
         * user_defined_symbols, these characters have scores based on the frequency
         * on input sentences, and the model can form subwords using characters
         * in this field.
         * </pre>
         *
         * <code>optional string required_chars = 36;</code>
         *
         * @return The requiredChars.
         */
        @Override
        public String getRequiredChars()
        {
            Object ref = requiredChars_;
            if (ref instanceof String)
            {
                return (String) ref;
            }
            else
            {
                ByteString bs =
                        (ByteString) ref;
                String s = bs.toStringUtf8();
                if (bs.isValidUtf8())
                {
                    requiredChars_ = s;
                }
                return s;
            }
        }

        /**
         * <pre>
         * Defines required characters. Each UTF8 character in this string is included
         * in the character set regardless of character_coverage value. Unlike
         * user_defined_symbols, these characters have scores based on the frequency
         * on input sentences, and the model can form subwords using characters
         * in this field.
         * </pre>
         *
         * <code>optional string required_chars = 36;</code>
         *
         * @return The bytes for requiredChars.
         */
        @Override
        public ByteString
        getRequiredCharsBytes()
        {
            Object ref = requiredChars_;
            if (ref instanceof String)
            {
                ByteString b =
                        ByteString.copyFromUtf8(
                                (String) ref);
                requiredChars_ = b;
                return b;
            }
            else
            {
                return (ByteString) ref;
            }
        }

        public static final int BYTE_FALLBACK_FIELD_NUMBER = 35;
        private boolean byteFallback_ = false;

        /**
         * <pre>
         * Decomposes unknown pieces into UTF-8 bytes.
         * </pre>
         *
         * <code>optional bool byte_fallback = 35 [default = false];</code>
         *
         * @return Whether the byteFallback field is set.
         */
        @Override
        public boolean hasByteFallback()
        {
            return ((bitField0_ & 0x08000000) != 0);
        }

        /**
         * <pre>
         * Decomposes unknown pieces into UTF-8 bytes.
         * </pre>
         *
         * <code>optional bool byte_fallback = 35 [default = false];</code>
         *
         * @return The byteFallback.
         */
        @Override
        public boolean getByteFallback()
        {
            return byteFallback_;
        }

        public static final int VOCABULARY_OUTPUT_PIECE_SCORE_FIELD_NUMBER = 32;
        private boolean vocabularyOutputPieceScore_ = true;

        /**
         * <pre>
         * When creating the vocabulary file, defines whether or not to additionally
         * output the score for each piece.
         * </pre>
         *
         * <code>optional bool vocabulary_output_piece_score = 32 [default = true];</code>
         *
         * @return Whether the vocabularyOutputPieceScore field is set.
         */
        @Override
        public boolean hasVocabularyOutputPieceScore()
        {
            return ((bitField0_ & 0x10000000) != 0);
        }

        /**
         * <pre>
         * When creating the vocabulary file, defines whether or not to additionally
         * output the score for each piece.
         * </pre>
         *
         * <code>optional bool vocabulary_output_piece_score = 32 [default = true];</code>
         *
         * @return The vocabularyOutputPieceScore.
         */
        @Override
        public boolean getVocabularyOutputPieceScore()
        {
            return vocabularyOutputPieceScore_;
        }

        public static final int HARD_VOCAB_LIMIT_FIELD_NUMBER = 33;
        private boolean hardVocabLimit_ = true;

        /**
         * <pre>
         * `vocab_size` is treated as hard limit. Crash if
         * the model can not produce the vocab of size `vocab_size`,
         * When `hard_vocab_limit` is false, vocab_size is treated
         * as soft limit. Note that when model_type=char,
         * always assumes hard_vocab_limit = false.
         * </pre>
         *
         * <code>optional bool hard_vocab_limit = 33 [default = true];</code>
         *
         * @return Whether the hardVocabLimit field is set.
         */
        @Override
        public boolean hasHardVocabLimit()
        {
            return ((bitField0_ & 0x20000000) != 0);
        }

        /**
         * <pre>
         * `vocab_size` is treated as hard limit. Crash if
         * the model can not produce the vocab of size `vocab_size`,
         * When `hard_vocab_limit` is false, vocab_size is treated
         * as soft limit. Note that when model_type=char,
         * always assumes hard_vocab_limit = false.
         * </pre>
         *
         * <code>optional bool hard_vocab_limit = 33 [default = true];</code>
         *
         * @return The hardVocabLimit.
         */
        @Override
        public boolean getHardVocabLimit()
        {
            return hardVocabLimit_;
        }

        public static final int USE_ALL_VOCAB_FIELD_NUMBER = 34;
        private boolean useAllVocab_ = false;

        /**
         * <pre>
         * use all symbols for vocab extraction. This flag is valid
         * if model type is either CHAR or WORD
         * </pre>
         *
         * <code>optional bool use_all_vocab = 34 [default = false];</code>
         *
         * @return Whether the useAllVocab field is set.
         */
        @Override
        public boolean hasUseAllVocab()
        {
            return ((bitField0_ & 0x40000000) != 0);
        }

        /**
         * <pre>
         * use all symbols for vocab extraction. This flag is valid
         * if model type is either CHAR or WORD
         * </pre>
         *
         * <code>optional bool use_all_vocab = 34 [default = false];</code>
         *
         * @return The useAllVocab.
         */
        @Override
        public boolean getUseAllVocab()
        {
            return useAllVocab_;
        }

        public static final int UNK_ID_FIELD_NUMBER = 40;
        private int unkId_ = 0;

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * Reserved special meta tokens.
         * * -1 is not used.
         * * unk_id must not be -1.
         * Id must starts with 0 and be contigous.
         * </pre>
         *
         * <code>optional int32 unk_id = 40 [default = 0];</code>
         *
         * @return Whether the unkId field is set.
         */
        @Override
        public boolean hasUnkId()
        {
            return ((bitField0_ & 0x80000000) != 0);
        }

        /**
         * <pre>
         * &#47;////////////////////////////////////////////////////////////////
         * Reserved special meta tokens.
         * * -1 is not used.
         * * unk_id must not be -1.
         * Id must starts with 0 and be contigous.
         * </pre>
         *
         * <code>optional int32 unk_id = 40 [default = 0];</code>
         *
         * @return The unkId.
         */
        @Override
        public int getUnkId()
        {
            return unkId_;
        }

        public static final int BOS_ID_FIELD_NUMBER = 41;
        private int bosId_ = 1;

        /**
         * <pre>
         * &lt;s&gt;
         * </pre>
         *
         * <code>optional int32 bos_id = 41 [default = 1];</code>
         *
         * @return Whether the bosId field is set.
         */
        @Override
        public boolean hasBosId()
        {
            return ((bitField1_ & 0x00000001) != 0);
        }

        /**
         * <pre>
         * &lt;s&gt;
         * </pre>
         *
         * <code>optional int32 bos_id = 41 [default = 1];</code>
         *
         * @return The bosId.
         */
        @Override
        public int getBosId()
        {
            return bosId_;
        }

        public static final int EOS_ID_FIELD_NUMBER = 42;
        private int eosId_ = 2;

        /**
         * <pre>
         * &lt;/s&gt;
         * </pre>
         *
         * <code>optional int32 eos_id = 42 [default = 2];</code>
         *
         * @return Whether the eosId field is set.
         */
        @Override
        public boolean hasEosId()
        {
            return ((bitField1_ & 0x00000002) != 0);
        }

        /**
         * <pre>
         * &lt;/s&gt;
         * </pre>
         *
         * <code>optional int32 eos_id = 42 [default = 2];</code>
         *
         * @return The eosId.
         */
        @Override
        public int getEosId()
        {
            return eosId_;
        }

        public static final int PAD_ID_FIELD_NUMBER = 43;
        private int padId_ = -1;

        /**
         * <pre>
         * &lt;pad&gt; (padding)
         * </pre>
         *
         * <code>optional int32 pad_id = 43 [default = -1];</code>
         *
         * @return Whether the padId field is set.
         */
        @Override
        public boolean hasPadId()
        {
            return ((bitField1_ & 0x00000004) != 0);
        }

        /**
         * <pre>
         * &lt;pad&gt; (padding)
         * </pre>
         *
         * <code>optional int32 pad_id = 43 [default = -1];</code>
         *
         * @return The padId.
         */
        @Override
        public int getPadId()
        {
            return padId_;
        }

        public static final int UNK_PIECE_FIELD_NUMBER = 45;

        private volatile Object unkPiece_ = "<unk>";

        /**
         * <code>optional string unk_piece = 45 [default = "&lt;unk&gt;"];</code>
         *
         * @return Whether the unkPiece field is set.
         */
        @Override
        public boolean hasUnkPiece()
        {
            return ((bitField1_ & 0x00000008) != 0);
        }

        /**
         * <code>optional string unk_piece = 45 [default = "&lt;unk&gt;"];</code>
         *
         * @return The unkPiece.
         */
        @Override
        public String getUnkPiece()
        {
            Object ref = unkPiece_;
            if (ref instanceof String)
            {
                return (String) ref;
            }
            else
            {
                ByteString bs =
                        (ByteString) ref;
                String s = bs.toStringUtf8();
                if (bs.isValidUtf8())
                {
                    unkPiece_ = s;
                }
                return s;
            }
        }

        /**
         * <code>optional string unk_piece = 45 [default = "&lt;unk&gt;"];</code>
         *
         * @return The bytes for unkPiece.
         */
        @Override
        public ByteString
        getUnkPieceBytes()
        {
            Object ref = unkPiece_;
            if (ref instanceof String)
            {
                ByteString b =
                        ByteString.copyFromUtf8(
                                (String) ref);
                unkPiece_ = b;
                return b;
            }
            else
            {
                return (ByteString) ref;
            }
        }

        public static final int BOS_PIECE_FIELD_NUMBER = 46;

        private volatile Object bosPiece_ = "<s>";

        /**
         * <code>optional string bos_piece = 46 [default = "&lt;s&gt;"];</code>
         *
         * @return Whether the bosPiece field is set.
         */
        @Override
        public boolean hasBosPiece()
        {
            return ((bitField1_ & 0x00000010) != 0);
        }

        /**
         * <code>optional string bos_piece = 46 [default = "&lt;s&gt;"];</code>
         *
         * @return The bosPiece.
         */
        @Override
        public String getBosPiece()
        {
            Object ref = bosPiece_;
            if (ref instanceof String)
            {
                return (String) ref;
            }
            else
            {
                ByteString bs =
                        (ByteString) ref;
                String s = bs.toStringUtf8();
                if (bs.isValidUtf8())
                {
                    bosPiece_ = s;
                }
                return s;
            }
        }

        /**
         * <code>optional string bos_piece = 46 [default = "&lt;s&gt;"];</code>
         *
         * @return The bytes for bosPiece.
         */
        @Override
        public ByteString
        getBosPieceBytes()
        {
            Object ref = bosPiece_;
            if (ref instanceof String)
            {
                ByteString b =
                        ByteString.copyFromUtf8(
                                (String) ref);
                bosPiece_ = b;
                return b;
            }
            else
            {
                return (ByteString) ref;
            }
        }

        public static final int EOS_PIECE_FIELD_NUMBER = 47;

        private volatile Object eosPiece_ = "</s>";

        /**
         * <code>optional string eos_piece = 47 [default = "&lt;/s&gt;"];</code>
         *
         * @return Whether the eosPiece field is set.
         */
        @Override
        public boolean hasEosPiece()
        {
            return ((bitField1_ & 0x00000020) != 0);
        }

        /**
         * <code>optional string eos_piece = 47 [default = "&lt;/s&gt;"];</code>
         *
         * @return The eosPiece.
         */
        @Override
        public String getEosPiece()
        {
            Object ref = eosPiece_;
            if (ref instanceof String)
            {
                return (String) ref;
            }
            else
            {
                ByteString bs =
                        (ByteString) ref;
                String s = bs.toStringUtf8();
                if (bs.isValidUtf8())
                {
                    eosPiece_ = s;
                }
                return s;
            }
        }

        /**
         * <code>optional string eos_piece = 47 [default = "&lt;/s&gt;"];</code>
         *
         * @return The bytes for eosPiece.
         */
        @Override
        public ByteString
        getEosPieceBytes()
        {
            Object ref = eosPiece_;
            if (ref instanceof String)
            {
                ByteString b =
                        ByteString.copyFromUtf8(
                                (String) ref);
                eosPiece_ = b;
                return b;
            }
            else
            {
                return (ByteString) ref;
            }
        }

        public static final int PAD_PIECE_FIELD_NUMBER = 48;

        private volatile Object padPiece_ = "<pad>";

        /**
         * <code>optional string pad_piece = 48 [default = "&lt;pad&gt;"];</code>
         *
         * @return Whether the padPiece field is set.
         */
        @Override
        public boolean hasPadPiece()
        {
            return ((bitField1_ & 0x00000040) != 0);
        }

        /**
         * <code>optional string pad_piece = 48 [default = "&lt;pad&gt;"];</code>
         *
         * @return The padPiece.
         */
        @Override
        public String getPadPiece()
        {
            Object ref = padPiece_;
            if (ref instanceof String)
            {
                return (String) ref;
            }
            else
            {
                ByteString bs =
                        (ByteString) ref;
                String s = bs.toStringUtf8();
                if (bs.isValidUtf8())
                {
                    padPiece_ = s;
                }
                return s;
            }
        }

        /**
         * <code>optional string pad_piece = 48 [default = "&lt;pad&gt;"];</code>
         *
         * @return The bytes for padPiece.
         */
        @Override
        public ByteString
        getPadPieceBytes()
        {
            Object ref = padPiece_;
            if (ref instanceof String)
            {
                ByteString b =
                        ByteString.copyFromUtf8(
                                (String) ref);
                padPiece_ = b;
                return b;
            }
            else
            {
                return (ByteString) ref;
            }
        }

        public static final int UNK_SURFACE_FIELD_NUMBER = 44;

        private volatile Object unkSurface_ = Internal.stringDefaultValue(" \342\201\207 ");

        /**
         * <pre>
         * Encodes &lt;unk&gt; into U+2047 (DOUBLE QUESTION MARK),
         * since this character can be useful both for user and
         * developer. We can easily figure out that &lt;unk&gt; is emitted.
         * </pre>
         *
         * <code>optional string unk_surface = 44 [default = " &#92;342&#92;201&#92;207 "];</code>
         *
         * @return Whether the unkSurface field is set.
         */
        @Override
        public boolean hasUnkSurface()
        {
            return ((bitField1_ & 0x00000080) != 0);
        }

        /**
         * <pre>
         * Encodes &lt;unk&gt; into U+2047 (DOUBLE QUESTION MARK),
         * since this character can be useful both for user and
         * developer. We can easily figure out that &lt;unk&gt; is emitted.
         * </pre>
         *
         * <code>optional string unk_surface = 44 [default = " &#92;342&#92;201&#92;207 "];</code>
         *
         * @return The unkSurface.
         */
        @Override
        public String getUnkSurface()
        {
            Object ref = unkSurface_;
            if (ref instanceof String)
            {
                return (String) ref;
            }
            else
            {
                ByteString bs =
                        (ByteString) ref;
                String s = bs.toStringUtf8();
                if (bs.isValidUtf8())
                {
                    unkSurface_ = s;
                }
                return s;
            }
        }

        /**
         * <pre>
         * Encodes &lt;unk&gt; into U+2047 (DOUBLE QUESTION MARK),
         * since this character can be useful both for user and
         * developer. We can easily figure out that &lt;unk&gt; is emitted.
         * </pre>
         *
         * <code>optional string unk_surface = 44 [default = " &#92;342&#92;201&#92;207 "];</code>
         *
         * @return The bytes for unkSurface.
         */
        @Override
        public ByteString
        getUnkSurfaceBytes()
        {
            Object ref = unkSurface_;
            if (ref instanceof String)
            {
                ByteString b =
                        ByteString.copyFromUtf8(
                                (String) ref);
                unkSurface_ = b;
                return b;
            }
            else
            {
                return (ByteString) ref;
            }
        }

        public static final int TRAIN_EXTREMELY_LARGE_CORPUS_FIELD_NUMBER = 49;
        private boolean trainExtremelyLargeCorpus_ = false;

        /**
         * <pre>
         * Increase bit depth to allow unigram model training on large
         * (&gt;10M sentences) corpora. A Side-effect of enabling this flag
         * is increased memory usage.
         * </pre>
         *
         * <code>optional bool train_extremely_large_corpus = 49 [default = false];</code>
         *
         * @return Whether the trainExtremelyLargeCorpus field is set.
         */
        @Override
        public boolean hasTrainExtremelyLargeCorpus()
        {
            return ((bitField1_ & 0x00000100) != 0);
        }

        /**
         * <pre>
         * Increase bit depth to allow unigram model training on large
         * (&gt;10M sentences) corpora. A Side-effect of enabling this flag
         * is increased memory usage.
         * </pre>
         *
         * <code>optional bool train_extremely_large_corpus = 49 [default = false];</code>
         *
         * @return The trainExtremelyLargeCorpus.
         */
        @Override
        public boolean getTrainExtremelyLargeCorpus()
        {
            return trainExtremelyLargeCorpus_;
        }

        public static final int SEED_SENTENCEPIECES_FILE_FIELD_NUMBER = 54;

        private volatile Object seedSentencepiecesFile_ = "";

        /**
         * <pre>
         * Path to a seed sentencepieces file, with one tab-separated
         * seed sentencepiece &lt;tab&gt; frequency per line.
         * </pre>
         *
         * <code>optional string seed_sentencepieces_file = 54 [default = ""];</code>
         *
         * @return Whether the seedSentencepiecesFile field is set.
         */
        @Override
        public boolean hasSeedSentencepiecesFile()
        {
            return ((bitField1_ & 0x00000200) != 0);
        }

        /**
         * <pre>
         * Path to a seed sentencepieces file, with one tab-separated
         * seed sentencepiece &lt;tab&gt; frequency per line.
         * </pre>
         *
         * <code>optional string seed_sentencepieces_file = 54 [default = ""];</code>
         *
         * @return The seedSentencepiecesFile.
         */
        @Override
        public String getSeedSentencepiecesFile()
        {
            Object ref = seedSentencepiecesFile_;
            if (ref instanceof String)
            {
                return (String) ref;
            }
            else
            {
                ByteString bs =
                        (ByteString) ref;
                String s = bs.toStringUtf8();
                if (bs.isValidUtf8())
                {
                    seedSentencepiecesFile_ = s;
                }
                return s;
            }
        }

        /**
         * <pre>
         * Path to a seed sentencepieces file, with one tab-separated
         * seed sentencepiece &lt;tab&gt; frequency per line.
         * </pre>
         *
         * <code>optional string seed_sentencepieces_file = 54 [default = ""];</code>
         *
         * @return The bytes for seedSentencepiecesFile.
         */
        @Override
        public ByteString
        getSeedSentencepiecesFileBytes()
        {
            Object ref = seedSentencepiecesFile_;
            if (ref instanceof String)
            {
                ByteString b =
                        ByteString.copyFromUtf8(
                                (String) ref);
                seedSentencepiecesFile_ = b;
                return b;
            }
            else
            {
                return (ByteString) ref;
            }
        }

        private byte memoizedIsInitialized = -1;

        @Override
        public boolean isInitialized()
        {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;

            if (!extensionsAreInitialized())
            {
                memoizedIsInitialized = 0;
                return false;
            }
            memoizedIsInitialized = 1;
            return true;
        }

        @Override
        public void writeTo(CodedOutputStream output)
                throws IOException
        {
            ExtendableMessage<TrainerSpec>.ExtensionWriter
                    extensionWriter = newExtensionWriter();
            for (int i = 0; i < input_.size(); i++)
            {
                GeneratedMessage.writeString(output, 1, input_.getRaw(i));
            }
            if (((bitField0_ & 0x00000002) != 0))
            {
                GeneratedMessage.writeString(output, 2, modelPrefix_);
            }
            if (((bitField0_ & 0x00000004) != 0))
            {
                output.writeEnum(3, modelType_);
            }
            if (((bitField0_ & 0x00000008) != 0))
            {
                output.writeInt32(4, vocabSize_);
            }
            for (int i = 0; i < acceptLanguage_.size(); i++)
            {
                GeneratedMessage.writeString(output, 5, acceptLanguage_.getRaw(i));
            }
            if (((bitField0_ & 0x00000010) != 0))
            {
                output.writeInt32(6, selfTestSampleSize_);
            }
            if (((bitField0_ & 0x00000001) != 0))
            {
                GeneratedMessage.writeString(output, 7, inputFormat_);
            }
            if (((bitField0_ & 0x00000100) != 0))
            {
                output.writeFloat(10, characterCoverage_);
            }
            if (((bitField0_ & 0x00000200) != 0))
            {
                output.writeUInt64(11, inputSentenceSize_);
            }
            if (((bitField0_ & 0x00000800) != 0))
            {
                output.writeInt32(12, miningSentenceSize_);
            }
            if (((bitField0_ & 0x00001000) != 0))
            {
                output.writeInt32(13, trainingSentenceSize_);
            }
            if (((bitField0_ & 0x00002000) != 0))
            {
                output.writeInt32(14, seedSentencepieceSize_);
            }
            if (((bitField0_ & 0x00004000) != 0))
            {
                output.writeFloat(15, shrinkingFactor_);
            }
            if (((bitField0_ & 0x00010000) != 0))
            {
                output.writeInt32(16, numThreads_);
            }
            if (((bitField0_ & 0x00020000) != 0))
            {
                output.writeInt32(17, numSubIterations_);
            }
            if (((bitField0_ & 0x00008000) != 0))
            {
                output.writeInt32(18, maxSentenceLength_);
            }
            if (((bitField0_ & 0x00000400) != 0))
            {
                output.writeBool(19, shuffleInputSentence_);
            }
            if (((bitField0_ & 0x00040000) != 0))
            {
                output.writeInt32(20, maxSentencepieceLength_);
            }
            if (((bitField0_ & 0x00080000) != 0))
            {
                output.writeBool(21, splitByUnicodeScript_);
            }
            if (((bitField0_ & 0x00200000) != 0))
            {
                output.writeBool(22, splitByWhitespace_);
            }
            if (((bitField0_ & 0x00100000) != 0))
            {
                output.writeBool(23, splitByNumber_);
            }
            if (((bitField0_ & 0x00400000) != 0))
            {
                output.writeBool(24, treatWhitespaceAsSuffix_);
            }
            if (((bitField0_ & 0x01000000) != 0))
            {
                output.writeBool(25, splitDigits_);
            }
            if (((bitField0_ & 0x00800000) != 0))
            {
                output.writeBool(26, allowWhitespaceOnlyPieces_);
            }
            for (int i = 0; i < controlSymbols_.size(); i++)
            {
                GeneratedMessage.writeString(output, 30, controlSymbols_.getRaw(i));
            }
            for (int i = 0; i < userDefinedSymbols_.size(); i++)
            {
                GeneratedMessage.writeString(output, 31, userDefinedSymbols_.getRaw(i));
            }
            if (((bitField0_ & 0x10000000) != 0))
            {
                output.writeBool(32, vocabularyOutputPieceScore_);
            }
            if (((bitField0_ & 0x20000000) != 0))
            {
                output.writeBool(33, hardVocabLimit_);
            }
            if (((bitField0_ & 0x40000000) != 0))
            {
                output.writeBool(34, useAllVocab_);
            }
            if (((bitField0_ & 0x08000000) != 0))
            {
                output.writeBool(35, byteFallback_);
            }
            if (((bitField0_ & 0x04000000) != 0))
            {
                GeneratedMessage.writeString(output, 36, requiredChars_);
            }
            if (((bitField0_ & 0x80000000) != 0))
            {
                output.writeInt32(40, unkId_);
            }
            if (((bitField1_ & 0x00000001) != 0))
            {
                output.writeInt32(41, bosId_);
            }
            if (((bitField1_ & 0x00000002) != 0))
            {
                output.writeInt32(42, eosId_);
            }
            if (((bitField1_ & 0x00000004) != 0))
            {
                output.writeInt32(43, padId_);
            }
            if (((bitField1_ & 0x00000080) != 0))
            {
                GeneratedMessage.writeString(output, 44, unkSurface_);
            }
            if (((bitField1_ & 0x00000008) != 0))
            {
                GeneratedMessage.writeString(output, 45, unkPiece_);
            }
            if (((bitField1_ & 0x00000010) != 0))
            {
                GeneratedMessage.writeString(output, 46, bosPiece_);
            }
            if (((bitField1_ & 0x00000020) != 0))
            {
                GeneratedMessage.writeString(output, 47, eosPiece_);
            }
            if (((bitField1_ & 0x00000040) != 0))
            {
                GeneratedMessage.writeString(output, 48, padPiece_);
            }
            if (((bitField1_ & 0x00000100) != 0))
            {
                output.writeBool(49, trainExtremelyLargeCorpus_);
            }
            if (((bitField0_ & 0x00000020) != 0))
            {
                output.writeBool(50, enableDifferentialPrivacy_);
            }
            if (((bitField0_ & 0x00000040) != 0))
            {
                output.writeFloat(51, differentialPrivacyNoiseLevel_);
            }
            if (((bitField0_ & 0x00000080) != 0))
            {
                output.writeUInt64(52, differentialPrivacyClippingThreshold_);
            }
            if (((bitField0_ & 0x02000000) != 0))
            {
                GeneratedMessage.writeString(output, 53, pretokenizationDelimiter_);
            }
            if (((bitField1_ & 0x00000200) != 0))
            {
                GeneratedMessage.writeString(output, 54, seedSentencepiecesFile_);
            }
            extensionWriter.writeUntil(536870912, output);
            getUnknownFields().writeTo(output);
        }

        @Override
        public int getSerializedSize()
        {
            int size = memoizedSize;
            if (size != -1) return size;

            size = 0;
            {
                int dataSize = 0;
                for (int i = 0; i < input_.size(); i++)
                {
                    dataSize += computeStringSizeNoTag(input_.getRaw(i));
                }
                size += dataSize;
                size += getInputList().size();
            }
            if (((bitField0_ & 0x00000002) != 0))
            {
                size += GeneratedMessage.computeStringSize(2, modelPrefix_);
            }
            if (((bitField0_ & 0x00000004) != 0))
            {
                size += CodedOutputStream
                        .computeEnumSize(3, modelType_);
            }
            if (((bitField0_ & 0x00000008) != 0))
            {
                size += CodedOutputStream
                        .computeInt32Size(4, vocabSize_);
            }
            {
                int dataSize = 0;
                for (int i = 0; i < acceptLanguage_.size(); i++)
                {
                    dataSize += computeStringSizeNoTag(acceptLanguage_.getRaw(i));
                }
                size += dataSize;
                size += getAcceptLanguageList().size();
            }
            if (((bitField0_ & 0x00000010) != 0))
            {
                size += CodedOutputStream
                        .computeInt32Size(6, selfTestSampleSize_);
            }
            if (((bitField0_ & 0x00000001) != 0))
            {
                size += GeneratedMessage.computeStringSize(7, inputFormat_);
            }
            if (((bitField0_ & 0x00000100) != 0))
            {
                size += CodedOutputStream
                        .computeFloatSize(10, characterCoverage_);
            }
            if (((bitField0_ & 0x00000200) != 0))
            {
                size += CodedOutputStream
                        .computeUInt64Size(11, inputSentenceSize_);
            }
            if (((bitField0_ & 0x00000800) != 0))
            {
                size += CodedOutputStream
                        .computeInt32Size(12, miningSentenceSize_);
            }
            if (((bitField0_ & 0x00001000) != 0))
            {
                size += CodedOutputStream
                        .computeInt32Size(13, trainingSentenceSize_);
            }
            if (((bitField0_ & 0x00002000) != 0))
            {
                size += CodedOutputStream
                        .computeInt32Size(14, seedSentencepieceSize_);
            }
            if (((bitField0_ & 0x00004000) != 0))
            {
                size += CodedOutputStream
                        .computeFloatSize(15, shrinkingFactor_);
            }
            if (((bitField0_ & 0x00010000) != 0))
            {
                size += CodedOutputStream
                        .computeInt32Size(16, numThreads_);
            }
            if (((bitField0_ & 0x00020000) != 0))
            {
                size += CodedOutputStream
                        .computeInt32Size(17, numSubIterations_);
            }
            if (((bitField0_ & 0x00008000) != 0))
            {
                size += CodedOutputStream
                        .computeInt32Size(18, maxSentenceLength_);
            }
            if (((bitField0_ & 0x00000400) != 0))
            {
                size += CodedOutputStream
                        .computeBoolSize(19, shuffleInputSentence_);
            }
            if (((bitField0_ & 0x00040000) != 0))
            {
                size += CodedOutputStream
                        .computeInt32Size(20, maxSentencepieceLength_);
            }
            if (((bitField0_ & 0x00080000) != 0))
            {
                size += CodedOutputStream
                        .computeBoolSize(21, splitByUnicodeScript_);
            }
            if (((bitField0_ & 0x00200000) != 0))
            {
                size += CodedOutputStream
                        .computeBoolSize(22, splitByWhitespace_);
            }
            if (((bitField0_ & 0x00100000) != 0))
            {
                size += CodedOutputStream
                        .computeBoolSize(23, splitByNumber_);
            }
            if (((bitField0_ & 0x00400000) != 0))
            {
                size += CodedOutputStream
                        .computeBoolSize(24, treatWhitespaceAsSuffix_);
            }
            if (((bitField0_ & 0x01000000) != 0))
            {
                size += CodedOutputStream
                        .computeBoolSize(25, splitDigits_);
            }
            if (((bitField0_ & 0x00800000) != 0))
            {
                size += CodedOutputStream
                        .computeBoolSize(26, allowWhitespaceOnlyPieces_);
            }
            {
                int dataSize = 0;
                for (int i = 0; i < controlSymbols_.size(); i++)
                {
                    dataSize += computeStringSizeNoTag(controlSymbols_.getRaw(i));
                }
                size += dataSize;
                size += 2 * getControlSymbolsList().size();
            }
            {
                int dataSize = 0;
                for (int i = 0; i < userDefinedSymbols_.size(); i++)
                {
                    dataSize += computeStringSizeNoTag(userDefinedSymbols_.getRaw(i));
                }
                size += dataSize;
                size += 2 * getUserDefinedSymbolsList().size();
            }
            if (((bitField0_ & 0x10000000) != 0))
            {
                size += CodedOutputStream
                        .computeBoolSize(32, vocabularyOutputPieceScore_);
            }
            if (((bitField0_ & 0x20000000) != 0))
            {
                size += CodedOutputStream
                        .computeBoolSize(33, hardVocabLimit_);
            }
            if (((bitField0_ & 0x40000000) != 0))
            {
                size += CodedOutputStream
                        .computeBoolSize(34, useAllVocab_);
            }
            if (((bitField0_ & 0x08000000) != 0))
            {
                size += CodedOutputStream
                        .computeBoolSize(35, byteFallback_);
            }
            if (((bitField0_ & 0x04000000) != 0))
            {
                size += GeneratedMessage.computeStringSize(36, requiredChars_);
            }
            if (((bitField0_ & 0x80000000) != 0))
            {
                size += CodedOutputStream
                        .computeInt32Size(40, unkId_);
            }
            if (((bitField1_ & 0x00000001) != 0))
            {
                size += CodedOutputStream
                        .computeInt32Size(41, bosId_);
            }
            if (((bitField1_ & 0x00000002) != 0))
            {
                size += CodedOutputStream
                        .computeInt32Size(42, eosId_);
            }
            if (((bitField1_ & 0x00000004) != 0))
            {
                size += CodedOutputStream
                        .computeInt32Size(43, padId_);
            }
            if (((bitField1_ & 0x00000080) != 0))
            {
                size += GeneratedMessage.computeStringSize(44, unkSurface_);
            }
            if (((bitField1_ & 0x00000008) != 0))
            {
                size += GeneratedMessage.computeStringSize(45, unkPiece_);
            }
            if (((bitField1_ & 0x00000010) != 0))
            {
                size += GeneratedMessage.computeStringSize(46, bosPiece_);
            }
            if (((bitField1_ & 0x00000020) != 0))
            {
                size += GeneratedMessage.computeStringSize(47, eosPiece_);
            }
            if (((bitField1_ & 0x00000040) != 0))
            {
                size += GeneratedMessage.computeStringSize(48, padPiece_);
            }
            if (((bitField1_ & 0x00000100) != 0))
            {
                size += CodedOutputStream
                        .computeBoolSize(49, trainExtremelyLargeCorpus_);
            }
            if (((bitField0_ & 0x00000020) != 0))
            {
                size += CodedOutputStream
                        .computeBoolSize(50, enableDifferentialPrivacy_);
            }
            if (((bitField0_ & 0x00000040) != 0))
            {
                size += CodedOutputStream
                        .computeFloatSize(51, differentialPrivacyNoiseLevel_);
            }
            if (((bitField0_ & 0x00000080) != 0))
            {
                size += CodedOutputStream
                        .computeUInt64Size(52, differentialPrivacyClippingThreshold_);
            }
            if (((bitField0_ & 0x02000000) != 0))
            {
                size += GeneratedMessage.computeStringSize(53, pretokenizationDelimiter_);
            }
            if (((bitField1_ & 0x00000200) != 0))
            {
                size += GeneratedMessage.computeStringSize(54, seedSentencepiecesFile_);
            }
            size += extensionsSerializedSize();
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }

        @Override
        public boolean equals(final Object obj)
        {
            if (obj == this)
            {
                return true;
            }
            if (!(obj instanceof TrainerSpec other))
            {
                return super.equals(obj);
            }

            if (!getInputList().equals(other.getInputList())) return false;
            if (hasInputFormat() != other.hasInputFormat()) return false;
            if (hasInputFormat())
            {
                if (!getInputFormat().equals(other.getInputFormat())) return false;
            }
            if (hasModelPrefix() != other.hasModelPrefix()) return false;
            if (hasModelPrefix())
            {
                if (!getModelPrefix().equals(other.getModelPrefix())) return false;
            }
            if (hasModelType() != other.hasModelType()) return false;
            if (hasModelType())
            {
                if (modelType_ != other.modelType_) return false;
            }
            if (hasVocabSize() != other.hasVocabSize()) return false;
            if (hasVocabSize())
            {
                if (getVocabSize() != other.getVocabSize()) return false;
            }
            if (!getAcceptLanguageList().equals(other.getAcceptLanguageList())) return false;
            if (hasSelfTestSampleSize() != other.hasSelfTestSampleSize()) return false;
            if (hasSelfTestSampleSize())
            {
                if (getSelfTestSampleSize() != other.getSelfTestSampleSize()) return false;
            }
            if (hasEnableDifferentialPrivacy() != other.hasEnableDifferentialPrivacy()) return false;
            if (hasEnableDifferentialPrivacy())
            {
                if (getEnableDifferentialPrivacy() != other.getEnableDifferentialPrivacy()) return false;
            }
            if (hasDifferentialPrivacyNoiseLevel() != other.hasDifferentialPrivacyNoiseLevel()) return false;
            if (hasDifferentialPrivacyNoiseLevel())
            {
                if (Float.floatToIntBits(getDifferentialPrivacyNoiseLevel()) != Float.floatToIntBits(
                        other.getDifferentialPrivacyNoiseLevel())) return false;
            }
            if (hasDifferentialPrivacyClippingThreshold() != other.hasDifferentialPrivacyClippingThreshold())
                return false;
            if (hasDifferentialPrivacyClippingThreshold())
            {
                if (getDifferentialPrivacyClippingThreshold() != other.getDifferentialPrivacyClippingThreshold()) return false;
            }
            if (hasCharacterCoverage() != other.hasCharacterCoverage()) return false;
            if (hasCharacterCoverage())
            {
                if (Float.floatToIntBits(getCharacterCoverage())
                        != Float.floatToIntBits(other.getCharacterCoverage())) return false;
            }
            if (hasInputSentenceSize() != other.hasInputSentenceSize()) return false;
            if (hasInputSentenceSize())
            {
                if (getInputSentenceSize() != other.getInputSentenceSize()) return false;
            }
            if (hasShuffleInputSentence() != other.hasShuffleInputSentence()) return false;
            if (hasShuffleInputSentence())
            {
                if (getShuffleInputSentence() != other.getShuffleInputSentence()) return false;
            }
            if (hasMiningSentenceSize() != other.hasMiningSentenceSize()) return false;
            if (hasMiningSentenceSize())
            {
                if (getMiningSentenceSize() != other.getMiningSentenceSize()) return false;
            }
            if (hasTrainingSentenceSize() != other.hasTrainingSentenceSize()) return false;
            if (hasTrainingSentenceSize())
            {
                if (getTrainingSentenceSize() != other.getTrainingSentenceSize()) return false;
            }
            if (hasSeedSentencepieceSize() != other.hasSeedSentencepieceSize()) return false;
            if (hasSeedSentencepieceSize())
            {
                if (getSeedSentencepieceSize() != other.getSeedSentencepieceSize()) return false;
            }
            if (hasShrinkingFactor() != other.hasShrinkingFactor()) return false;
            if (hasShrinkingFactor())
            {
                if (Float.floatToIntBits(getShrinkingFactor())
                        != Float.floatToIntBits( other.getShrinkingFactor())) return false;
            }
            if (hasMaxSentenceLength() != other.hasMaxSentenceLength()) return false;
            if (hasMaxSentenceLength())
            {
                if (getMaxSentenceLength() != other.getMaxSentenceLength()) return false;
            }
            if (hasNumThreads() != other.hasNumThreads()) return false;
            if (hasNumThreads())
            {
                if (getNumThreads() != other.getNumThreads()) return false;
            }
            if (hasNumSubIterations() != other.hasNumSubIterations()) return false;
            if (hasNumSubIterations())
            {
                if (getNumSubIterations() != other.getNumSubIterations()) return false;
            }
            if (hasMaxSentencepieceLength() != other.hasMaxSentencepieceLength()) return false;
            if (hasMaxSentencepieceLength())
            {
                if (getMaxSentencepieceLength() != other.getMaxSentencepieceLength()) return false;
            }
            if (hasSplitByUnicodeScript() != other.hasSplitByUnicodeScript()) return false;
            if (hasSplitByUnicodeScript())
            {
                if (getSplitByUnicodeScript() != other.getSplitByUnicodeScript()) return false;
            }
            if (hasSplitByNumber() != other.hasSplitByNumber()) return false;
            if (hasSplitByNumber())
            {
                if (getSplitByNumber() != other.getSplitByNumber()) return false;
            }
            if (hasSplitByWhitespace() != other.hasSplitByWhitespace()) return false;
            if (hasSplitByWhitespace())
            {
                if (getSplitByWhitespace() != other.getSplitByWhitespace()) return false;
            }
            if (hasTreatWhitespaceAsSuffix() != other.hasTreatWhitespaceAsSuffix()) return false;
            if (hasTreatWhitespaceAsSuffix())
            {
                if (getTreatWhitespaceAsSuffix() != other.getTreatWhitespaceAsSuffix()) return false;
            }
            if (hasAllowWhitespaceOnlyPieces() != other.hasAllowWhitespaceOnlyPieces()) return false;
            if (hasAllowWhitespaceOnlyPieces())
            {
                if (getAllowWhitespaceOnlyPieces() != other.getAllowWhitespaceOnlyPieces()) return false;
            }
            if (hasSplitDigits() != other.hasSplitDigits()) return false;
            if (hasSplitDigits())
            {
                if (getSplitDigits() != other.getSplitDigits()) return false;
            }
            if (hasPretokenizationDelimiter() != other.hasPretokenizationDelimiter()) return false;
            if (hasPretokenizationDelimiter())
            {
                if (!getPretokenizationDelimiter().equals(other.getPretokenizationDelimiter())) return false;
            }
            if (!getControlSymbolsList().equals(other.getControlSymbolsList())) return false;
            if (!getUserDefinedSymbolsList().equals(other.getUserDefinedSymbolsList())) return false;
            if (hasRequiredChars() != other.hasRequiredChars()) return false;
            if (hasRequiredChars())
            {
                if (!getRequiredChars().equals(other.getRequiredChars())) return false;
            }
            if (hasByteFallback() != other.hasByteFallback()) return false;
            if (hasByteFallback())
            {
                if (getByteFallback() != other.getByteFallback()) return false;
            }
            if (hasVocabularyOutputPieceScore() != other.hasVocabularyOutputPieceScore()) return false;
            if (hasVocabularyOutputPieceScore())
            {
                if (getVocabularyOutputPieceScore() != other.getVocabularyOutputPieceScore()) return false;
            }
            if (hasHardVocabLimit() != other.hasHardVocabLimit()) return false;
            if (hasHardVocabLimit())
            {
                if (getHardVocabLimit() != other.getHardVocabLimit()) return false;
            }
            if (hasUseAllVocab() != other.hasUseAllVocab()) return false;
            if (hasUseAllVocab())
            {
                if (getUseAllVocab() != other.getUseAllVocab()) return false;
            }
            if (hasUnkId() != other.hasUnkId()) return false;
            if (hasUnkId())
            {
                if (getUnkId() != other.getUnkId()) return false;
            }
            if (hasBosId() != other.hasBosId()) return false;
            if (hasBosId())
            {
                if (getBosId() != other.getBosId()) return false;
            }
            if (hasEosId() != other.hasEosId()) return false;
            if (hasEosId())
            {
                if (getEosId() != other.getEosId()) return false;
            }
            if (hasPadId() != other.hasPadId()) return false;
            if (hasPadId())
            {
                if (getPadId() != other.getPadId()) return false;
            }
            if (hasUnkPiece() != other.hasUnkPiece()) return false;
            if (hasUnkPiece())
            {
                if (!getUnkPiece().equals(other.getUnkPiece())) return false;
            }
            if (hasBosPiece() != other.hasBosPiece()) return false;
            if (hasBosPiece())
            {
                if (!getBosPiece().equals(other.getBosPiece())) return false;
            }
            if (hasEosPiece() != other.hasEosPiece()) return false;
            if (hasEosPiece())
            {
                if (!getEosPiece().equals(other.getEosPiece())) return false;
            }
            if (hasPadPiece() != other.hasPadPiece()) return false;
            if (hasPadPiece())
            {
                if (!getPadPiece().equals(other.getPadPiece())) return false;
            }
            if (hasUnkSurface() != other.hasUnkSurface()) return false;
            if (hasUnkSurface())
            {
                if (!getUnkSurface().equals(other.getUnkSurface())) return false;
            }
            if (hasTrainExtremelyLargeCorpus() != other.hasTrainExtremelyLargeCorpus()) return false;
            if (hasTrainExtremelyLargeCorpus())
            {
                if (getTrainExtremelyLargeCorpus()
                        != other.getTrainExtremelyLargeCorpus()) return false;
            }
            if (hasSeedSentencepiecesFile() != other.hasSeedSentencepiecesFile()) return false;
            if (hasSeedSentencepiecesFile())
            {
                if (!getSeedSentencepiecesFile()
                        .equals(other.getSeedSentencepiecesFile())) return false;
            }
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return getExtensionFields().equals(other.getExtensionFields());
        }

        @Override
        public int hashCode()
        {
            if (memoizedHashCode != 0)
            {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (getInputCount() > 0)
            {
                hash = (37 * hash) + INPUT_FIELD_NUMBER;
                hash = (53 * hash) + getInputList().hashCode();
            }
            if (hasInputFormat())
            {
                hash = (37 * hash) + INPUT_FORMAT_FIELD_NUMBER;
                hash = (53 * hash) + getInputFormat().hashCode();
            }
            if (hasModelPrefix())
            {
                hash = (37 * hash) + MODEL_PREFIX_FIELD_NUMBER;
                hash = (53 * hash) + getModelPrefix().hashCode();
            }
            if (hasModelType())
            {
                hash = (37 * hash) + MODEL_TYPE_FIELD_NUMBER;
                hash = (53 * hash) + modelType_;
            }
            if (hasVocabSize())
            {
                hash = (37 * hash) + VOCAB_SIZE_FIELD_NUMBER;
                hash = (53 * hash) + getVocabSize();
            }
            if (getAcceptLanguageCount() > 0)
            {
                hash = (37 * hash) + ACCEPT_LANGUAGE_FIELD_NUMBER;
                hash = (53 * hash) + getAcceptLanguageList().hashCode();
            }
            if (hasSelfTestSampleSize())
            {
                hash = (37 * hash) + SELF_TEST_SAMPLE_SIZE_FIELD_NUMBER;
                hash = (53 * hash) + getSelfTestSampleSize();
            }
            if (hasEnableDifferentialPrivacy())
            {
                hash = (37 * hash) + ENABLE_DIFFERENTIAL_PRIVACY_FIELD_NUMBER;
                hash = (53 * hash) + Internal.hashBoolean(
                        getEnableDifferentialPrivacy());
            }
            if (hasDifferentialPrivacyNoiseLevel())
            {
                hash = (37 * hash) + DIFFERENTIAL_PRIVACY_NOISE_LEVEL_FIELD_NUMBER;
                hash = (53 * hash) + Float.floatToIntBits(
                        getDifferentialPrivacyNoiseLevel());
            }
            if (hasDifferentialPrivacyClippingThreshold())
            {
                hash = (37 * hash) + DIFFERENTIAL_PRIVACY_CLIPPING_THRESHOLD_FIELD_NUMBER;
                hash = (53 * hash) + Internal.hashLong(
                        getDifferentialPrivacyClippingThreshold());
            }
            if (hasCharacterCoverage())
            {
                hash = (37 * hash) + CHARACTER_COVERAGE_FIELD_NUMBER;
                hash = (53 * hash) + Float.floatToIntBits(
                        getCharacterCoverage());
            }
            if (hasInputSentenceSize())
            {
                hash = (37 * hash) + INPUT_SENTENCE_SIZE_FIELD_NUMBER;
                hash = (53 * hash) + Internal.hashLong(
                        getInputSentenceSize());
            }
            if (hasShuffleInputSentence())
            {
                hash = (37 * hash) + SHUFFLE_INPUT_SENTENCE_FIELD_NUMBER;
                hash = (53 * hash) + Internal.hashBoolean(
                        getShuffleInputSentence());
            }
            if (hasMiningSentenceSize())
            {
                hash = (37 * hash) + MINING_SENTENCE_SIZE_FIELD_NUMBER;
                hash = (53 * hash) + getMiningSentenceSize();
            }
            if (hasTrainingSentenceSize())
            {
                hash = (37 * hash) + TRAINING_SENTENCE_SIZE_FIELD_NUMBER;
                hash = (53 * hash) + getTrainingSentenceSize();
            }
            if (hasSeedSentencepieceSize())
            {
                hash = (37 * hash) + SEED_SENTENCEPIECE_SIZE_FIELD_NUMBER;
                hash = (53 * hash) + getSeedSentencepieceSize();
            }
            if (hasShrinkingFactor())
            {
                hash = (37 * hash) + SHRINKING_FACTOR_FIELD_NUMBER;
                hash = (53 * hash) + Float.floatToIntBits(
                        getShrinkingFactor());
            }
            if (hasMaxSentenceLength())
            {
                hash = (37 * hash) + MAX_SENTENCE_LENGTH_FIELD_NUMBER;
                hash = (53 * hash) + getMaxSentenceLength();
            }
            if (hasNumThreads())
            {
                hash = (37 * hash) + NUM_THREADS_FIELD_NUMBER;
                hash = (53 * hash) + getNumThreads();
            }
            if (hasNumSubIterations())
            {
                hash = (37 * hash) + NUM_SUB_ITERATIONS_FIELD_NUMBER;
                hash = (53 * hash) + getNumSubIterations();
            }
            if (hasMaxSentencepieceLength())
            {
                hash = (37 * hash) + MAX_SENTENCEPIECE_LENGTH_FIELD_NUMBER;
                hash = (53 * hash) + getMaxSentencepieceLength();
            }
            if (hasSplitByUnicodeScript())
            {
                hash = (37 * hash) + SPLIT_BY_UNICODE_SCRIPT_FIELD_NUMBER;
                hash = (53 * hash) + Internal.hashBoolean(
                        getSplitByUnicodeScript());
            }
            if (hasSplitByNumber())
            {
                hash = (37 * hash) + SPLIT_BY_NUMBER_FIELD_NUMBER;
                hash = (53 * hash) + Internal.hashBoolean(
                        getSplitByNumber());
            }
            if (hasSplitByWhitespace())
            {
                hash = (37 * hash) + SPLIT_BY_WHITESPACE_FIELD_NUMBER;
                hash = (53 * hash) + Internal.hashBoolean(
                        getSplitByWhitespace());
            }
            if (hasTreatWhitespaceAsSuffix())
            {
                hash = (37 * hash) + TREAT_WHITESPACE_AS_SUFFIX_FIELD_NUMBER;
                hash = (53 * hash) + Internal.hashBoolean(
                        getTreatWhitespaceAsSuffix());
            }
            if (hasAllowWhitespaceOnlyPieces())
            {
                hash = (37 * hash) + ALLOW_WHITESPACE_ONLY_PIECES_FIELD_NUMBER;
                hash = (53 * hash) + Internal.hashBoolean(
                        getAllowWhitespaceOnlyPieces());
            }
            if (hasSplitDigits())
            {
                hash = (37 * hash) + SPLIT_DIGITS_FIELD_NUMBER;
                hash = (53 * hash) + Internal.hashBoolean(
                        getSplitDigits());
            }
            if (hasPretokenizationDelimiter())
            {
                hash = (37 * hash) + PRETOKENIZATION_DELIMITER_FIELD_NUMBER;
                hash = (53 * hash) + getPretokenizationDelimiter().hashCode();
            }
            if (getControlSymbolsCount() > 0)
            {
                hash = (37 * hash) + CONTROL_SYMBOLS_FIELD_NUMBER;
                hash = (53 * hash) + getControlSymbolsList().hashCode();
            }
            if (getUserDefinedSymbolsCount() > 0)
            {
                hash = (37 * hash) + USER_DEFINED_SYMBOLS_FIELD_NUMBER;
                hash = (53 * hash) + getUserDefinedSymbolsList().hashCode();
            }
            if (hasRequiredChars())
            {
                hash = (37 * hash) + REQUIRED_CHARS_FIELD_NUMBER;
                hash = (53 * hash) + getRequiredChars().hashCode();
            }
            if (hasByteFallback())
            {
                hash = (37 * hash) + BYTE_FALLBACK_FIELD_NUMBER;
                hash = (53 * hash) + Internal.hashBoolean(
                        getByteFallback());
            }
            if (hasVocabularyOutputPieceScore())
            {
                hash = (37 * hash) + VOCABULARY_OUTPUT_PIECE_SCORE_FIELD_NUMBER;
                hash = (53 * hash) + Internal.hashBoolean(
                        getVocabularyOutputPieceScore());
            }
            if (hasHardVocabLimit())
            {
                hash = (37 * hash) + HARD_VOCAB_LIMIT_FIELD_NUMBER;
                hash = (53 * hash) + Internal.hashBoolean(
                        getHardVocabLimit());
            }
            if (hasUseAllVocab())
            {
                hash = (37 * hash) + USE_ALL_VOCAB_FIELD_NUMBER;
                hash = (53 * hash) + Internal.hashBoolean(
                        getUseAllVocab());
            }
            if (hasUnkId())
            {
                hash = (37 * hash) + UNK_ID_FIELD_NUMBER;
                hash = (53 * hash) + getUnkId();
            }
            if (hasBosId())
            {
                hash = (37 * hash) + BOS_ID_FIELD_NUMBER;
                hash = (53 * hash) + getBosId();
            }
            if (hasEosId())
            {
                hash = (37 * hash) + EOS_ID_FIELD_NUMBER;
                hash = (53 * hash) + getEosId();
            }
            if (hasPadId())
            {
                hash = (37 * hash) + PAD_ID_FIELD_NUMBER;
                hash = (53 * hash) + getPadId();
            }
            if (hasUnkPiece())
            {
                hash = (37 * hash) + UNK_PIECE_FIELD_NUMBER;
                hash = (53 * hash) + getUnkPiece().hashCode();
            }
            if (hasBosPiece())
            {
                hash = (37 * hash) + BOS_PIECE_FIELD_NUMBER;
                hash = (53 * hash) + getBosPiece().hashCode();
            }
            if (hasEosPiece())
            {
                hash = (37 * hash) + EOS_PIECE_FIELD_NUMBER;
                hash = (53 * hash) + getEosPiece().hashCode();
            }
            if (hasPadPiece())
            {
                hash = (37 * hash) + PAD_PIECE_FIELD_NUMBER;
                hash = (53 * hash) + getPadPiece().hashCode();
            }
            if (hasUnkSurface())
            {
                hash = (37 * hash) + UNK_SURFACE_FIELD_NUMBER;
                hash = (53 * hash) + getUnkSurface().hashCode();
            }
            if (hasTrainExtremelyLargeCorpus())
            {
                hash = (37 * hash) + TRAIN_EXTREMELY_LARGE_CORPUS_FIELD_NUMBER;
                hash = (53 * hash) + Internal.hashBoolean(
                        getTrainExtremelyLargeCorpus());
            }
            if (hasSeedSentencepiecesFile())
            {
                hash = (37 * hash) + SEED_SENTENCEPIECES_FILE_FIELD_NUMBER;
                hash = (53 * hash) + getSeedSentencepiecesFile().hashCode();
            }
            hash = hashFields(hash, getExtensionFields());
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }

        public static TrainerSpec parseFrom(
                ByteBuffer data)
                throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data);
        }

        public static TrainerSpec parseFrom(
                ByteBuffer data,
                ExtensionRegistryLite extensionRegistry)
                throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data, extensionRegistry);
        }

        public static TrainerSpec parseFrom(
                ByteString data)
                throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data);
        }

        public static TrainerSpec parseFrom(
                ByteString data,
                ExtensionRegistryLite extensionRegistry)
                throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data, extensionRegistry);
        }

        public static TrainerSpec parseFrom(byte[] data)
                throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data);
        }

        public static TrainerSpec parseFrom(
                byte[] data,
                ExtensionRegistryLite extensionRegistry)
                throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data, extensionRegistry);
        }

        public static TrainerSpec parseFrom(InputStream input)
                throws IOException
        {
            return GeneratedMessage
                    .parseWithIOException(PARSER, input);
        }

        public static TrainerSpec parseFrom(
                InputStream input,
                ExtensionRegistryLite extensionRegistry)
                throws IOException
        {
            return GeneratedMessage
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }

        public static TrainerSpec parseDelimitedFrom(InputStream input)
                throws IOException
        {
            return GeneratedMessage
                    .parseDelimitedWithIOException(PARSER, input);
        }

        public static TrainerSpec parseDelimitedFrom(
                InputStream input,
                ExtensionRegistryLite extensionRegistry)
                throws IOException
        {
            return GeneratedMessage
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }

        public static TrainerSpec parseFrom(
                CodedInputStream input)
                throws IOException
        {
            return GeneratedMessage
                    .parseWithIOException(PARSER, input);
        }

        public static TrainerSpec parseFrom(
                CodedInputStream input,
                ExtensionRegistryLite extensionRegistry)
                throws IOException
        {
            return GeneratedMessage
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }

        @Override
        public Builder newBuilderForType()
        {
            return newBuilder();
        }

        public static Builder newBuilder()
        {
            return DEFAULT_INSTANCE.toBuilder();
        }

        public static Builder newBuilder(TrainerSpec prototype)
        {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }

        @Override
        public Builder toBuilder()
        {
            return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
        }

        @Override
        protected Builder newBuilderForType(
                BuilderParent parent)
        {
            return new Builder(parent);
        }

        /**
         * <pre>
         * TrainerSpec encodes a various parameters for SentencePiece training.
         * Next id: 55
         * </pre>
         * <p>
         * Protobuf type {@code sentencepiece.TrainerSpec}
         */
        public static final class Builder extends ExtendableBuilder<TrainerSpec, Builder> implements TrainerSpecOrBuilder
        {
            public static Descriptors.Descriptor
            getDescriptor()
            {
                return internal_static_sentencepiece_TrainerSpec_descriptor;
            }

            @Override
            protected FieldAccessorTable
            internalGetFieldAccessorTable()
            {
                return internal_static_sentencepiece_TrainerSpec_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                TrainerSpec.class, Builder.class);
            }

            // Construct using TrainerSpec.newBuilder()
            private Builder()
            {

            }

            private Builder(
                    BuilderParent parent)
            {
                super(parent);

            }

            @Override
            public Builder clear()
            {
                super.clear();
                bitField0_ = 0;
                bitField1_ = 0;
                input_ = LazyStringArrayList.emptyList();
                inputFormat_ = "";
                modelPrefix_ = "";
                modelType_ = 1;
                vocabSize_ = 8000;
                acceptLanguage_ = LazyStringArrayList.emptyList();
                selfTestSampleSize_ = 0;
                enableDifferentialPrivacy_ = false;
                differentialPrivacyNoiseLevel_ = 0F;
                differentialPrivacyClippingThreshold_ = 0L;
                characterCoverage_ = 0.9995F;
                inputSentenceSize_ = 0L;
                shuffleInputSentence_ = true;
                miningSentenceSize_ = 0;
                trainingSentenceSize_ = 0;
                seedSentencepieceSize_ = 1000000;
                shrinkingFactor_ = 0.75F;
                maxSentenceLength_ = 4192;
                numThreads_ = 16;
                numSubIterations_ = 2;
                maxSentencepieceLength_ = 16;
                splitByUnicodeScript_ = true;
                splitByNumber_ = true;
                splitByWhitespace_ = true;
                treatWhitespaceAsSuffix_ = false;
                allowWhitespaceOnlyPieces_ = false;
                splitDigits_ = false;
                pretokenizationDelimiter_ = "";
                controlSymbols_ = LazyStringArrayList.emptyList();
                userDefinedSymbols_ = LazyStringArrayList.emptyList();
                requiredChars_ = "";
                byteFallback_ = false;
                vocabularyOutputPieceScore_ = true;
                hardVocabLimit_ = true;
                useAllVocab_ = false;
                unkId_ = 0;
                bosId_ = 1;
                eosId_ = 2;
                padId_ = -1;
                unkPiece_ = "<unk>";
                bosPiece_ = "<s>";
                eosPiece_ = "</s>";
                padPiece_ = "<pad>";
                unkSurface_ = Internal.stringDefaultValue(" \342\201\207 ");
                trainExtremelyLargeCorpus_ = false;
                seedSentencepiecesFile_ = "";
                return this;
            }

            @Override
            public Descriptors.Descriptor
            getDescriptorForType()
            {
                return internal_static_sentencepiece_TrainerSpec_descriptor;
            }

            @Override
            public TrainerSpec getDefaultInstanceForType()
            {
                return TrainerSpec.getDefaultInstance();
            }

            @Override
            public TrainerSpec build()
            {
                TrainerSpec result = buildPartial();
                if (!result.isInitialized())
                {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }

            @Override
            public TrainerSpec buildPartial()
            {
                TrainerSpec result = new TrainerSpec(this);
                if (bitField0_ != 0)
                {
                    buildPartial0(result);
                }
                if (bitField1_ != 0)
                {
                    buildPartial1(result);
                }
                onBuilt();
                return result;
            }

            private void buildPartial0(TrainerSpec result)
            {
                int from_bitField0_ = bitField0_;
                if (((from_bitField0_ & 0x00000001) != 0))
                {
                    input_.makeImmutable();
                    result.input_ = input_;
                }
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000002) != 0))
                {
                    result.inputFormat_ = inputFormat_;
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000004) != 0))
                {
                    result.modelPrefix_ = modelPrefix_;
                    to_bitField0_ |= 0x00000002;
                }
                if (((from_bitField0_ & 0x00000008) != 0))
                {
                    result.modelType_ = modelType_;
                    to_bitField0_ |= 0x00000004;
                }
                if (((from_bitField0_ & 0x00000010) != 0))
                {
                    result.vocabSize_ = vocabSize_;
                    to_bitField0_ |= 0x00000008;
                }
                if (((from_bitField0_ & 0x00000020) != 0))
                {
                    acceptLanguage_.makeImmutable();
                    result.acceptLanguage_ = acceptLanguage_;
                }
                if (((from_bitField0_ & 0x00000040) != 0))
                {
                    result.selfTestSampleSize_ = selfTestSampleSize_;
                    to_bitField0_ |= 0x00000010;
                }
                if (((from_bitField0_ & 0x00000080) != 0))
                {
                    result.enableDifferentialPrivacy_ = enableDifferentialPrivacy_;
                    to_bitField0_ |= 0x00000020;
                }
                if (((from_bitField0_ & 0x00000100) != 0))
                {
                    result.differentialPrivacyNoiseLevel_ = differentialPrivacyNoiseLevel_;
                    to_bitField0_ |= 0x00000040;
                }
                if (((from_bitField0_ & 0x00000200) != 0))
                {
                    result.differentialPrivacyClippingThreshold_ = differentialPrivacyClippingThreshold_;
                    to_bitField0_ |= 0x00000080;
                }
                if (((from_bitField0_ & 0x00000400) != 0))
                {
                    result.characterCoverage_ = characterCoverage_;
                    to_bitField0_ |= 0x00000100;
                }
                if (((from_bitField0_ & 0x00000800) != 0))
                {
                    result.inputSentenceSize_ = inputSentenceSize_;
                    to_bitField0_ |= 0x00000200;
                }
                if (((from_bitField0_ & 0x00001000) != 0))
                {
                    result.shuffleInputSentence_ = shuffleInputSentence_;
                    to_bitField0_ |= 0x00000400;
                }
                if (((from_bitField0_ & 0x00002000) != 0))
                {
                    result.miningSentenceSize_ = miningSentenceSize_;
                    to_bitField0_ |= 0x00000800;
                }
                if (((from_bitField0_ & 0x00004000) != 0))
                {
                    result.trainingSentenceSize_ = trainingSentenceSize_;
                    to_bitField0_ |= 0x00001000;
                }
                if (((from_bitField0_ & 0x00008000) != 0))
                {
                    result.seedSentencepieceSize_ = seedSentencepieceSize_;
                    to_bitField0_ |= 0x00002000;
                }
                if (((from_bitField0_ & 0x00010000) != 0))
                {
                    result.shrinkingFactor_ = shrinkingFactor_;
                    to_bitField0_ |= 0x00004000;
                }
                if (((from_bitField0_ & 0x00020000) != 0))
                {
                    result.maxSentenceLength_ = maxSentenceLength_;
                    to_bitField0_ |= 0x00008000;
                }
                if (((from_bitField0_ & 0x00040000) != 0))
                {
                    result.numThreads_ = numThreads_;
                    to_bitField0_ |= 0x00010000;
                }
                if (((from_bitField0_ & 0x00080000) != 0))
                {
                    result.numSubIterations_ = numSubIterations_;
                    to_bitField0_ |= 0x00020000;
                }
                if (((from_bitField0_ & 0x00100000) != 0))
                {
                    result.maxSentencepieceLength_ = maxSentencepieceLength_;
                    to_bitField0_ |= 0x00040000;
                }
                if (((from_bitField0_ & 0x00200000) != 0))
                {
                    result.splitByUnicodeScript_ = splitByUnicodeScript_;
                    to_bitField0_ |= 0x00080000;
                }
                if (((from_bitField0_ & 0x00400000) != 0))
                {
                    result.splitByNumber_ = splitByNumber_;
                    to_bitField0_ |= 0x00100000;
                }
                if (((from_bitField0_ & 0x00800000) != 0))
                {
                    result.splitByWhitespace_ = splitByWhitespace_;
                    to_bitField0_ |= 0x00200000;
                }
                if (((from_bitField0_ & 0x01000000) != 0))
                {
                    result.treatWhitespaceAsSuffix_ = treatWhitespaceAsSuffix_;
                    to_bitField0_ |= 0x00400000;
                }
                if (((from_bitField0_ & 0x02000000) != 0))
                {
                    result.allowWhitespaceOnlyPieces_ = allowWhitespaceOnlyPieces_;
                    to_bitField0_ |= 0x00800000;
                }
                if (((from_bitField0_ & 0x04000000) != 0))
                {
                    result.splitDigits_ = splitDigits_;
                    to_bitField0_ |= 0x01000000;
                }
                if (((from_bitField0_ & 0x08000000) != 0))
                {
                    result.pretokenizationDelimiter_ = pretokenizationDelimiter_;
                    to_bitField0_ |= 0x02000000;
                }
                if (((from_bitField0_ & 0x10000000) != 0))
                {
                    controlSymbols_.makeImmutable();
                    result.controlSymbols_ = controlSymbols_;
                }
                if (((from_bitField0_ & 0x20000000) != 0))
                {
                    userDefinedSymbols_.makeImmutable();
                    result.userDefinedSymbols_ = userDefinedSymbols_;
                }
                if (((from_bitField0_ & 0x40000000) != 0))
                {
                    result.requiredChars_ = requiredChars_;
                    to_bitField0_ |= 0x04000000;
                }
                if (((from_bitField0_ & 0x80000000) != 0))
                {
                    result.byteFallback_ = byteFallback_;
                    to_bitField0_ |= 0x08000000;
                }
                result.bitField0_ |= to_bitField0_;
            }

            private void buildPartial1(TrainerSpec result)
            {
                int from_bitField1_ = bitField1_;
                int to_bitField0_ = 0;
                if (((from_bitField1_ & 0x00000001) != 0))
                {
                    result.vocabularyOutputPieceScore_ = vocabularyOutputPieceScore_;
                    to_bitField0_ |= 0x10000000;
                }
                if (((from_bitField1_ & 0x00000002) != 0))
                {
                    result.hardVocabLimit_ = hardVocabLimit_;
                    to_bitField0_ |= 0x20000000;
                }
                if (((from_bitField1_ & 0x00000004) != 0))
                {
                    result.useAllVocab_ = useAllVocab_;
                    to_bitField0_ |= 0x40000000;
                }
                if (((from_bitField1_ & 0x00000008) != 0))
                {
                    result.unkId_ = unkId_;
                    to_bitField0_ |= 0x80000000;
                }
                int to_bitField1_ = 0;
                if (((from_bitField1_ & 0x00000010) != 0))
                {
                    result.bosId_ = bosId_;
                    to_bitField1_ |= 0x00000001;
                }
                if (((from_bitField1_ & 0x00000020) != 0))
                {
                    result.eosId_ = eosId_;
                    to_bitField1_ |= 0x00000002;
                }
                if (((from_bitField1_ & 0x00000040) != 0))
                {
                    result.padId_ = padId_;
                    to_bitField1_ |= 0x00000004;
                }
                if (((from_bitField1_ & 0x00000080) != 0))
                {
                    result.unkPiece_ = unkPiece_;
                    to_bitField1_ |= 0x00000008;
                }
                if (((from_bitField1_ & 0x00000100) != 0))
                {
                    result.bosPiece_ = bosPiece_;
                    to_bitField1_ |= 0x00000010;
                }
                if (((from_bitField1_ & 0x00000200) != 0))
                {
                    result.eosPiece_ = eosPiece_;
                    to_bitField1_ |= 0x00000020;
                }
                if (((from_bitField1_ & 0x00000400) != 0))
                {
                    result.padPiece_ = padPiece_;
                    to_bitField1_ |= 0x00000040;
                }
                if (((from_bitField1_ & 0x00000800) != 0))
                {
                    result.unkSurface_ = unkSurface_;
                    to_bitField1_ |= 0x00000080;
                }
                if (((from_bitField1_ & 0x00001000) != 0))
                {
                    result.trainExtremelyLargeCorpus_ = trainExtremelyLargeCorpus_;
                    to_bitField1_ |= 0x00000100;
                }
                if (((from_bitField1_ & 0x00002000) != 0))
                {
                    result.seedSentencepiecesFile_ = seedSentencepiecesFile_;
                    to_bitField1_ |= 0x00000200;
                }
                result.bitField0_ |= to_bitField0_;
                result.bitField1_ |= to_bitField1_;
            }

            @Override
            public Builder mergeFrom(Message other)
            {
                if (other instanceof TrainerSpec)
                {
                    return mergeFrom((TrainerSpec) other);
                }
                else
                {
                    super.mergeFrom(other);
                    return this;
                }
            }

            public Builder mergeFrom(TrainerSpec other)
            {
                if (other == TrainerSpec.getDefaultInstance()) return this;
                if (!other.input_.isEmpty())
                {
                    if (input_.isEmpty())
                    {
                        input_ = other.input_;
                        bitField0_ |= 0x00000001;
                    }
                    else
                    {
                        ensureInputIsMutable();
                        input_.addAll(other.input_);
                    }
                    onChanged();
                }
                if (other.hasInputFormat())
                {
                    inputFormat_ = other.inputFormat_;
                    bitField0_ |= 0x00000002;
                    onChanged();
                }
                if (other.hasModelPrefix())
                {
                    modelPrefix_ = other.modelPrefix_;
                    bitField0_ |= 0x00000004;
                    onChanged();
                }
                if (other.hasModelType())
                {
                    setModelType(other.getModelType());
                }
                if (other.hasVocabSize())
                {
                    setVocabSize(other.getVocabSize());
                }
                if (!other.acceptLanguage_.isEmpty())
                {
                    if (acceptLanguage_.isEmpty())
                    {
                        acceptLanguage_ = other.acceptLanguage_;
                        bitField0_ |= 0x00000020;
                    }
                    else
                    {
                        ensureAcceptLanguageIsMutable();
                        acceptLanguage_.addAll(other.acceptLanguage_);
                    }
                    onChanged();
                }
                if (other.hasSelfTestSampleSize())
                {
                    setSelfTestSampleSize(other.getSelfTestSampleSize());
                }
                if (other.hasEnableDifferentialPrivacy())
                {
                    setEnableDifferentialPrivacy(other.getEnableDifferentialPrivacy());
                }
                if (other.hasDifferentialPrivacyNoiseLevel())
                {
                    setDifferentialPrivacyNoiseLevel(other.getDifferentialPrivacyNoiseLevel());
                }
                if (other.hasDifferentialPrivacyClippingThreshold())
                {
                    setDifferentialPrivacyClippingThreshold(other.getDifferentialPrivacyClippingThreshold());
                }
                if (other.hasCharacterCoverage())
                {
                    setCharacterCoverage(other.getCharacterCoverage());
                }
                if (other.hasInputSentenceSize())
                {
                    setInputSentenceSize(other.getInputSentenceSize());
                }
                if (other.hasShuffleInputSentence())
                {
                    setShuffleInputSentence(other.getShuffleInputSentence());
                }
                if (other.hasMiningSentenceSize())
                {
                    setMiningSentenceSize(other.getMiningSentenceSize());
                }
                if (other.hasTrainingSentenceSize())
                {
                    setTrainingSentenceSize(other.getTrainingSentenceSize());
                }
                if (other.hasSeedSentencepieceSize())
                {
                    setSeedSentencepieceSize(other.getSeedSentencepieceSize());
                }
                if (other.hasShrinkingFactor())
                {
                    setShrinkingFactor(other.getShrinkingFactor());
                }
                if (other.hasMaxSentenceLength())
                {
                    setMaxSentenceLength(other.getMaxSentenceLength());
                }
                if (other.hasNumThreads())
                {
                    setNumThreads(other.getNumThreads());
                }
                if (other.hasNumSubIterations())
                {
                    setNumSubIterations(other.getNumSubIterations());
                }
                if (other.hasMaxSentencepieceLength())
                {
                    setMaxSentencepieceLength(other.getMaxSentencepieceLength());
                }
                if (other.hasSplitByUnicodeScript())
                {
                    setSplitByUnicodeScript(other.getSplitByUnicodeScript());
                }
                if (other.hasSplitByNumber())
                {
                    setSplitByNumber(other.getSplitByNumber());
                }
                if (other.hasSplitByWhitespace())
                {
                    setSplitByWhitespace(other.getSplitByWhitespace());
                }
                if (other.hasTreatWhitespaceAsSuffix())
                {
                    setTreatWhitespaceAsSuffix(other.getTreatWhitespaceAsSuffix());
                }
                if (other.hasAllowWhitespaceOnlyPieces())
                {
                    setAllowWhitespaceOnlyPieces(other.getAllowWhitespaceOnlyPieces());
                }
                if (other.hasSplitDigits())
                {
                    setSplitDigits(other.getSplitDigits());
                }
                if (other.hasPretokenizationDelimiter())
                {
                    pretokenizationDelimiter_ = other.pretokenizationDelimiter_;
                    bitField0_ |= 0x08000000;
                    onChanged();
                }
                if (!other.controlSymbols_.isEmpty())
                {
                    if (controlSymbols_.isEmpty())
                    {
                        controlSymbols_ = other.controlSymbols_;
                        bitField0_ |= 0x10000000;
                    }
                    else
                    {
                        ensureControlSymbolsIsMutable();
                        controlSymbols_.addAll(other.controlSymbols_);
                    }
                    onChanged();
                }
                if (!other.userDefinedSymbols_.isEmpty())
                {
                    if (userDefinedSymbols_.isEmpty())
                    {
                        userDefinedSymbols_ = other.userDefinedSymbols_;
                        bitField0_ |= 0x20000000;
                    }
                    else
                    {
                        ensureUserDefinedSymbolsIsMutable();
                        userDefinedSymbols_.addAll(other.userDefinedSymbols_);
                    }
                    onChanged();
                }
                if (other.hasRequiredChars())
                {
                    requiredChars_ = other.requiredChars_;
                    bitField0_ |= 0x40000000;
                    onChanged();
                }
                if (other.hasByteFallback())
                {
                    setByteFallback(other.getByteFallback());
                }
                if (other.hasVocabularyOutputPieceScore())
                {
                    setVocabularyOutputPieceScore(other.getVocabularyOutputPieceScore());
                }
                if (other.hasHardVocabLimit())
                {
                    setHardVocabLimit(other.getHardVocabLimit());
                }
                if (other.hasUseAllVocab())
                {
                    setUseAllVocab(other.getUseAllVocab());
                }
                if (other.hasUnkId())
                {
                    setUnkId(other.getUnkId());
                }
                if (other.hasBosId())
                {
                    setBosId(other.getBosId());
                }
                if (other.hasEosId())
                {
                    setEosId(other.getEosId());
                }
                if (other.hasPadId())
                {
                    setPadId(other.getPadId());
                }
                if (other.hasUnkPiece())
                {
                    unkPiece_ = other.unkPiece_;
                    bitField1_ |= 0x00000080;
                    onChanged();
                }
                if (other.hasBosPiece())
                {
                    bosPiece_ = other.bosPiece_;
                    bitField1_ |= 0x00000100;
                    onChanged();
                }
                if (other.hasEosPiece())
                {
                    eosPiece_ = other.eosPiece_;
                    bitField1_ |= 0x00000200;
                    onChanged();
                }
                if (other.hasPadPiece())
                {
                    padPiece_ = other.padPiece_;
                    bitField1_ |= 0x00000400;
                    onChanged();
                }
                if (other.hasUnkSurface())
                {
                    unkSurface_ = other.unkSurface_;
                    bitField1_ |= 0x00000800;
                    onChanged();
                }
                if (other.hasTrainExtremelyLargeCorpus())
                {
                    setTrainExtremelyLargeCorpus(other.getTrainExtremelyLargeCorpus());
                }
                if (other.hasSeedSentencepiecesFile())
                {
                    seedSentencepiecesFile_ = other.seedSentencepiecesFile_;
                    bitField1_ |= 0x00002000;
                    onChanged();
                }
                this.mergeExtensionFields(other);
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }

            @Override
            public boolean isInitialized()
            {
                return extensionsAreInitialized();
            }

            @Override
            public Builder mergeFrom(
                    CodedInputStream input,
                    ExtensionRegistryLite extensionRegistry)
                    throws IOException
            {
                if (extensionRegistry == null)
                {
                    throw new NullPointerException();
                }
                try
                {
                    boolean done = false;
                    while (!done)
                    {
                        int tag = input.readTag();
                        switch (tag)
                        {
                            case 0:
                                done = true;
                                break;
                            case 10:
                            {
                                ByteString bs = input.readBytes();
                                ensureInputIsMutable();
                                input_.add(bs);
                                break;
                            } // case 10
                            case 18:
                            {
                                modelPrefix_ = input.readBytes();
                                bitField0_ |= 0x00000004;
                                break;
                            } // case 18
                            case 24:
                            {
                                int tmpRaw = input.readEnum();
                                ModelType tmpValue =
                                        ModelType.forNumber(tmpRaw);
                                if (tmpValue == null)
                                {
                                    mergeUnknownVarintField(3, tmpRaw);
                                }
                                else
                                {
                                    modelType_ = tmpRaw;
                                    bitField0_ |= 0x00000008;
                                }
                                break;
                            } // case 24
                            case 32:
                            {
                                vocabSize_ = input.readInt32();
                                bitField0_ |= 0x00000010;
                                break;
                            } // case 32
                            case 42:
                            {
                                ByteString bs = input.readBytes();
                                ensureAcceptLanguageIsMutable();
                                acceptLanguage_.add(bs);
                                break;
                            } // case 42
                            case 48:
                            {
                                selfTestSampleSize_ = input.readInt32();
                                bitField0_ |= 0x00000040;
                                break;
                            } // case 48
                            case 58:
                            {
                                inputFormat_ = input.readBytes();
                                bitField0_ |= 0x00000002;
                                break;
                            } // case 58
                            case 85:
                            {
                                characterCoverage_ = input.readFloat();
                                bitField0_ |= 0x00000400;
                                break;
                            } // case 85
                            case 88:
                            {
                                inputSentenceSize_ = input.readUInt64();
                                bitField0_ |= 0x00000800;
                                break;
                            } // case 88
                            case 96:
                            {
                                miningSentenceSize_ = input.readInt32();
                                bitField0_ |= 0x00002000;
                                break;
                            } // case 96
                            case 104:
                            {
                                trainingSentenceSize_ = input.readInt32();
                                bitField0_ |= 0x00004000;
                                break;
                            } // case 104
                            case 112:
                            {
                                seedSentencepieceSize_ = input.readInt32();
                                bitField0_ |= 0x00008000;
                                break;
                            } // case 112
                            case 125:
                            {
                                shrinkingFactor_ = input.readFloat();
                                bitField0_ |= 0x00010000;
                                break;
                            } // case 125
                            case 128:
                            {
                                numThreads_ = input.readInt32();
                                bitField0_ |= 0x00040000;
                                break;
                            } // case 128
                            case 136:
                            {
                                numSubIterations_ = input.readInt32();
                                bitField0_ |= 0x00080000;
                                break;
                            } // case 136
                            case 144:
                            {
                                maxSentenceLength_ = input.readInt32();
                                bitField0_ |= 0x00020000;
                                break;
                            } // case 144
                            case 152:
                            {
                                shuffleInputSentence_ = input.readBool();
                                bitField0_ |= 0x00001000;
                                break;
                            } // case 152
                            case 160:
                            {
                                maxSentencepieceLength_ = input.readInt32();
                                bitField0_ |= 0x00100000;
                                break;
                            } // case 160
                            case 168:
                            {
                                splitByUnicodeScript_ = input.readBool();
                                bitField0_ |= 0x00200000;
                                break;
                            } // case 168
                            case 176:
                            {
                                splitByWhitespace_ = input.readBool();
                                bitField0_ |= 0x00800000;
                                break;
                            } // case 176
                            case 184:
                            {
                                splitByNumber_ = input.readBool();
                                bitField0_ |= 0x00400000;
                                break;
                            } // case 184
                            case 192:
                            {
                                treatWhitespaceAsSuffix_ = input.readBool();
                                bitField0_ |= 0x01000000;
                                break;
                            } // case 192
                            case 200:
                            {
                                splitDigits_ = input.readBool();
                                bitField0_ |= 0x04000000;
                                break;
                            } // case 200
                            case 208:
                            {
                                allowWhitespaceOnlyPieces_ = input.readBool();
                                bitField0_ |= 0x02000000;
                                break;
                            } // case 208
                            case 242:
                            {
                                ByteString bs = input.readBytes();
                                ensureControlSymbolsIsMutable();
                                controlSymbols_.add(bs);
                                break;
                            } // case 242
                            case 250:
                            {
                                ByteString bs = input.readBytes();
                                ensureUserDefinedSymbolsIsMutable();
                                userDefinedSymbols_.add(bs);
                                break;
                            } // case 250
                            case 256:
                            {
                                vocabularyOutputPieceScore_ = input.readBool();
                                bitField1_ |= 0x00000001;
                                break;
                            } // case 256
                            case 264:
                            {
                                hardVocabLimit_ = input.readBool();
                                bitField1_ |= 0x00000002;
                                break;
                            } // case 264
                            case 272:
                            {
                                useAllVocab_ = input.readBool();
                                bitField1_ |= 0x00000004;
                                break;
                            } // case 272
                            case 280:
                            {
                                byteFallback_ = input.readBool();
                                bitField0_ |= 0x80000000;
                                break;
                            } // case 280
                            case 290:
                            {
                                requiredChars_ = input.readBytes();
                                bitField0_ |= 0x40000000;
                                break;
                            } // case 290
                            case 320:
                            {
                                unkId_ = input.readInt32();
                                bitField1_ |= 0x00000008;
                                break;
                            } // case 320
                            case 328:
                            {
                                bosId_ = input.readInt32();
                                bitField1_ |= 0x00000010;
                                break;
                            } // case 328
                            case 336:
                            {
                                eosId_ = input.readInt32();
                                bitField1_ |= 0x00000020;
                                break;
                            } // case 336
                            case 344:
                            {
                                padId_ = input.readInt32();
                                bitField1_ |= 0x00000040;
                                break;
                            } // case 344
                            case 354:
                            {
                                unkSurface_ = input.readBytes();
                                bitField1_ |= 0x00000800;
                                break;
                            } // case 354
                            case 362:
                            {
                                unkPiece_ = input.readBytes();
                                bitField1_ |= 0x00000080;
                                break;
                            } // case 362
                            case 370:
                            {
                                bosPiece_ = input.readBytes();
                                bitField1_ |= 0x00000100;
                                break;
                            } // case 370
                            case 378:
                            {
                                eosPiece_ = input.readBytes();
                                bitField1_ |= 0x00000200;
                                break;
                            } // case 378
                            case 386:
                            {
                                padPiece_ = input.readBytes();
                                bitField1_ |= 0x00000400;
                                break;
                            } // case 386
                            case 392:
                            {
                                trainExtremelyLargeCorpus_ = input.readBool();
                                bitField1_ |= 0x00001000;
                                break;
                            } // case 392
                            case 400:
                            {
                                enableDifferentialPrivacy_ = input.readBool();
                                bitField0_ |= 0x00000080;
                                break;
                            } // case 400
                            case 413:
                            {
                                differentialPrivacyNoiseLevel_ = input.readFloat();
                                bitField0_ |= 0x00000100;
                                break;
                            } // case 413
                            case 416:
                            {
                                differentialPrivacyClippingThreshold_ = input.readUInt64();
                                bitField0_ |= 0x00000200;
                                break;
                            } // case 416
                            case 426:
                            {
                                pretokenizationDelimiter_ = input.readBytes();
                                bitField0_ |= 0x08000000;
                                break;
                            } // case 426
                            case 434:
                            {
                                seedSentencepiecesFile_ = input.readBytes();
                                bitField1_ |= 0x00002000;
                                break;
                            } // case 434
                            default:
                            {
                                if (!super.parseUnknownField(input, extensionRegistry, tag))
                                {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (InvalidProtocolBufferException e)
                {
                    throw e.unwrapIOException();
                } finally
                {
                    onChanged();
                } // finally
                return this;
            }

            private int bitField0_;
            private int bitField1_;

            private LazyStringArrayList input_ = LazyStringArrayList.emptyList();

            private void ensureInputIsMutable()
            {
                if (!input_.isModifiable())
                {
                    input_ = new LazyStringArrayList(input_);
                }
                bitField0_ |= 0x00000001;
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * General parameters
             *
             * Input corpus files.
             * Trainer accepts the following two formats:
             * A) Monolingual: plain text, one sentence per line.
             * B) Bilingual:   TSV, source sentence &lt;tab&gt; target sentence
             * When bilingual data is passed, shared vocabulary model is built.
             * Note that the input file must be raw corpus, not a preprocessed corpus.
             * Trainer only loads the first `input_sentence_size` sentences specified
             * with this parameter.
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             *
             * @return A list containing the input.
             */
            public ProtocolStringList getInputList()
            {
                input_.makeImmutable();
                return input_;
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * General parameters
             *
             * Input corpus files.
             * Trainer accepts the following two formats:
             * A) Monolingual: plain text, one sentence per line.
             * B) Bilingual:   TSV, source sentence &lt;tab&gt; target sentence
             * When bilingual data is passed, shared vocabulary model is built.
             * Note that the input file must be raw corpus, not a preprocessed corpus.
             * Trainer only loads the first `input_sentence_size` sentences specified
             * with this parameter.
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             *
             * @return The count of input.
             */
            public int getInputCount()
            {
                return input_.size();
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * General parameters
             *
             * Input corpus files.
             * Trainer accepts the following two formats:
             * A) Monolingual: plain text, one sentence per line.
             * B) Bilingual:   TSV, source sentence &lt;tab&gt; target sentence
             * When bilingual data is passed, shared vocabulary model is built.
             * Note that the input file must be raw corpus, not a preprocessed corpus.
             * Trainer only loads the first `input_sentence_size` sentences specified
             * with this parameter.
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             *
             * @param index The index of the element to return.
             * @return The input at the given index.
             */
            public String getInput(int index)
            {
                return input_.get(index);
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * General parameters
             *
             * Input corpus files.
             * Trainer accepts the following two formats:
             * A) Monolingual: plain text, one sentence per line.
             * B) Bilingual:   TSV, source sentence &lt;tab&gt; target sentence
             * When bilingual data is passed, shared vocabulary model is built.
             * Note that the input file must be raw corpus, not a preprocessed corpus.
             * Trainer only loads the first `input_sentence_size` sentences specified
             * with this parameter.
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             *
             * @param index The index of the value to return.
             * @return The bytes of the input at the given index.
             */
            public ByteString
            getInputBytes(int index)
            {
                return input_.getByteString(index);
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * General parameters
             *
             * Input corpus files.
             * Trainer accepts the following two formats:
             * A) Monolingual: plain text, one sentence per line.
             * B) Bilingual:   TSV, source sentence &lt;tab&gt; target sentence
             * When bilingual data is passed, shared vocabulary model is built.
             * Note that the input file must be raw corpus, not a preprocessed corpus.
             * Trainer only loads the first `input_sentence_size` sentences specified
             * with this parameter.
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             *
             * @param index The index to set the value at.
             * @param value The input to set.
             * @return This builder for chaining.
             */
            public Builder setInput(int index, String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                ensureInputIsMutable();
                input_.set(index, value);
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * General parameters
             *
             * Input corpus files.
             * Trainer accepts the following two formats:
             * A) Monolingual: plain text, one sentence per line.
             * B) Bilingual:   TSV, source sentence &lt;tab&gt; target sentence
             * When bilingual data is passed, shared vocabulary model is built.
             * Note that the input file must be raw corpus, not a preprocessed corpus.
             * Trainer only loads the first `input_sentence_size` sentences specified
             * with this parameter.
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             *
             * @param value The input to add.
             * @return This builder for chaining.
             */
            public Builder addInput(String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                ensureInputIsMutable();
                input_.add(value);
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * General parameters
             *
             * Input corpus files.
             * Trainer accepts the following two formats:
             * A) Monolingual: plain text, one sentence per line.
             * B) Bilingual:   TSV, source sentence &lt;tab&gt; target sentence
             * When bilingual data is passed, shared vocabulary model is built.
             * Note that the input file must be raw corpus, not a preprocessed corpus.
             * Trainer only loads the first `input_sentence_size` sentences specified
             * with this parameter.
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             *
             * @param values The input to add.
             * @return This builder for chaining.
             */
            public Builder addAllInput(Iterable<String> values)
            {
                ensureInputIsMutable();
                AbstractMessageLite.Builder.addAll(values, input_);
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * General parameters
             *
             * Input corpus files.
             * Trainer accepts the following two formats:
             * A) Monolingual: plain text, one sentence per line.
             * B) Bilingual:   TSV, source sentence &lt;tab&gt; target sentence
             * When bilingual data is passed, shared vocabulary model is built.
             * Note that the input file must be raw corpus, not a preprocessed corpus.
             * Trainer only loads the first `input_sentence_size` sentences specified
             * with this parameter.
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearInput()
            {
                input_ = LazyStringArrayList.emptyList();
                bitField0_ = (bitField0_ & ~0x00000001);
                onChanged();
                return this;
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * General parameters
             *
             * Input corpus files.
             * Trainer accepts the following two formats:
             * A) Monolingual: plain text, one sentence per line.
             * B) Bilingual:   TSV, source sentence &lt;tab&gt; target sentence
             * When bilingual data is passed, shared vocabulary model is built.
             * Note that the input file must be raw corpus, not a preprocessed corpus.
             * Trainer only loads the first `input_sentence_size` sentences specified
             * with this parameter.
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             *
             * @param value The bytes of the input to add.
             * @return This builder for chaining.
             */
            public Builder addInputBytes(ByteString value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                ensureInputIsMutable();
                input_.add(value);
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }

            private Object inputFormat_ = "";

            /**
             * <pre>
             * Input corpus format:
             * "text": one-sentence-per-line text format (default)
             * "tsv":  sentence &lt;tab&gt; freq
             * </pre>
             *
             * <code>optional string input_format = 7;</code>
             *
             * @return Whether the inputFormat field is set.
             */
            public boolean hasInputFormat()
            {
                return ((bitField0_ & 0x00000002) != 0);
            }

            /**
             * <pre>
             * Input corpus format:
             * "text": one-sentence-per-line text format (default)
             * "tsv":  sentence &lt;tab&gt; freq
             * </pre>
             *
             * <code>optional string input_format = 7;</code>
             *
             * @return The inputFormat.
             */
            public String getInputFormat()
            {
                Object ref = inputFormat_;
                if (!(ref instanceof String))
                {
                    ByteString bs = (ByteString) ref;
                    String s = bs.toStringUtf8();
                    if (bs.isValidUtf8())
                    {
                        inputFormat_ = s;
                    }
                    return s;
                }
                else
                {
                    return (String) ref;
                }
            }

            /**
             * <pre>
             * Input corpus format:
             * "text": one-sentence-per-line text format (default)
             * "tsv":  sentence &lt;tab&gt; freq
             * </pre>
             *
             * <code>optional string input_format = 7;</code>
             *
             * @return The bytes for inputFormat.
             */
            public ByteString
            getInputFormatBytes()
            {
                Object ref = inputFormat_;
                if (ref instanceof String)
                {
                    ByteString b = ByteString.copyFromUtf8((String) ref);
                    inputFormat_ = b;
                    return b;
                }
                else
                {
                    return (ByteString) ref;
                }
            }

            /**
             * <pre>
             * Input corpus format:
             * "text": one-sentence-per-line text format (default)
             * "tsv":  sentence &lt;tab&gt; freq
             * </pre>
             *
             * <code>optional string input_format = 7;</code>
             *
             * @param value The inputFormat to set.
             * @return This builder for chaining.
             */
            public Builder setInputFormat(String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                inputFormat_ = value;
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Input corpus format:
             * "text": one-sentence-per-line text format (default)
             * "tsv":  sentence &lt;tab&gt; freq
             * </pre>
             *
             * <code>optional string input_format = 7;</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearInputFormat()
            {
                inputFormat_ = getDefaultInstance().getInputFormat();
                bitField0_ = (bitField0_ & ~0x00000002);
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Input corpus format:
             * "text": one-sentence-per-line text format (default)
             * "tsv":  sentence &lt;tab&gt; freq
             * </pre>
             *
             * <code>optional string input_format = 7;</code>
             *
             * @param value The bytes for inputFormat to set.
             * @return This builder for chaining.
             */
            public Builder setInputFormatBytes(ByteString value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                inputFormat_ = value;
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }

            private Object modelPrefix_ = "";

            /**
             * <pre>
             * Output model file prefix.
             * &lt;model_prefix&gt;.model and &lt;model_prefix&gt;.vocab are generated.
             * </pre>
             *
             * <code>optional string model_prefix = 2;</code>
             *
             * @return Whether the modelPrefix field is set.
             */
            public boolean hasModelPrefix()
            {
                return ((bitField0_ & 0x00000004) != 0);
            }

            /**
             * <pre>
             * Output model file prefix.
             * &lt;model_prefix&gt;.model and &lt;model_prefix&gt;.vocab are generated.
             * </pre>
             *
             * <code>optional string model_prefix = 2;</code>
             *
             * @return The modelPrefix.
             */
            public String getModelPrefix()
            {
                Object ref = modelPrefix_;
                if (!(ref instanceof String))
                {
                    ByteString bs = (ByteString) ref;
                    String s = bs.toStringUtf8();
                    if (bs.isValidUtf8())
                    {
                        modelPrefix_ = s;
                    }
                    return s;
                }
                else
                {
                    return (String) ref;
                }
            }

            /**
             * <pre>
             * Output model file prefix.
             * &lt;model_prefix&gt;.model and &lt;model_prefix&gt;.vocab are generated.
             * </pre>
             *
             * <code>optional string model_prefix = 2;</code>
             *
             * @return The bytes for modelPrefix.
             */
            public ByteString
            getModelPrefixBytes()
            {
                Object ref = modelPrefix_;
                if (ref instanceof String)
                {
                    ByteString b = ByteString.copyFromUtf8((String) ref);
                    modelPrefix_ = b;
                    return b;
                }
                else
                {
                    return (ByteString) ref;
                }
            }

            /**
             * <pre>
             * Output model file prefix.
             * &lt;model_prefix&gt;.model and &lt;model_prefix&gt;.vocab are generated.
             * </pre>
             *
             * <code>optional string model_prefix = 2;</code>
             *
             * @param value The modelPrefix to set.
             * @return This builder for chaining.
             */
            public Builder setModelPrefix(String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                modelPrefix_ = value;
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Output model file prefix.
             * &lt;model_prefix&gt;.model and &lt;model_prefix&gt;.vocab are generated.
             * </pre>
             *
             * <code>optional string model_prefix = 2;</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearModelPrefix()
            {
                modelPrefix_ = getDefaultInstance().getModelPrefix();
                bitField0_ = (bitField0_ & ~0x00000004);
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Output model file prefix.
             * &lt;model_prefix&gt;.model and &lt;model_prefix&gt;.vocab are generated.
             * </pre>
             *
             * <code>optional string model_prefix = 2;</code>
             *
             * @param value The bytes for modelPrefix to set.
             * @return This builder for chaining.
             */
            public Builder setModelPrefixBytes(ByteString value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                modelPrefix_ = value;
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }

            private int modelType_ = 1;

            /**
             * <code>optional .sentencepiece.TrainerSpec.ModelType model_type = 3 [default = UNIGRAM];</code>
             *
             * @return Whether the modelType field is set.
             */
            @Override
            public boolean hasModelType()
            {
                return ((bitField0_ & 0x00000008) != 0);
            }

            /**
             * <code>optional .sentencepiece.TrainerSpec.ModelType model_type = 3 [default = UNIGRAM];</code>
             *
             * @return The modelType.
             */
            @Override
            public ModelType getModelType()
            {
                ModelType result = ModelType.forNumber(modelType_);
                return result == null ? ModelType.UNIGRAM : result;
            }

            /**
             * <code>optional .sentencepiece.TrainerSpec.ModelType model_type = 3 [default = UNIGRAM];</code>
             *
             * @param value The modelType to set.
             * @return This builder for chaining.
             */
            public Builder setModelType(ModelType value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000008;
                modelType_ = value.getNumber();
                onChanged();
                return this;
            }

            /**
             * <code>optional .sentencepiece.TrainerSpec.ModelType model_type = 3 [default = UNIGRAM];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearModelType()
            {
                bitField0_ = (bitField0_ & ~0x00000008);
                modelType_ = 1;
                onChanged();
                return this;
            }

            private int vocabSize_ = 8000;

            /**
             * <pre>
             * Vocabulary size. 8k is the default size.
             * </pre>
             *
             * <code>optional int32 vocab_size = 4 [default = 8000];</code>
             *
             * @return Whether the vocabSize field is set.
             */
            @Override
            public boolean hasVocabSize()
            {
                return ((bitField0_ & 0x00000010) != 0);
            }

            /**
             * <pre>
             * Vocabulary size. 8k is the default size.
             * </pre>
             *
             * <code>optional int32 vocab_size = 4 [default = 8000];</code>
             *
             * @return The vocabSize.
             */
            @Override
            public int getVocabSize()
            {
                return vocabSize_;
            }

            /**
             * <pre>
             * Vocabulary size. 8k is the default size.
             * </pre>
             *
             * <code>optional int32 vocab_size = 4 [default = 8000];</code>
             *
             * @param value The vocabSize to set.
             * @return This builder for chaining.
             */
            public Builder setVocabSize(int value)
            {
                vocabSize_ = value;
                bitField0_ |= 0x00000010;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Vocabulary size. 8k is the default size.
             * </pre>
             *
             * <code>optional int32 vocab_size = 4 [default = 8000];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearVocabSize()
            {
                bitField0_ = (bitField0_ & ~0x00000010);
                vocabSize_ = 8000;
                onChanged();
                return this;
            }

            private LazyStringArrayList acceptLanguage_ = LazyStringArrayList.emptyList();

            private void ensureAcceptLanguageIsMutable()
            {
                if (!acceptLanguage_.isModifiable())
                {
                    acceptLanguage_ = new LazyStringArrayList(acceptLanguage_);
                }
                bitField0_ |= 0x00000020;
            }

            /**
             * <pre>
             * List of the languages this model can accept.
             * Since the model is language-agnostic, this field is used as a reference.
             * </pre>
             *
             * <code>repeated string accept_language = 5;</code>
             *
             * @return A list containing the acceptLanguage.
             */
            public ProtocolStringList getAcceptLanguageList()
            {
                acceptLanguage_.makeImmutable();
                return acceptLanguage_;
            }

            /**
             * <pre>
             * List of the languages this model can accept.
             * Since the model is language-agnostic, this field is used as a reference.
             * </pre>
             *
             * <code>repeated string accept_language = 5;</code>
             *
             * @return The count of acceptLanguage.
             */
            public int getAcceptLanguageCount()
            {
                return acceptLanguage_.size();
            }

            /**
             * <pre>
             * List of the languages this model can accept.
             * Since the model is language-agnostic, this field is used as a reference.
             * </pre>
             *
             * <code>repeated string accept_language = 5;</code>
             *
             * @param index The index of the element to return.
             * @return The acceptLanguage at the given index.
             */
            public String getAcceptLanguage(int index)
            {
                return acceptLanguage_.get(index);
            }

            /**
             * <pre>
             * List of the languages this model can accept.
             * Since the model is language-agnostic, this field is used as a reference.
             * </pre>
             *
             * <code>repeated string accept_language = 5;</code>
             *
             * @param index The index of the value to return.
             * @return The bytes of the acceptLanguage at the given index.
             */
            public ByteString getAcceptLanguageBytes(int index)
            {
                return acceptLanguage_.getByteString(index);
            }

            /**
             * <pre>
             * List of the languages this model can accept.
             * Since the model is language-agnostic, this field is used as a reference.
             * </pre>
             *
             * <code>repeated string accept_language = 5;</code>
             *
             * @param index The index to set the value at.
             * @param value The acceptLanguage to set.
             * @return This builder for chaining.
             */
            public Builder setAcceptLanguage(int index, String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                ensureAcceptLanguageIsMutable();
                acceptLanguage_.set(index, value);
                bitField0_ |= 0x00000020;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * List of the languages this model can accept.
             * Since the model is language-agnostic, this field is used as a reference.
             * </pre>
             *
             * <code>repeated string accept_language = 5;</code>
             *
             * @param value The acceptLanguage to add.
             * @return This builder for chaining.
             */
            public Builder addAcceptLanguage(String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                ensureAcceptLanguageIsMutable();
                acceptLanguage_.add(value);
                bitField0_ |= 0x00000020;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * List of the languages this model can accept.
             * Since the model is language-agnostic, this field is used as a reference.
             * </pre>
             *
             * <code>repeated string accept_language = 5;</code>
             *
             * @param values The acceptLanguage to add.
             * @return This builder for chaining.
             */
            public Builder addAllAcceptLanguage(Iterable<String> values)
            {
                ensureAcceptLanguageIsMutable();
                AbstractMessageLite.Builder.addAll(values, acceptLanguage_);
                bitField0_ |= 0x00000020;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * List of the languages this model can accept.
             * Since the model is language-agnostic, this field is used as a reference.
             * </pre>
             *
             * <code>repeated string accept_language = 5;</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearAcceptLanguage()
            {
                acceptLanguage_ = LazyStringArrayList.emptyList();
                bitField0_ = (bitField0_ & ~0x00000020);
                onChanged();
                return this;
            }

            /**
             * <pre>
             * List of the languages this model can accept.
             * Since the model is language-agnostic, this field is used as a reference.
             * </pre>
             *
             * <code>repeated string accept_language = 5;</code>
             *
             * @param value The bytes of the acceptLanguage to add.
             * @return This builder for chaining.
             */
            public Builder addAcceptLanguageBytes(ByteString value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                ensureAcceptLanguageIsMutable();
                acceptLanguage_.add(value);
                bitField0_ |= 0x00000020;
                onChanged();
                return this;
            }

            private int selfTestSampleSize_;

            /**
             * <pre>
             * Size of self-test samples, which are encoded in the model file.
             * </pre>
             *
             * <code>optional int32 self_test_sample_size = 6 [default = 0];</code>
             *
             * @return Whether the selfTestSampleSize field is set.
             */
            @Override
            public boolean hasSelfTestSampleSize()
            {
                return ((bitField0_ & 0x00000040) != 0);
            }

            /**
             * <pre>
             * Size of self-test samples, which are encoded in the model file.
             * </pre>
             *
             * <code>optional int32 self_test_sample_size = 6 [default = 0];</code>
             *
             * @return The selfTestSampleSize.
             */
            @Override
            public int getSelfTestSampleSize()
            {
                return selfTestSampleSize_;
            }

            /**
             * <pre>
             * Size of self-test samples, which are encoded in the model file.
             * </pre>
             *
             * <code>optional int32 self_test_sample_size = 6 [default = 0];</code>
             *
             * @param value The selfTestSampleSize to set.
             * @return This builder for chaining.
             */
            public Builder setSelfTestSampleSize(int value)
            {
                selfTestSampleSize_ = value;
                bitField0_ |= 0x00000040;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Size of self-test samples, which are encoded in the model file.
             * </pre>
             *
             * <code>optional int32 self_test_sample_size = 6 [default = 0];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearSelfTestSampleSize()
            {
                bitField0_ = (bitField0_ & ~0x00000040);
                selfTestSampleSize_ = 0;
                onChanged();
                return this;
            }

            private boolean enableDifferentialPrivacy_;

            /**
             * <pre>
             * Whether to use DP version of sentencepiece. Use it with TSV input format
             * (requires precomputed word tab counts to work).
             * </pre>
             *
             * <code>optional bool enable_differential_privacy = 50 [default = false];</code>
             *
             * @return Whether the enableDifferentialPrivacy field is set.
             */
            @Override
            public boolean hasEnableDifferentialPrivacy()
            {
                return ((bitField0_ & 0x00000080) != 0);
            }

            /**
             * <pre>
             * Whether to use DP version of sentencepiece. Use it with TSV input format
             * (requires precomputed word tab counts to work).
             * </pre>
             *
             * <code>optional bool enable_differential_privacy = 50 [default = false];</code>
             *
             * @return The enableDifferentialPrivacy.
             */
            @Override
            public boolean getEnableDifferentialPrivacy()
            {
                return enableDifferentialPrivacy_;
            }

            /**
             * <pre>
             * Whether to use DP version of sentencepiece. Use it with TSV input format
             * (requires precomputed word tab counts to work).
             * </pre>
             *
             * <code>optional bool enable_differential_privacy = 50 [default = false];</code>
             *
             * @param value The enableDifferentialPrivacy to set.
             * @return This builder for chaining.
             */
            public Builder setEnableDifferentialPrivacy(boolean value)
            {
                enableDifferentialPrivacy_ = value;
                bitField0_ |= 0x00000080;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Whether to use DP version of sentencepiece. Use it with TSV input format
             * (requires precomputed word tab counts to work).
             * </pre>
             *
             * <code>optional bool enable_differential_privacy = 50 [default = false];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearEnableDifferentialPrivacy()
            {
                bitField0_ = (bitField0_ & ~0x00000080);
                enableDifferentialPrivacy_ = false;
                onChanged();
                return this;
            }

            private float differentialPrivacyNoiseLevel_;

            /**
             * <pre>
             * Set these parameters if you need DP version of sentencepiece.
             * std of noise to add.
             * </pre>
             *
             * <code>optional float differential_privacy_noise_level = 51 [default = 0];</code>
             *
             * @return Whether the differentialPrivacyNoiseLevel field is set.
             */
            @Override
            public boolean hasDifferentialPrivacyNoiseLevel()
            {
                return ((bitField0_ & 0x00000100) != 0);
            }

            /**
             * <pre>
             * Set these parameters if you need DP version of sentencepiece.
             * std of noise to add.
             * </pre>
             *
             * <code>optional float differential_privacy_noise_level = 51 [default = 0];</code>
             *
             * @return The differentialPrivacyNoiseLevel.
             */
            @Override
            public float getDifferentialPrivacyNoiseLevel()
            {
                return differentialPrivacyNoiseLevel_;
            }

            /**
             * <pre>
             * Set these parameters if you need DP version of sentencepiece.
             * std of noise to add.
             * </pre>
             *
             * <code>optional float differential_privacy_noise_level = 51 [default = 0];</code>
             *
             * @param value The differentialPrivacyNoiseLevel to set.
             * @return This builder for chaining.
             */
            public Builder setDifferentialPrivacyNoiseLevel(float value)
            {
                differentialPrivacyNoiseLevel_ = value;
                bitField0_ |= 0x00000100;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Set these parameters if you need DP version of sentencepiece.
             * std of noise to add.
             * </pre>
             *
             * <code>optional float differential_privacy_noise_level = 51 [default = 0];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearDifferentialPrivacyNoiseLevel()
            {
                bitField0_ = (bitField0_ & ~0x00000100);
                differentialPrivacyNoiseLevel_ = 0F;
                onChanged();
                return this;
            }

            private long differentialPrivacyClippingThreshold_;

            /**
             * <pre>
             * Clipping threshold to apply after adding noise. All the words with
             * frequency less than this value are dropped.
             * </pre>
             *
             * <code>optional uint64 differential_privacy_clipping_threshold = 52 [default = 0];</code>
             *
             * @return Whether the differentialPrivacyClippingThreshold field is set.
             */
            @Override
            public boolean hasDifferentialPrivacyClippingThreshold()
            {
                return ((bitField0_ & 0x00000200) != 0);
            }

            /**
             * <pre>
             * Clipping threshold to apply after adding noise. All the words with
             * frequency less than this value are dropped.
             * </pre>
             *
             * <code>optional uint64 differential_privacy_clipping_threshold = 52 [default = 0];</code>
             *
             * @return The differentialPrivacyClippingThreshold.
             */
            @Override
            public long getDifferentialPrivacyClippingThreshold()
            {
                return differentialPrivacyClippingThreshold_;
            }

            /**
             * <pre>
             * Clipping threshold to apply after adding noise. All the words with
             * frequency less than this value are dropped.
             * </pre>
             *
             * <code>optional uint64 differential_privacy_clipping_threshold = 52 [default = 0];</code>
             *
             * @param value The differentialPrivacyClippingThreshold to set.
             * @return This builder for chaining.
             */
            public Builder setDifferentialPrivacyClippingThreshold(long value)
            {
                differentialPrivacyClippingThreshold_ = value;
                bitField0_ |= 0x00000200;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Clipping threshold to apply after adding noise. All the words with
             * frequency less than this value are dropped.
             * </pre>
             *
             * <code>optional uint64 differential_privacy_clipping_threshold = 52 [default = 0];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearDifferentialPrivacyClippingThreshold()
            {
                bitField0_ = (bitField0_ & ~0x00000200);
                differentialPrivacyClippingThreshold_ = 0L;
                onChanged();
                return this;
            }

            private float characterCoverage_ = 0.9995F;

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * Training parameters.
             *
             * Uses characters which cover the corpus with the ratio of `chars_coverage`.
             * This parameter determines the set of basic Alphabet of sentence piece.
             * 1.0 - `chars_coverage` characters are treated as UNK.
             * See also required_chars field.
             * </pre>
             *
             * <code>optional float character_coverage = 10 [default = 0.9995];</code>
             *
             * @return Whether the characterCoverage field is set.
             */
            @Override
            public boolean hasCharacterCoverage()
            {
                return ((bitField0_ & 0x00000400) != 0);
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * Training parameters.
             *
             * Uses characters which cover the corpus with the ratio of `chars_coverage`.
             * This parameter determines the set of basic Alphabet of sentence piece.
             * 1.0 - `chars_coverage` characters are treated as UNK.
             * See also required_chars field.
             * </pre>
             *
             * <code>optional float character_coverage = 10 [default = 0.9995];</code>
             *
             * @return The characterCoverage.
             */
            @Override
            public float getCharacterCoverage()
            {
                return characterCoverage_;
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * Training parameters.
             *
             * Uses characters which cover the corpus with the ratio of `chars_coverage`.
             * This parameter determines the set of basic Alphabet of sentence piece.
             * 1.0 - `chars_coverage` characters are treated as UNK.
             * See also required_chars field.
             * </pre>
             *
             * <code>optional float character_coverage = 10 [default = 0.9995];</code>
             *
             * @param value The characterCoverage to set.
             * @return This builder for chaining.
             */
            public Builder setCharacterCoverage(float value)
            {
                characterCoverage_ = value;
                bitField0_ |= 0x00000400;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * Training parameters.
             *
             * Uses characters which cover the corpus with the ratio of `chars_coverage`.
             * This parameter determines the set of basic Alphabet of sentence piece.
             * 1.0 - `chars_coverage` characters are treated as UNK.
             * See also required_chars field.
             * </pre>
             *
             * <code>optional float character_coverage = 10 [default = 0.9995];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearCharacterCoverage()
            {
                bitField0_ = (bitField0_ & ~0x00000400);
                characterCoverage_ = 0.9995F;
                onChanged();
                return this;
            }

            private long inputSentenceSize_;

            /**
             * <pre>
             * Maximum size of sentences the trainer loads from `input` parameter.
             * Trainer simply loads the `input` files in sequence.
             * It is better to shuffle the input corpus randomly.
             * </pre>
             *
             * <code>optional uint64 input_sentence_size = 11 [default = 0];</code>
             *
             * @return Whether the inputSentenceSize field is set.
             */
            @Override
            public boolean hasInputSentenceSize()
            {
                return ((bitField0_ & 0x00000800) != 0);
            }

            /**
             * <pre>
             * Maximum size of sentences the trainer loads from `input` parameter.
             * Trainer simply loads the `input` files in sequence.
             * It is better to shuffle the input corpus randomly.
             * </pre>
             *
             * <code>optional uint64 input_sentence_size = 11 [default = 0];</code>
             *
             * @return The inputSentenceSize.
             */
            @Override
            public long getInputSentenceSize()
            {
                return inputSentenceSize_;
            }

            /**
             * <pre>
             * Maximum size of sentences the trainer loads from `input` parameter.
             * Trainer simply loads the `input` files in sequence.
             * It is better to shuffle the input corpus randomly.
             * </pre>
             *
             * <code>optional uint64 input_sentence_size = 11 [default = 0];</code>
             *
             * @param value The inputSentenceSize to set.
             * @return This builder for chaining.
             */
            public Builder setInputSentenceSize(long value)
            {
                inputSentenceSize_ = value;
                bitField0_ |= 0x00000800;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Maximum size of sentences the trainer loads from `input` parameter.
             * Trainer simply loads the `input` files in sequence.
             * It is better to shuffle the input corpus randomly.
             * </pre>
             *
             * <code>optional uint64 input_sentence_size = 11 [default = 0];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearInputSentenceSize()
            {
                bitField0_ = (bitField0_ & ~0x00000800);
                inputSentenceSize_ = 0L;
                onChanged();
                return this;
            }

            private boolean shuffleInputSentence_ = true;

            /**
             * <code>optional bool shuffle_input_sentence = 19 [default = true];</code>
             *
             * @return Whether the shuffleInputSentence field is set.
             */
            @Override
            public boolean hasShuffleInputSentence()
            {
                return ((bitField0_ & 0x00001000) != 0);
            }

            /**
             * <code>optional bool shuffle_input_sentence = 19 [default = true];</code>
             *
             * @return The shuffleInputSentence.
             */
            @Override
            public boolean getShuffleInputSentence()
            {
                return shuffleInputSentence_;
            }

            /**
             * <code>optional bool shuffle_input_sentence = 19 [default = true];</code>
             *
             * @param value The shuffleInputSentence to set.
             * @return This builder for chaining.
             */
            public Builder setShuffleInputSentence(boolean value)
            {
                shuffleInputSentence_ = value;
                bitField0_ |= 0x00001000;
                onChanged();
                return this;
            }

            /**
             * <code>optional bool shuffle_input_sentence = 19 [default = true];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearShuffleInputSentence()
            {
                bitField0_ = (bitField0_ & ~0x00001000);
                shuffleInputSentence_ = true;
                onChanged();
                return this;
            }

            private int miningSentenceSize_;

            /**
             * <pre>
             * Maximum size of sentences to make seed sentence pieces.
             * Extended suffix array is constructed to extract frequent
             * sub-strings from the corpus. This uses 20N working space,
             * where N is the size of corpus.
             * </pre>
             *
             * <code>optional int32 mining_sentence_size = 12 [deprecated = true];</code>
             *
             * @return Whether the miningSentenceSize field is set.
             * @deprecated sentencepiece.TrainerSpec.mining_sentence_size is deprecated.
             * See sentencepiece_model.proto;l=94
             */
            @Override
            @Deprecated
            public boolean hasMiningSentenceSize()
            {
                return ((bitField0_ & 0x00002000) != 0);
            }

            /**
             * <pre>
             * Maximum size of sentences to make seed sentence pieces.
             * Extended suffix array is constructed to extract frequent
             * sub-strings from the corpus. This uses 20N working space,
             * where N is the size of corpus.
             * </pre>
             *
             * <code>optional int32 mining_sentence_size = 12 [deprecated = true];</code>
             *
             * @return The miningSentenceSize.
             * @deprecated sentencepiece.TrainerSpec.mining_sentence_size is deprecated.
             * See sentencepiece_model.proto;l=94
             */
            @Override
            @Deprecated
            public int getMiningSentenceSize()
            {
                return miningSentenceSize_;
            }

            /**
             * <pre>
             * Maximum size of sentences to make seed sentence pieces.
             * Extended suffix array is constructed to extract frequent
             * sub-strings from the corpus. This uses 20N working space,
             * where N is the size of corpus.
             * </pre>
             *
             * <code>optional int32 mining_sentence_size = 12 [deprecated = true];</code>
             *
             * @param value The miningSentenceSize to set.
             * @return This builder for chaining.
             */
            @Deprecated
            public Builder setMiningSentenceSize(int value)
            {
                miningSentenceSize_ = value;
                bitField0_ |= 0x00002000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Maximum size of sentences to make seed sentence pieces.
             * Extended suffix array is constructed to extract frequent
             * sub-strings from the corpus. This uses 20N working space,
             * where N is the size of corpus.
             * </pre>
             *
             * <code>optional int32 mining_sentence_size = 12 [deprecated = true];</code>
             *
             * @return This builder for chaining.
             */
            @Deprecated
            public Builder clearMiningSentenceSize()
            {
                bitField0_ = (bitField0_ & ~0x00002000);
                miningSentenceSize_ = 0;
                onChanged();
                return this;
            }

            private int trainingSentenceSize_;

            /**
             * <pre>
             * Maximum size of sentences to train sentence pieces.
             * </pre>
             *
             * <code>optional int32 training_sentence_size = 13 [deprecated = true];</code>
             *
             * @return Whether the trainingSentenceSize field is set.
             * @deprecated sentencepiece.TrainerSpec.training_sentence_size is deprecated.
             * See sentencepiece_model.proto;l=97
             */
            @Override
            @Deprecated
            public boolean hasTrainingSentenceSize()
            {
                return ((bitField0_ & 0x00004000) != 0);
            }

            /**
             * <pre>
             * Maximum size of sentences to train sentence pieces.
             * </pre>
             *
             * <code>optional int32 training_sentence_size = 13 [deprecated = true];</code>
             *
             * @return The trainingSentenceSize.
             * @deprecated sentencepiece.TrainerSpec.training_sentence_size is deprecated.
             * See sentencepiece_model.proto;l=97
             */
            @Override
            @Deprecated
            public int getTrainingSentenceSize()
            {
                return trainingSentenceSize_;
            }

            /**
             * <pre>
             * Maximum size of sentences to train sentence pieces.
             * </pre>
             *
             * <code>optional int32 training_sentence_size = 13 [deprecated = true];</code>
             *
             * @param value The trainingSentenceSize to set.
             * @return This builder for chaining.
             */
            @Deprecated
            public Builder setTrainingSentenceSize(int value)
            {
                trainingSentenceSize_ = value;
                bitField0_ |= 0x00004000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Maximum size of sentences to train sentence pieces.
             * </pre>
             *
             * <code>optional int32 training_sentence_size = 13 [deprecated = true];</code>
             *
             * @return This builder for chaining.
             */
            @Deprecated
            public Builder clearTrainingSentenceSize()
            {
                bitField0_ = (bitField0_ & ~0x00004000);
                trainingSentenceSize_ = 0;
                onChanged();
                return this;
            }

            private int seedSentencepieceSize_ = 1000000;

            /**
             * <pre>
             * The size of seed sentencepieces.
             * `seed_sentencepiece_size` must be larger than `vocab_size`.
             * </pre>
             *
             * <code>optional int32 seed_sentencepiece_size = 14 [default = 1000000];</code>
             *
             * @return Whether the seedSentencepieceSize field is set.
             */
            @Override
            public boolean hasSeedSentencepieceSize()
            {
                return ((bitField0_ & 0x00008000) != 0);
            }

            /**
             * <pre>
             * The size of seed sentencepieces.
             * `seed_sentencepiece_size` must be larger than `vocab_size`.
             * </pre>
             *
             * <code>optional int32 seed_sentencepiece_size = 14 [default = 1000000];</code>
             *
             * @return The seedSentencepieceSize.
             */
            @Override
            public int getSeedSentencepieceSize()
            {
                return seedSentencepieceSize_;
            }

            /**
             * <pre>
             * The size of seed sentencepieces.
             * `seed_sentencepiece_size` must be larger than `vocab_size`.
             * </pre>
             *
             * <code>optional int32 seed_sentencepiece_size = 14 [default = 1000000];</code>
             *
             * @param value The seedSentencepieceSize to set.
             * @return This builder for chaining.
             */
            public Builder setSeedSentencepieceSize(int value)
            {
                seedSentencepieceSize_ = value;
                bitField0_ |= 0x00008000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * The size of seed sentencepieces.
             * `seed_sentencepiece_size` must be larger than `vocab_size`.
             * </pre>
             *
             * <code>optional int32 seed_sentencepiece_size = 14 [default = 1000000];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearSeedSentencepieceSize()
            {
                bitField0_ = (bitField0_ & ~0x00008000);
                seedSentencepieceSize_ = 1000000;
                onChanged();
                return this;
            }

            private float shrinkingFactor_ = 0.75F;

            /**
             * <pre>
             * In every EM sub-iterations, keeps top
             * `shrinking_factor` * `current sentencepieces size` with respect to
             * the loss of the sentence piece. This value should be smaller than 1.0.
             * </pre>
             *
             * <code>optional float shrinking_factor = 15 [default = 0.75];</code>
             *
             * @return Whether the shrinkingFactor field is set.
             */
            @Override
            public boolean hasShrinkingFactor()
            {
                return ((bitField0_ & 0x00010000) != 0);
            }

            /**
             * <pre>
             * In every EM sub-iterations, keeps top
             * `shrinking_factor` * `current sentencepieces size` with respect to
             * the loss of the sentence piece. This value should be smaller than 1.0.
             * </pre>
             *
             * <code>optional float shrinking_factor = 15 [default = 0.75];</code>
             *
             * @return The shrinkingFactor.
             */
            @Override
            public float getShrinkingFactor()
            {
                return shrinkingFactor_;
            }

            /**
             * <pre>
             * In every EM sub-iterations, keeps top
             * `shrinking_factor` * `current sentencepieces size` with respect to
             * the loss of the sentence piece. This value should be smaller than 1.0.
             * </pre>
             *
             * <code>optional float shrinking_factor = 15 [default = 0.75];</code>
             *
             * @param value The shrinkingFactor to set.
             * @return This builder for chaining.
             */
            public Builder setShrinkingFactor(float value)
            {
                shrinkingFactor_ = value;
                bitField0_ |= 0x00010000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * In every EM sub-iterations, keeps top
             * `shrinking_factor` * `current sentencepieces size` with respect to
             * the loss of the sentence piece. This value should be smaller than 1.0.
             * </pre>
             *
             * <code>optional float shrinking_factor = 15 [default = 0.75];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearShrinkingFactor()
            {
                bitField0_ = (bitField0_ & ~0x00010000);
                shrinkingFactor_ = 0.75F;
                onChanged();
                return this;
            }

            private int maxSentenceLength_ = 4192;

            /**
             * <pre>
             * The maximum sentence length in byte. The sentences with the length
             * larger than `max_sentence_length` is simply ignored.
             * Longer input tends to bring the following risks:
             * * Overflow during EM training (unigram language model only)
             * * Performance drop because of O(n log n) cost in BPE.
             * </pre>
             *
             * <code>optional int32 max_sentence_length = 18 [default = 4192];</code>
             *
             * @return Whether the maxSentenceLength field is set.
             */
            @Override
            public boolean hasMaxSentenceLength()
            {
                return ((bitField0_ & 0x00020000) != 0);
            }

            /**
             * <pre>
             * The maximum sentence length in byte. The sentences with the length
             * larger than `max_sentence_length` is simply ignored.
             * Longer input tends to bring the following risks:
             * * Overflow during EM training (unigram language model only)
             * * Performance drop because of O(n log n) cost in BPE.
             * </pre>
             *
             * <code>optional int32 max_sentence_length = 18 [default = 4192];</code>
             *
             * @return The maxSentenceLength.
             */
            @Override
            public int getMaxSentenceLength()
            {
                return maxSentenceLength_;
            }

            /**
             * <pre>
             * The maximum sentence length in byte. The sentences with the length
             * larger than `max_sentence_length` is simply ignored.
             * Longer input tends to bring the following risks:
             * * Overflow during EM training (unigram language model only)
             * * Performance drop because of O(n log n) cost in BPE.
             * </pre>
             *
             * <code>optional int32 max_sentence_length = 18 [default = 4192];</code>
             *
             * @param value The maxSentenceLength to set.
             * @return This builder for chaining.
             */
            public Builder setMaxSentenceLength(int value)
            {
                maxSentenceLength_ = value;
                bitField0_ |= 0x00020000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * The maximum sentence length in byte. The sentences with the length
             * larger than `max_sentence_length` is simply ignored.
             * Longer input tends to bring the following risks:
             * * Overflow during EM training (unigram language model only)
             * * Performance drop because of O(n log n) cost in BPE.
             * </pre>
             *
             * <code>optional int32 max_sentence_length = 18 [default = 4192];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearMaxSentenceLength()
            {
                bitField0_ = (bitField0_ & ~0x00020000);
                maxSentenceLength_ = 4192;
                onChanged();
                return this;
            }

            private int numThreads_ = 16;

            /**
             * <pre>
             * Number of threads in the training.
             * </pre>
             *
             * <code>optional int32 num_threads = 16 [default = 16];</code>
             *
             * @return Whether the numThreads field is set.
             */
            @Override
            public boolean hasNumThreads()
            {
                return ((bitField0_ & 0x00040000) != 0);
            }

            /**
             * <pre>
             * Number of threads in the training.
             * </pre>
             *
             * <code>optional int32 num_threads = 16 [default = 16];</code>
             *
             * @return The numThreads.
             */
            @Override
            public int getNumThreads()
            {
                return numThreads_;
            }

            /**
             * <pre>
             * Number of threads in the training.
             * </pre>
             *
             * <code>optional int32 num_threads = 16 [default = 16];</code>
             *
             * @param value The numThreads to set.
             * @return This builder for chaining.
             */
            public Builder setNumThreads(int value)
            {
                numThreads_ = value;
                bitField0_ |= 0x00040000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Number of threads in the training.
             * </pre>
             *
             * <code>optional int32 num_threads = 16 [default = 16];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearNumThreads()
            {
                bitField0_ = (bitField0_ & ~0x00040000);
                numThreads_ = 16;
                onChanged();
                return this;
            }

            private int numSubIterations_ = 2;

            /**
             * <pre>
             * Number of EM sub iterations.
             * </pre>
             *
             * <code>optional int32 num_sub_iterations = 17 [default = 2];</code>
             *
             * @return Whether the numSubIterations field is set.
             */
            @Override
            public boolean hasNumSubIterations()
            {
                return ((bitField0_ & 0x00080000) != 0);
            }

            /**
             * <pre>
             * Number of EM sub iterations.
             * </pre>
             *
             * <code>optional int32 num_sub_iterations = 17 [default = 2];</code>
             *
             * @return The numSubIterations.
             */
            @Override
            public int getNumSubIterations()
            {
                return numSubIterations_;
            }

            /**
             * <pre>
             * Number of EM sub iterations.
             * </pre>
             *
             * <code>optional int32 num_sub_iterations = 17 [default = 2];</code>
             *
             * @param value The numSubIterations to set.
             * @return This builder for chaining.
             */
            public Builder setNumSubIterations(int value)
            {
                numSubIterations_ = value;
                bitField0_ |= 0x00080000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Number of EM sub iterations.
             * </pre>
             *
             * <code>optional int32 num_sub_iterations = 17 [default = 2];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearNumSubIterations()
            {
                bitField0_ = (bitField0_ & ~0x00080000);
                numSubIterations_ = 2;
                onChanged();
                return this;
            }

            private int maxSentencepieceLength_ = 16;

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * SentencePiece parameters which control the shapes of sentence piece.
             *
             * Maximum length of sentencepiece.
             * </pre>
             *
             * <code>optional int32 max_sentencepiece_length = 20 [default = 16];</code>
             *
             * @return Whether the maxSentencepieceLength field is set.
             */
            @Override
            public boolean hasMaxSentencepieceLength()
            {
                return ((bitField0_ & 0x00100000) != 0);
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * SentencePiece parameters which control the shapes of sentence piece.
             *
             * Maximum length of sentencepiece.
             * </pre>
             *
             * <code>optional int32 max_sentencepiece_length = 20 [default = 16];</code>
             *
             * @return The maxSentencepieceLength.
             */
            @Override
            public int getMaxSentencepieceLength()
            {
                return maxSentencepieceLength_;
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * SentencePiece parameters which control the shapes of sentence piece.
             *
             * Maximum length of sentencepiece.
             * </pre>
             *
             * <code>optional int32 max_sentencepiece_length = 20 [default = 16];</code>
             *
             * @param value The maxSentencepieceLength to set.
             * @return This builder for chaining.
             */
            public Builder setMaxSentencepieceLength(int value)
            {
                maxSentencepieceLength_ = value;
                bitField0_ |= 0x00100000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * SentencePiece parameters which control the shapes of sentence piece.
             *
             * Maximum length of sentencepiece.
             * </pre>
             *
             * <code>optional int32 max_sentencepiece_length = 20 [default = 16];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearMaxSentencepieceLength()
            {
                bitField0_ = (bitField0_ & ~0x00100000);
                maxSentencepieceLength_ = 16;
                onChanged();
                return this;
            }

            private boolean splitByUnicodeScript_ = true;

            /**
             * <pre>
             * Uses Unicode script to split sentence pieces.
             * When `split_by_unicode_script` is true, we do not allow sentence piece to
             * include multiple Unicode scripts, e.g. "F1" is not a valid piece.
             * Exception: CJ characters (Hiragana/Katakana/Han) are all handled
             * as one script type, since Japanese word can consist of multiple scripts.
             * This exception is always applied regardless of the accept-language
             * parameter.
             * </pre>
             *
             * <code>optional bool split_by_unicode_script = 21 [default = true];</code>
             *
             * @return Whether the splitByUnicodeScript field is set.
             */
            @Override
            public boolean hasSplitByUnicodeScript()
            {
                return ((bitField0_ & 0x00200000) != 0);
            }

            /**
             * <pre>
             * Uses Unicode script to split sentence pieces.
             * When `split_by_unicode_script` is true, we do not allow sentence piece to
             * include multiple Unicode scripts, e.g. "F1" is not a valid piece.
             * Exception: CJ characters (Hiragana/Katakana/Han) are all handled
             * as one script type, since Japanese word can consist of multiple scripts.
             * This exception is always applied regardless of the accept-language
             * parameter.
             * </pre>
             *
             * <code>optional bool split_by_unicode_script = 21 [default = true];</code>
             *
             * @return The splitByUnicodeScript.
             */
            @Override
            public boolean getSplitByUnicodeScript()
            {
                return splitByUnicodeScript_;
            }

            /**
             * <pre>
             * Uses Unicode script to split sentence pieces.
             * When `split_by_unicode_script` is true, we do not allow sentence piece to
             * include multiple Unicode scripts, e.g. "F1" is not a valid piece.
             * Exception: CJ characters (Hiragana/Katakana/Han) are all handled
             * as one script type, since Japanese word can consist of multiple scripts.
             * This exception is always applied regardless of the accept-language
             * parameter.
             * </pre>
             *
             * <code>optional bool split_by_unicode_script = 21 [default = true];</code>
             *
             * @param value The splitByUnicodeScript to set.
             * @return This builder for chaining.
             */
            public Builder setSplitByUnicodeScript(boolean value)
            {
                splitByUnicodeScript_ = value;
                bitField0_ |= 0x00200000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Uses Unicode script to split sentence pieces.
             * When `split_by_unicode_script` is true, we do not allow sentence piece to
             * include multiple Unicode scripts, e.g. "F1" is not a valid piece.
             * Exception: CJ characters (Hiragana/Katakana/Han) are all handled
             * as one script type, since Japanese word can consist of multiple scripts.
             * This exception is always applied regardless of the accept-language
             * parameter.
             * </pre>
             *
             * <code>optional bool split_by_unicode_script = 21 [default = true];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearSplitByUnicodeScript()
            {
                bitField0_ = (bitField0_ & ~0x00200000);
                splitByUnicodeScript_ = true;
                onChanged();
                return this;
            }

            private boolean splitByNumber_ = true;

            /**
             * <pre>
             * When `split_by_number` is true, put a boundary between number and
             * non-number transition. If we want to treat "F1" is one token, set this flag
             * to be false.
             * </pre>
             *
             * <code>optional bool split_by_number = 23 [default = true];</code>
             *
             * @return Whether the splitByNumber field is set.
             */
            @Override
            public boolean hasSplitByNumber()
            {
                return ((bitField0_ & 0x00400000) != 0);
            }

            /**
             * <pre>
             * When `split_by_number` is true, put a boundary between number and
             * non-number transition. If we want to treat "F1" is one token, set this flag
             * to be false.
             * </pre>
             *
             * <code>optional bool split_by_number = 23 [default = true];</code>
             *
             * @return The splitByNumber.
             */
            @Override
            public boolean getSplitByNumber()
            {
                return splitByNumber_;
            }

            /**
             * <pre>
             * When `split_by_number` is true, put a boundary between number and
             * non-number transition. If we want to treat "F1" is one token, set this flag
             * to be false.
             * </pre>
             *
             * <code>optional bool split_by_number = 23 [default = true];</code>
             *
             * @param value The splitByNumber to set.
             * @return This builder for chaining.
             */
            public Builder setSplitByNumber(boolean value)
            {
                splitByNumber_ = value;
                bitField0_ |= 0x00400000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * When `split_by_number` is true, put a boundary between number and
             * non-number transition. If we want to treat "F1" is one token, set this flag
             * to be false.
             * </pre>
             *
             * <code>optional bool split_by_number = 23 [default = true];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearSplitByNumber()
            {
                bitField0_ = (bitField0_ & ~0x00400000);
                splitByNumber_ = true;
                onChanged();
                return this;
            }

            private boolean splitByWhitespace_ = true;

            /**
             * <pre>
             * Use a white space to split sentence pieces.
             * When `split_by_whitespace` is false, we may have the piece containing
             * a white space in the middle. e.g., "in_the".
             * </pre>
             *
             * <code>optional bool split_by_whitespace = 22 [default = true];</code>
             *
             * @return Whether the splitByWhitespace field is set.
             */
            @Override
            public boolean hasSplitByWhitespace()
            {
                return ((bitField0_ & 0x00800000) != 0);
            }

            /**
             * <pre>
             * Use a white space to split sentence pieces.
             * When `split_by_whitespace` is false, we may have the piece containing
             * a white space in the middle. e.g., "in_the".
             * </pre>
             *
             * <code>optional bool split_by_whitespace = 22 [default = true];</code>
             *
             * @return The splitByWhitespace.
             */
            @Override
            public boolean getSplitByWhitespace()
            {
                return splitByWhitespace_;
            }

            /**
             * <pre>
             * Use a white space to split sentence pieces.
             * When `split_by_whitespace` is false, we may have the piece containing
             * a white space in the middle. e.g., "in_the".
             * </pre>
             *
             * <code>optional bool split_by_whitespace = 22 [default = true];</code>
             *
             * @param value The splitByWhitespace to set.
             * @return This builder for chaining.
             */
            public Builder setSplitByWhitespace(boolean value)
            {
                splitByWhitespace_ = value;
                bitField0_ |= 0x00800000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Use a white space to split sentence pieces.
             * When `split_by_whitespace` is false, we may have the piece containing
             * a white space in the middle. e.g., "in_the".
             * </pre>
             *
             * <code>optional bool split_by_whitespace = 22 [default = true];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearSplitByWhitespace()
            {
                bitField0_ = (bitField0_ & ~0x00800000);
                splitByWhitespace_ = true;
                onChanged();
                return this;
            }

            private boolean treatWhitespaceAsSuffix_;

            /**
             * <pre>
             * Adds whitespace symbol (_) as a suffix instead of prefix. e.g., _hello =&gt;
             * hello_. When `treat_whitespace_as_suffix` is true,
             * NormalizerSpec::add_dummy_prefix will add the dummy whitespace to the end
             * of sentence.
             * </pre>
             *
             * <code>optional bool treat_whitespace_as_suffix = 24 [default = false];</code>
             *
             * @return Whether the treatWhitespaceAsSuffix field is set.
             */
            @Override
            public boolean hasTreatWhitespaceAsSuffix()
            {
                return ((bitField0_ & 0x01000000) != 0);
            }

            /**
             * <pre>
             * Adds whitespace symbol (_) as a suffix instead of prefix. e.g., _hello =&gt;
             * hello_. When `treat_whitespace_as_suffix` is true,
             * NormalizerSpec::add_dummy_prefix will add the dummy whitespace to the end
             * of sentence.
             * </pre>
             *
             * <code>optional bool treat_whitespace_as_suffix = 24 [default = false];</code>
             *
             * @return The treatWhitespaceAsSuffix.
             */
            @Override
            public boolean getTreatWhitespaceAsSuffix()
            {
                return treatWhitespaceAsSuffix_;
            }

            /**
             * <pre>
             * Adds whitespace symbol (_) as a suffix instead of prefix. e.g., _hello =&gt;
             * hello_. When `treat_whitespace_as_suffix` is true,
             * NormalizerSpec::add_dummy_prefix will add the dummy whitespace to the end
             * of sentence.
             * </pre>
             *
             * <code>optional bool treat_whitespace_as_suffix = 24 [default = false];</code>
             *
             * @param value The treatWhitespaceAsSuffix to set.
             * @return This builder for chaining.
             */
            public Builder setTreatWhitespaceAsSuffix(boolean value)
            {
                treatWhitespaceAsSuffix_ = value;
                bitField0_ |= 0x01000000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Adds whitespace symbol (_) as a suffix instead of prefix. e.g., _hello =&gt;
             * hello_. When `treat_whitespace_as_suffix` is true,
             * NormalizerSpec::add_dummy_prefix will add the dummy whitespace to the end
             * of sentence.
             * </pre>
             *
             * <code>optional bool treat_whitespace_as_suffix = 24 [default = false];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearTreatWhitespaceAsSuffix()
            {
                bitField0_ = (bitField0_ & ~0x01000000);
                treatWhitespaceAsSuffix_ = false;
                onChanged();
                return this;
            }

            private boolean allowWhitespaceOnlyPieces_;

            /**
             * <pre>
             * Allows pieces that only contain whitespaces instead of appearing only as
             * prefix or suffix of other pieces.
             * </pre>
             *
             * <code>optional bool allow_whitespace_only_pieces = 26 [default = false];</code>
             *
             * @return Whether the allowWhitespaceOnlyPieces field is set.
             */
            @Override
            public boolean hasAllowWhitespaceOnlyPieces()
            {
                return ((bitField0_ & 0x02000000) != 0);
            }

            /**
             * <pre>
             * Allows pieces that only contain whitespaces instead of appearing only as
             * prefix or suffix of other pieces.
             * </pre>
             *
             * <code>optional bool allow_whitespace_only_pieces = 26 [default = false];</code>
             *
             * @return The allowWhitespaceOnlyPieces.
             */
            @Override
            public boolean getAllowWhitespaceOnlyPieces()
            {
                return allowWhitespaceOnlyPieces_;
            }

            /**
             * <pre>
             * Allows pieces that only contain whitespaces instead of appearing only as
             * prefix or suffix of other pieces.
             * </pre>
             *
             * <code>optional bool allow_whitespace_only_pieces = 26 [default = false];</code>
             *
             * @param value The allowWhitespaceOnlyPieces to set.
             * @return This builder for chaining.
             */
            public Builder setAllowWhitespaceOnlyPieces(boolean value)
            {
                allowWhitespaceOnlyPieces_ = value;
                bitField0_ |= 0x02000000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Allows pieces that only contain whitespaces instead of appearing only as
             * prefix or suffix of other pieces.
             * </pre>
             *
             * <code>optional bool allow_whitespace_only_pieces = 26 [default = false];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearAllowWhitespaceOnlyPieces()
            {
                bitField0_ = (bitField0_ & ~0x02000000);
                allowWhitespaceOnlyPieces_ = false;
                onChanged();
                return this;
            }

            private boolean splitDigits_;

            /**
             * <pre>
             * Split all digits (0-9) into separate pieces.
             * </pre>
             *
             * <code>optional bool split_digits = 25 [default = false];</code>
             *
             * @return Whether the splitDigits field is set.
             */
            @Override
            public boolean hasSplitDigits()
            {
                return ((bitField0_ & 0x04000000) != 0);
            }

            /**
             * <pre>
             * Split all digits (0-9) into separate pieces.
             * </pre>
             *
             * <code>optional bool split_digits = 25 [default = false];</code>
             *
             * @return The splitDigits.
             */
            @Override
            public boolean getSplitDigits()
            {
                return splitDigits_;
            }

            /**
             * <pre>
             * Split all digits (0-9) into separate pieces.
             * </pre>
             *
             * <code>optional bool split_digits = 25 [default = false];</code>
             *
             * @param value The splitDigits to set.
             * @return This builder for chaining.
             */
            public Builder setSplitDigits(boolean value)
            {
                splitDigits_ = value;
                bitField0_ |= 0x04000000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Split all digits (0-9) into separate pieces.
             * </pre>
             *
             * <code>optional bool split_digits = 25 [default = false];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearSplitDigits()
            {
                bitField0_ = (bitField0_ & ~0x04000000);
                splitDigits_ = false;
                onChanged();
                return this;
            }

            private Object pretokenizationDelimiter_ = "";

            /**
             * <pre>
             * Defines the pre-tokenization delimiter.
             * When specified, no pieces crossing this delimiter is not included
             * in the vocab. Then the delimiter string is virtually ignored
             * during the training. This field can allows constraints on the vocabulary
             * selection. Note that this field is available on unigram mode.
             * </pre>
             *
             * <code>optional string pretokenization_delimiter = 53 [default = ""];</code>
             *
             * @return Whether the pretokenizationDelimiter field is set.
             */
            public boolean hasPretokenizationDelimiter()
            {
                return ((bitField0_ & 0x08000000) != 0);
            }

            /**
             * <pre>
             * Defines the pre-tokenization delimiter.
             * When specified, no pieces crossing this delimiter is not included
             * in the vocab. Then the delimiter string is virtually ignored
             * during the training. This field can allows constraints on the vocabulary
             * selection. Note that this field is available on unigram mode.
             * </pre>
             *
             * <code>optional string pretokenization_delimiter = 53 [default = ""];</code>
             *
             * @return The pretokenizationDelimiter.
             */
            public String getPretokenizationDelimiter()
            {
                Object ref = pretokenizationDelimiter_;
                if (!(ref instanceof String))
                {
                    ByteString bs =
                            (ByteString) ref;
                    String s = bs.toStringUtf8();
                    if (bs.isValidUtf8())
                    {
                        pretokenizationDelimiter_ = s;
                    }
                    return s;
                }
                else
                {
                    return (String) ref;
                }
            }

            /**
             * <pre>
             * Defines the pre-tokenization delimiter.
             * When specified, no pieces crossing this delimiter is not included
             * in the vocab. Then the delimiter string is virtually ignored
             * during the training. This field can allows constraints on the vocabulary
             * selection. Note that this field is available on unigram mode.
             * </pre>
             *
             * <code>optional string pretokenization_delimiter = 53 [default = ""];</code>
             *
             * @return The bytes for pretokenizationDelimiter.
             */
            public ByteString
            getPretokenizationDelimiterBytes()
            {
                Object ref = pretokenizationDelimiter_;
                if (ref instanceof String)
                {
                    ByteString b =
                            ByteString.copyFromUtf8(
                                    (String) ref);
                    pretokenizationDelimiter_ = b;
                    return b;
                }
                else
                {
                    return (ByteString) ref;
                }
            }

            /**
             * <pre>
             * Defines the pre-tokenization delimiter.
             * When specified, no pieces crossing this delimiter is not included
             * in the vocab. Then the delimiter string is virtually ignored
             * during the training. This field can allows constraints on the vocabulary
             * selection. Note that this field is available on unigram mode.
             * </pre>
             *
             * <code>optional string pretokenization_delimiter = 53 [default = ""];</code>
             *
             * @param value The pretokenizationDelimiter to set.
             * @return This builder for chaining.
             */
            public Builder setPretokenizationDelimiter(
                    String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                pretokenizationDelimiter_ = value;
                bitField0_ |= 0x08000000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Defines the pre-tokenization delimiter.
             * When specified, no pieces crossing this delimiter is not included
             * in the vocab. Then the delimiter string is virtually ignored
             * during the training. This field can allows constraints on the vocabulary
             * selection. Note that this field is available on unigram mode.
             * </pre>
             *
             * <code>optional string pretokenization_delimiter = 53 [default = ""];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearPretokenizationDelimiter()
            {
                pretokenizationDelimiter_ = getDefaultInstance().getPretokenizationDelimiter();
                bitField0_ = (bitField0_ & ~0x08000000);
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Defines the pre-tokenization delimiter.
             * When specified, no pieces crossing this delimiter is not included
             * in the vocab. Then the delimiter string is virtually ignored
             * during the training. This field can allows constraints on the vocabulary
             * selection. Note that this field is available on unigram mode.
             * </pre>
             *
             * <code>optional string pretokenization_delimiter = 53 [default = ""];</code>
             *
             * @param value The bytes for pretokenizationDelimiter to set.
             * @return This builder for chaining.
             */
            public Builder setPretokenizationDelimiterBytes(ByteString value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                pretokenizationDelimiter_ = value;
                bitField0_ |= 0x08000000;
                onChanged();
                return this;
            }

            private LazyStringArrayList controlSymbols_ = LazyStringArrayList.emptyList();

            private void ensureControlSymbolsIsMutable()
            {
                if (!controlSymbols_.isModifiable())
                {
                    controlSymbols_ = new LazyStringArrayList(controlSymbols_);
                }
                bitField0_ |= 0x10000000;
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * Vocabulary management
             *
             * Defines control symbols used as an indicator to
             * change the behavior of the decoder. &lt;s&gt; and &lt;/s&gt; are pre-defined.
             * We can use this field to encode various meta information,
             * including language indicator in multilingual model.
             * These symbols are not visible to users, but visible to
             * the decoder. Note that when the input sentence contains control symbols,
             * they are not treated as one token, but segmented into normal pieces.
             * Control symbols must be inserted independently from the segmentation.
             * </pre>
             *
             * <code>repeated string control_symbols = 30;</code>
             *
             * @return A list containing the controlSymbols.
             */
            public ProtocolStringList
            getControlSymbolsList()
            {
                controlSymbols_.makeImmutable();
                return controlSymbols_;
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * Vocabulary management
             *
             * Defines control symbols used as an indicator to
             * change the behavior of the decoder. &lt;s&gt; and &lt;/s&gt; are pre-defined.
             * We can use this field to encode various meta information,
             * including language indicator in multilingual model.
             * These symbols are not visible to users, but visible to
             * the decoder. Note that when the input sentence contains control symbols,
             * they are not treated as one token, but segmented into normal pieces.
             * Control symbols must be inserted independently from the segmentation.
             * </pre>
             *
             * <code>repeated string control_symbols = 30;</code>
             *
             * @return The count of controlSymbols.
             */
            public int getControlSymbolsCount()
            {
                return controlSymbols_.size();
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * Vocabulary management
             *
             * Defines control symbols used as an indicator to
             * change the behavior of the decoder. &lt;s&gt; and &lt;/s&gt; are pre-defined.
             * We can use this field to encode various meta information,
             * including language indicator in multilingual model.
             * These symbols are not visible to users, but visible to
             * the decoder. Note that when the input sentence contains control symbols,
             * they are not treated as one token, but segmented into normal pieces.
             * Control symbols must be inserted independently from the segmentation.
             * </pre>
             *
             * <code>repeated string control_symbols = 30;</code>
             *
             * @param index The index of the element to return.
             * @return The controlSymbols at the given index.
             */
            public String getControlSymbols(int index)
            {
                return controlSymbols_.get(index);
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * Vocabulary management
             *
             * Defines control symbols used as an indicator to
             * change the behavior of the decoder. &lt;s&gt; and &lt;/s&gt; are pre-defined.
             * We can use this field to encode various meta information,
             * including language indicator in multilingual model.
             * These symbols are not visible to users, but visible to
             * the decoder. Note that when the input sentence contains control symbols,
             * they are not treated as one token, but segmented into normal pieces.
             * Control symbols must be inserted independently from the segmentation.
             * </pre>
             *
             * <code>repeated string control_symbols = 30;</code>
             *
             * @param index The index of the value to return.
             * @return The bytes of the controlSymbols at the given index.
             */
            public ByteString
            getControlSymbolsBytes(int index)
            {
                return controlSymbols_.getByteString(index);
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * Vocabulary management
             *
             * Defines control symbols used as an indicator to
             * change the behavior of the decoder. &lt;s&gt; and &lt;/s&gt; are pre-defined.
             * We can use this field to encode various meta information,
             * including language indicator in multilingual model.
             * These symbols are not visible to users, but visible to
             * the decoder. Note that when the input sentence contains control symbols,
             * they are not treated as one token, but segmented into normal pieces.
             * Control symbols must be inserted independently from the segmentation.
             * </pre>
             *
             * <code>repeated string control_symbols = 30;</code>
             *
             * @param index The index to set the value at.
             * @param value The controlSymbols to set.
             * @return This builder for chaining.
             */
            public Builder setControlSymbols(int index, String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                ensureControlSymbolsIsMutable();
                controlSymbols_.set(index, value);
                bitField0_ |= 0x10000000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * Vocabulary management
             *
             * Defines control symbols used as an indicator to
             * change the behavior of the decoder. &lt;s&gt; and &lt;/s&gt; are pre-defined.
             * We can use this field to encode various meta information,
             * including language indicator in multilingual model.
             * These symbols are not visible to users, but visible to
             * the decoder. Note that when the input sentence contains control symbols,
             * they are not treated as one token, but segmented into normal pieces.
             * Control symbols must be inserted independently from the segmentation.
             * </pre>
             *
             * <code>repeated string control_symbols = 30;</code>
             *
             * @param value The controlSymbols to add.
             * @return This builder for chaining.
             */
            public Builder addControlSymbols(String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                ensureControlSymbolsIsMutable();
                controlSymbols_.add(value);
                bitField0_ |= 0x10000000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * Vocabulary management
             *
             * Defines control symbols used as an indicator to
             * change the behavior of the decoder. &lt;s&gt; and &lt;/s&gt; are pre-defined.
             * We can use this field to encode various meta information,
             * including language indicator in multilingual model.
             * These symbols are not visible to users, but visible to
             * the decoder. Note that when the input sentence contains control symbols,
             * they are not treated as one token, but segmented into normal pieces.
             * Control symbols must be inserted independently from the segmentation.
             * </pre>
             *
             * <code>repeated string control_symbols = 30;</code>
             *
             * @param values The controlSymbols to add.
             * @return This builder for chaining.
             */
            public Builder addAllControlSymbols(Iterable<String> values)
            {
                ensureControlSymbolsIsMutable();
                AbstractMessageLite.Builder.addAll(values, controlSymbols_);
                bitField0_ |= 0x10000000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * Vocabulary management
             *
             * Defines control symbols used as an indicator to
             * change the behavior of the decoder. &lt;s&gt; and &lt;/s&gt; are pre-defined.
             * We can use this field to encode various meta information,
             * including language indicator in multilingual model.
             * These symbols are not visible to users, but visible to
             * the decoder. Note that when the input sentence contains control symbols,
             * they are not treated as one token, but segmented into normal pieces.
             * Control symbols must be inserted independently from the segmentation.
             * </pre>
             *
             * <code>repeated string control_symbols = 30;</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearControlSymbols()
            {
                controlSymbols_ = LazyStringArrayList.emptyList();
                bitField0_ = (bitField0_ & ~0x10000000);
                onChanged();
                return this;
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * Vocabulary management
             *
             * Defines control symbols used as an indicator to
             * change the behavior of the decoder. &lt;s&gt; and &lt;/s&gt; are pre-defined.
             * We can use this field to encode various meta information,
             * including language indicator in multilingual model.
             * These symbols are not visible to users, but visible to
             * the decoder. Note that when the input sentence contains control symbols,
             * they are not treated as one token, but segmented into normal pieces.
             * Control symbols must be inserted independently from the segmentation.
             * </pre>
             *
             * <code>repeated string control_symbols = 30;</code>
             *
             * @param value The bytes of the controlSymbols to add.
             * @return This builder for chaining.
             */
            public Builder addControlSymbolsBytes(ByteString value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                ensureControlSymbolsIsMutable();
                controlSymbols_.add(value);
                bitField0_ |= 0x10000000;
                onChanged();
                return this;
            }

            private LazyStringArrayList userDefinedSymbols_ = LazyStringArrayList.emptyList();

            private void ensureUserDefinedSymbolsIsMutable()
            {
                if (!userDefinedSymbols_.isModifiable())
                {
                    userDefinedSymbols_ = new LazyStringArrayList(userDefinedSymbols_);
                }
                bitField0_ |= 0x20000000;
            }

            /**
             * <pre>
             * Defines user defined symbols.
             * These symbols are added with extremely high score
             * so they are always treated as one unique symbol in any context.
             * Typical usage of user_defined_symbols is placeholder for named entities.
             * </pre>
             *
             * <code>repeated string user_defined_symbols = 31;</code>
             *
             * @return A list containing the userDefinedSymbols.
             */
            public ProtocolStringList getUserDefinedSymbolsList()
            {
                userDefinedSymbols_.makeImmutable();
                return userDefinedSymbols_;
            }

            /**
             * <pre>
             * Defines user defined symbols.
             * These symbols are added with extremely high score
             * so they are always treated as one unique symbol in any context.
             * Typical usage of user_defined_symbols is placeholder for named entities.
             * </pre>
             *
             * <code>repeated string user_defined_symbols = 31;</code>
             *
             * @return The count of userDefinedSymbols.
             */
            public int getUserDefinedSymbolsCount()
            {
                return userDefinedSymbols_.size();
            }

            /**
             * <pre>
             * Defines user defined symbols.
             * These symbols are added with extremely high score
             * so they are always treated as one unique symbol in any context.
             * Typical usage of user_defined_symbols is placeholder for named entities.
             * </pre>
             *
             * <code>repeated string user_defined_symbols = 31;</code>
             *
             * @param index The index of the element to return.
             * @return The userDefinedSymbols at the given index.
             */
            public String getUserDefinedSymbols(int index)
            {
                return userDefinedSymbols_.get(index);
            }

            /**
             * <pre>
             * Defines user defined symbols.
             * These symbols are added with extremely high score
             * so they are always treated as one unique symbol in any context.
             * Typical usage of user_defined_symbols is placeholder for named entities.
             * </pre>
             *
             * <code>repeated string user_defined_symbols = 31;</code>
             *
             * @param index The index of the value to return.
             * @return The bytes of the userDefinedSymbols at the given index.
             */
            public ByteString getUserDefinedSymbolsBytes(int index)
            {
                return userDefinedSymbols_.getByteString(index);
            }

            /**
             * <pre>
             * Defines user defined symbols.
             * These symbols are added with extremely high score
             * so they are always treated as one unique symbol in any context.
             * Typical usage of user_defined_symbols is placeholder for named entities.
             * </pre>
             *
             * <code>repeated string user_defined_symbols = 31;</code>
             *
             * @param index The index to set the value at.
             * @param value The userDefinedSymbols to set.
             * @return This builder for chaining.
             */
            public Builder setUserDefinedSymbols(int index, String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                ensureUserDefinedSymbolsIsMutable();
                userDefinedSymbols_.set(index, value);
                bitField0_ |= 0x20000000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Defines user defined symbols.
             * These symbols are added with extremely high score
             * so they are always treated as one unique symbol in any context.
             * Typical usage of user_defined_symbols is placeholder for named entities.
             * </pre>
             *
             * <code>repeated string user_defined_symbols = 31;</code>
             *
             * @param value The userDefinedSymbols to add.
             * @return This builder for chaining.
             */
            public Builder addUserDefinedSymbols(String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                ensureUserDefinedSymbolsIsMutable();
                userDefinedSymbols_.add(value);
                bitField0_ |= 0x20000000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Defines user defined symbols.
             * These symbols are added with extremely high score
             * so they are always treated as one unique symbol in any context.
             * Typical usage of user_defined_symbols is placeholder for named entities.
             * </pre>
             *
             * <code>repeated string user_defined_symbols = 31;</code>
             *
             * @param values The userDefinedSymbols to add.
             * @return This builder for chaining.
             */
            public Builder addAllUserDefinedSymbols(Iterable<String> values)
            {
                ensureUserDefinedSymbolsIsMutable();
                AbstractMessageLite.Builder.addAll(values, userDefinedSymbols_);
                bitField0_ |= 0x20000000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Defines user defined symbols.
             * These symbols are added with extremely high score
             * so they are always treated as one unique symbol in any context.
             * Typical usage of user_defined_symbols is placeholder for named entities.
             * </pre>
             *
             * <code>repeated string user_defined_symbols = 31;</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearUserDefinedSymbols()
            {
                userDefinedSymbols_ = LazyStringArrayList.emptyList();
                bitField0_ = (bitField0_ & ~0x20000000);
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Defines user defined symbols.
             * These symbols are added with extremely high score
             * so they are always treated as one unique symbol in any context.
             * Typical usage of user_defined_symbols is placeholder for named entities.
             * </pre>
             *
             * <code>repeated string user_defined_symbols = 31;</code>
             *
             * @param value The bytes of the userDefinedSymbols to add.
             * @return This builder for chaining.
             */
            public Builder addUserDefinedSymbolsBytes(ByteString value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                ensureUserDefinedSymbolsIsMutable();
                userDefinedSymbols_.add(value);
                bitField0_ |= 0x20000000;
                onChanged();
                return this;
            }

            private Object requiredChars_ = "";

            /**
             * <pre>
             * Defines required characters. Each UTF8 character in this string is included
             * in the character set regardless of character_coverage value. Unlike
             * user_defined_symbols, these characters have scores based on the frequency
             * on input sentences, and the model can form subwords using characters
             * in this field.
             * </pre>
             *
             * <code>optional string required_chars = 36;</code>
             *
             * @return Whether the requiredChars field is set.
             */
            public boolean hasRequiredChars()
            {
                return ((bitField0_ & 0x40000000) != 0);
            }

            /**
             * <pre>
             * Defines required characters. Each UTF8 character in this string is included
             * in the character set regardless of character_coverage value. Unlike
             * user_defined_symbols, these characters have scores based on the frequency
             * on input sentences, and the model can form subwords using characters
             * in this field.
             * </pre>
             *
             * <code>optional string required_chars = 36;</code>
             *
             * @return The requiredChars.
             */
            public String getRequiredChars()
            {
                Object ref = requiredChars_;
                if (!(ref instanceof String))
                {
                    ByteString bs = (ByteString) ref;
                    String s = bs.toStringUtf8();
                    if (bs.isValidUtf8())
                    {
                        requiredChars_ = s;
                    }
                    return s;
                }
                else
                {
                    return (String) ref;
                }
            }

            /**
             * <pre>
             * Defines required characters. Each UTF8 character in this string is included
             * in the character set regardless of character_coverage value. Unlike
             * user_defined_symbols, these characters have scores based on the frequency
             * on input sentences, and the model can form subwords using characters
             * in this field.
             * </pre>
             *
             * <code>optional string required_chars = 36;</code>
             *
             * @return The bytes for requiredChars.
             */
            public ByteString getRequiredCharsBytes()
            {
                Object ref = requiredChars_;
                if (ref instanceof String)
                {
                    ByteString b = ByteString.copyFromUtf8((String) ref);
                    requiredChars_ = b;
                    return b;
                }
                else
                {
                    return (ByteString) ref;
                }
            }

            /**
             * <pre>
             * Defines required characters. Each UTF8 character in this string is included
             * in the character set regardless of character_coverage value. Unlike
             * user_defined_symbols, these characters have scores based on the frequency
             * on input sentences, and the model can form subwords using characters
             * in this field.
             * </pre>
             *
             * <code>optional string required_chars = 36;</code>
             *
             * @param value The requiredChars to set.
             * @return This builder for chaining.
             */
            public Builder setRequiredChars(String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                requiredChars_ = value;
                bitField0_ |= 0x40000000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Defines required characters. Each UTF8 character in this string is included
             * in the character set regardless of character_coverage value. Unlike
             * user_defined_symbols, these characters have scores based on the frequency
             * on input sentences, and the model can form subwords using characters
             * in this field.
             * </pre>
             *
             * <code>optional string required_chars = 36;</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearRequiredChars()
            {
                requiredChars_ = getDefaultInstance().getRequiredChars();
                bitField0_ = (bitField0_ & ~0x40000000);
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Defines required characters. Each UTF8 character in this string is included
             * in the character set regardless of character_coverage value. Unlike
             * user_defined_symbols, these characters have scores based on the frequency
             * on input sentences, and the model can form subwords using characters
             * in this field.
             * </pre>
             *
             * <code>optional string required_chars = 36;</code>
             *
             * @param value The bytes for requiredChars to set.
             * @return This builder for chaining.
             */
            public Builder setRequiredCharsBytes(ByteString value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                requiredChars_ = value;
                bitField0_ |= 0x40000000;
                onChanged();
                return this;
            }

            private boolean byteFallback_;

            /**
             * <pre>
             * Decomposes unknown pieces into UTF-8 bytes.
             * </pre>
             *
             * <code>optional bool byte_fallback = 35 [default = false];</code>
             *
             * @return Whether the byteFallback field is set.
             */
            @Override
            public boolean hasByteFallback()
            {
                return ((bitField0_ & 0x80000000) != 0);
            }

            /**
             * <pre>
             * Decomposes unknown pieces into UTF-8 bytes.
             * </pre>
             *
             * <code>optional bool byte_fallback = 35 [default = false];</code>
             *
             * @return The byteFallback.
             */
            @Override
            public boolean getByteFallback()
            {
                return byteFallback_;
            }

            /**
             * <pre>
             * Decomposes unknown pieces into UTF-8 bytes.
             * </pre>
             *
             * <code>optional bool byte_fallback = 35 [default = false];</code>
             *
             * @param value The byteFallback to set.
             * @return This builder for chaining.
             */
            public Builder setByteFallback(boolean value)
            {
                byteFallback_ = value;
                bitField0_ |= 0x80000000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Decomposes unknown pieces into UTF-8 bytes.
             * </pre>
             *
             * <code>optional bool byte_fallback = 35 [default = false];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearByteFallback()
            {
                bitField0_ = (bitField0_ & ~0x80000000);
                byteFallback_ = false;
                onChanged();
                return this;
            }

            private boolean vocabularyOutputPieceScore_ = true;

            /**
             * <pre>
             * When creating the vocabulary file, defines whether or not to additionally
             * output the score for each piece.
             * </pre>
             *
             * <code>optional bool vocabulary_output_piece_score = 32 [default = true];</code>
             *
             * @return Whether the vocabularyOutputPieceScore field is set.
             */
            @Override
            public boolean hasVocabularyOutputPieceScore()
            {
                return ((bitField1_ & 0x00000001) != 0);
            }

            /**
             * <pre>
             * When creating the vocabulary file, defines whether or not to additionally
             * output the score for each piece.
             * </pre>
             *
             * <code>optional bool vocabulary_output_piece_score = 32 [default = true];</code>
             *
             * @return The vocabularyOutputPieceScore.
             */
            @Override
            public boolean getVocabularyOutputPieceScore()
            {
                return vocabularyOutputPieceScore_;
            }

            /**
             * <pre>
             * When creating the vocabulary file, defines whether or not to additionally
             * output the score for each piece.
             * </pre>
             *
             * <code>optional bool vocabulary_output_piece_score = 32 [default = true];</code>
             *
             * @param value The vocabularyOutputPieceScore to set.
             * @return This builder for chaining.
             */
            public Builder setVocabularyOutputPieceScore(boolean value)
            {
                vocabularyOutputPieceScore_ = value;
                bitField1_ |= 0x00000001;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * When creating the vocabulary file, defines whether or not to additionally
             * output the score for each piece.
             * </pre>
             *
             * <code>optional bool vocabulary_output_piece_score = 32 [default = true];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearVocabularyOutputPieceScore()
            {
                bitField1_ = (bitField1_ & ~0x00000001);
                vocabularyOutputPieceScore_ = true;
                onChanged();
                return this;
            }

            private boolean hardVocabLimit_ = true;

            /**
             * <pre>
             * `vocab_size` is treated as hard limit. Crash if
             * the model can not produce the vocab of size `vocab_size`,
             * When `hard_vocab_limit` is false, vocab_size is treated
             * as soft limit. Note that when model_type=char,
             * always assumes hard_vocab_limit = false.
             * </pre>
             *
             * <code>optional bool hard_vocab_limit = 33 [default = true];</code>
             *
             * @return Whether the hardVocabLimit field is set.
             */
            @Override
            public boolean hasHardVocabLimit()
            {
                return ((bitField1_ & 0x00000002) != 0);
            }

            /**
             * <pre>
             * `vocab_size` is treated as hard limit. Crash if
             * the model can not produce the vocab of size `vocab_size`,
             * When `hard_vocab_limit` is false, vocab_size is treated
             * as soft limit. Note that when model_type=char,
             * always assumes hard_vocab_limit = false.
             * </pre>
             *
             * <code>optional bool hard_vocab_limit = 33 [default = true];</code>
             *
             * @return The hardVocabLimit.
             */
            @Override
            public boolean getHardVocabLimit()
            {
                return hardVocabLimit_;
            }

            /**
             * <pre>
             * `vocab_size` is treated as hard limit. Crash if
             * the model can not produce the vocab of size `vocab_size`,
             * When `hard_vocab_limit` is false, vocab_size is treated
             * as soft limit. Note that when model_type=char,
             * always assumes hard_vocab_limit = false.
             * </pre>
             *
             * <code>optional bool hard_vocab_limit = 33 [default = true];</code>
             *
             * @param value The hardVocabLimit to set.
             * @return This builder for chaining.
             */
            public Builder setHardVocabLimit(boolean value)
            {
                hardVocabLimit_ = value;
                bitField1_ |= 0x00000002;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * `vocab_size` is treated as hard limit. Crash if
             * the model can not produce the vocab of size `vocab_size`,
             * When `hard_vocab_limit` is false, vocab_size is treated
             * as soft limit. Note that when model_type=char,
             * always assumes hard_vocab_limit = false.
             * </pre>
             *
             * <code>optional bool hard_vocab_limit = 33 [default = true];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearHardVocabLimit()
            {
                bitField1_ = (bitField1_ & ~0x00000002);
                hardVocabLimit_ = true;
                onChanged();
                return this;
            }

            private boolean useAllVocab_;

            /**
             * <pre>
             * use all symbols for vocab extraction. This flag is valid
             * if model type is either CHAR or WORD
             * </pre>
             *
             * <code>optional bool use_all_vocab = 34 [default = false];</code>
             *
             * @return Whether the useAllVocab field is set.
             */
            @Override
            public boolean hasUseAllVocab()
            {
                return ((bitField1_ & 0x00000004) != 0);
            }

            /**
             * <pre>
             * use all symbols for vocab extraction. This flag is valid
             * if model type is either CHAR or WORD
             * </pre>
             *
             * <code>optional bool use_all_vocab = 34 [default = false];</code>
             *
             * @return The useAllVocab.
             */
            @Override
            public boolean getUseAllVocab()
            {
                return useAllVocab_;
            }

            /**
             * <pre>
             * use all symbols for vocab extraction. This flag is valid
             * if model type is either CHAR or WORD
             * </pre>
             *
             * <code>optional bool use_all_vocab = 34 [default = false];</code>
             *
             * @param value The useAllVocab to set.
             * @return This builder for chaining.
             */
            public Builder setUseAllVocab(boolean value)
            {
                useAllVocab_ = value;
                bitField1_ |= 0x00000004;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * use all symbols for vocab extraction. This flag is valid
             * if model type is either CHAR or WORD
             * </pre>
             *
             * <code>optional bool use_all_vocab = 34 [default = false];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearUseAllVocab()
            {
                bitField1_ = (bitField1_ & ~0x00000004);
                useAllVocab_ = false;
                onChanged();
                return this;
            }

            private int unkId_;

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * Reserved special meta tokens.
             * * -1 is not used.
             * * unk_id must not be -1.
             * Id must starts with 0 and be contigous.
             * </pre>
             *
             * <code>optional int32 unk_id = 40 [default = 0];</code>
             *
             * @return Whether the unkId field is set.
             */
            @Override
            public boolean hasUnkId()
            {
                return ((bitField1_ & 0x00000008) != 0);
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * Reserved special meta tokens.
             * * -1 is not used.
             * * unk_id must not be -1.
             * Id must starts with 0 and be contigous.
             * </pre>
             *
             * <code>optional int32 unk_id = 40 [default = 0];</code>
             *
             * @return The unkId.
             */
            @Override
            public int getUnkId()
            {
                return unkId_;
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * Reserved special meta tokens.
             * * -1 is not used.
             * * unk_id must not be -1.
             * Id must starts with 0 and be contigous.
             * </pre>
             *
             * <code>optional int32 unk_id = 40 [default = 0];</code>
             *
             * @param value The unkId to set.
             * @return This builder for chaining.
             */
            public Builder setUnkId(int value)
            {
                unkId_ = value;
                bitField1_ |= 0x00000008;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * &#47;////////////////////////////////////////////////////////////////
             * Reserved special meta tokens.
             * * -1 is not used.
             * * unk_id must not be -1.
             * Id must starts with 0 and be contigous.
             * </pre>
             *
             * <code>optional int32 unk_id = 40 [default = 0];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearUnkId()
            {
                bitField1_ = (bitField1_ & ~0x00000008);
                unkId_ = 0;
                onChanged();
                return this;
            }

            private int bosId_ = 1;

            /**
             * <pre>
             * &lt;s&gt;
             * </pre>
             *
             * <code>optional int32 bos_id = 41 [default = 1];</code>
             *
             * @return Whether the bosId field is set.
             */
            @Override
            public boolean hasBosId()
            {
                return ((bitField1_ & 0x00000010) != 0);
            }

            /**
             * <pre>
             * &lt;s&gt;
             * </pre>
             *
             * <code>optional int32 bos_id = 41 [default = 1];</code>
             *
             * @return The bosId.
             */
            @Override
            public int getBosId()
            {
                return bosId_;
            }

            /**
             * <pre>
             * &lt;s&gt;
             * </pre>
             *
             * <code>optional int32 bos_id = 41 [default = 1];</code>
             *
             * @param value The bosId to set.
             * @return This builder for chaining.
             */
            public Builder setBosId(int value)
            {
                bosId_ = value;
                bitField1_ |= 0x00000010;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * &lt;s&gt;
             * </pre>
             *
             * <code>optional int32 bos_id = 41 [default = 1];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearBosId()
            {
                bitField1_ = (bitField1_ & ~0x00000010);
                bosId_ = 1;
                onChanged();
                return this;
            }

            private int eosId_ = 2;

            /**
             * <pre>
             * &lt;/s&gt;
             * </pre>
             *
             * <code>optional int32 eos_id = 42 [default = 2];</code>
             *
             * @return Whether the eosId field is set.
             */
            @Override
            public boolean hasEosId()
            {
                return ((bitField1_ & 0x00000020) != 0);
            }

            /**
             * <pre>
             * &lt;/s&gt;
             * </pre>
             *
             * <code>optional int32 eos_id = 42 [default = 2];</code>
             *
             * @return The eosId.
             */
            @Override
            public int getEosId()
            {
                return eosId_;
            }

            /**
             * <pre>
             * &lt;/s&gt;
             * </pre>
             *
             * <code>optional int32 eos_id = 42 [default = 2];</code>
             *
             * @param value The eosId to set.
             * @return This builder for chaining.
             */
            public Builder setEosId(int value)
            {
                eosId_ = value;
                bitField1_ |= 0x00000020;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * &lt;/s&gt;
             * </pre>
             *
             * <code>optional int32 eos_id = 42 [default = 2];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearEosId()
            {
                bitField1_ = (bitField1_ & ~0x00000020);
                eosId_ = 2;
                onChanged();
                return this;
            }

            private int padId_ = -1;

            /**
             * <pre>
             * &lt;pad&gt; (padding)
             * </pre>
             *
             * <code>optional int32 pad_id = 43 [default = -1];</code>
             *
             * @return Whether the padId field is set.
             */
            @Override
            public boolean hasPadId()
            {
                return ((bitField1_ & 0x00000040) != 0);
            }

            /**
             * <pre>
             * &lt;pad&gt; (padding)
             * </pre>
             *
             * <code>optional int32 pad_id = 43 [default = -1];</code>
             *
             * @return The padId.
             */
            @Override
            public int getPadId()
            {
                return padId_;
            }

            /**
             * <pre>
             * &lt;pad&gt; (padding)
             * </pre>
             *
             * <code>optional int32 pad_id = 43 [default = -1];</code>
             *
             * @param value The padId to set.
             * @return This builder for chaining.
             */
            public Builder setPadId(int value)
            {
                padId_ = value;
                bitField1_ |= 0x00000040;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * &lt;pad&gt; (padding)
             * </pre>
             *
             * <code>optional int32 pad_id = 43 [default = -1];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearPadId()
            {
                bitField1_ = (bitField1_ & ~0x00000040);
                padId_ = -1;
                onChanged();
                return this;
            }

            private Object unkPiece_ = "<unk>";

            /**
             * <code>optional string unk_piece = 45 [default = "&lt;unk&gt;"];</code>
             *
             * @return Whether the unkPiece field is set.
             */
            public boolean hasUnkPiece()
            {
                return ((bitField1_ & 0x00000080) != 0);
            }

            /**
             * <code>optional string unk_piece = 45 [default = "&lt;unk&gt;"];</code>
             *
             * @return The unkPiece.
             */
            public String getUnkPiece()
            {
                Object ref = unkPiece_;
                if (!(ref instanceof String))
                {
                    ByteString bs = (ByteString) ref;
                    String s = bs.toStringUtf8();
                    if (bs.isValidUtf8())
                    {
                        unkPiece_ = s;
                    }
                    return s;
                }
                else
                {
                    return (String) ref;
                }
            }

            /**
             * <code>optional string unk_piece = 45 [default = "&lt;unk&gt;"];</code>
             *
             * @return The bytes for unkPiece.
             */
            public ByteString
            getUnkPieceBytes()
            {
                Object ref = unkPiece_;
                if (ref instanceof String)
                {
                    ByteString b = ByteString.copyFromUtf8((String) ref);
                    unkPiece_ = b;
                    return b;
                }
                else
                {
                    return (ByteString) ref;
                }
            }

            /**
             * <code>optional string unk_piece = 45 [default = "&lt;unk&gt;"];</code>
             *
             * @param value The unkPiece to set.
             * @return This builder for chaining.
             */
            public Builder setUnkPiece(String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                unkPiece_ = value;
                bitField1_ |= 0x00000080;
                onChanged();
                return this;
            }

            /**
             * <code>optional string unk_piece = 45 [default = "&lt;unk&gt;"];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearUnkPiece()
            {
                unkPiece_ = getDefaultInstance().getUnkPiece();
                bitField1_ = (bitField1_ & ~0x00000080);
                onChanged();
                return this;
            }

            /**
             * <code>optional string unk_piece = 45 [default = "&lt;unk&gt;"];</code>
             *
             * @param value The bytes for unkPiece to set.
             * @return This builder for chaining.
             */
            public Builder setUnkPieceBytes(ByteString value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                unkPiece_ = value;
                bitField1_ |= 0x00000080;
                onChanged();
                return this;
            }

            private Object bosPiece_ = "<s>";

            /**
             * <code>optional string bos_piece = 46 [default = "&lt;s&gt;"];</code>
             *
             * @return Whether the bosPiece field is set.
             */
            public boolean hasBosPiece()
            {
                return ((bitField1_ & 0x00000100) != 0);
            }

            /**
             * <code>optional string bos_piece = 46 [default = "&lt;s&gt;"];</code>
             *
             * @return The bosPiece.
             */
            public String getBosPiece()
            {
                Object ref = bosPiece_;
                if (!(ref instanceof String))
                {
                    ByteString bs = (ByteString) ref;
                    String s = bs.toStringUtf8();
                    if (bs.isValidUtf8())
                    {
                        bosPiece_ = s;
                    }
                    return s;
                }
                else
                {
                    return (String) ref;
                }
            }

            /**
             * <code>optional string bos_piece = 46 [default = "&lt;s&gt;"];</code>
             *
             * @return The bytes for bosPiece.
             */
            public ByteString
            getBosPieceBytes()
            {
                Object ref = bosPiece_;
                if (ref instanceof String)
                {
                    ByteString b = ByteString.copyFromUtf8((String) ref);
                    bosPiece_ = b;
                    return b;
                }
                else
                {
                    return (ByteString) ref;
                }
            }

            /**
             * <code>optional string bos_piece = 46 [default = "&lt;s&gt;"];</code>
             *
             * @param value The bosPiece to set.
             * @return This builder for chaining.
             */
            public Builder setBosPiece(String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                bosPiece_ = value;
                bitField1_ |= 0x00000100;
                onChanged();
                return this;
            }

            /**
             * <code>optional string bos_piece = 46 [default = "&lt;s&gt;"];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearBosPiece()
            {
                bosPiece_ = getDefaultInstance().getBosPiece();
                bitField1_ = (bitField1_ & ~0x00000100);
                onChanged();
                return this;
            }

            /**
             * <code>optional string bos_piece = 46 [default = "&lt;s&gt;"];</code>
             *
             * @param value The bytes for bosPiece to set.
             * @return This builder for chaining.
             */
            public Builder setBosPieceBytes(ByteString value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                bosPiece_ = value;
                bitField1_ |= 0x00000100;
                onChanged();
                return this;
            }

            private Object eosPiece_ = "</s>";

            /**
             * <code>optional string eos_piece = 47 [default = "&lt;/s&gt;"];</code>
             *
             * @return Whether the eosPiece field is set.
             */
            public boolean hasEosPiece()
            {
                return ((bitField1_ & 0x00000200) != 0);
            }

            /**
             * <code>optional string eos_piece = 47 [default = "&lt;/s&gt;"];</code>
             *
             * @return The eosPiece.
             */
            public String getEosPiece()
            {
                Object ref = eosPiece_;
                if (!(ref instanceof String))
                {
                    ByteString bs = (ByteString) ref;
                    String s = bs.toStringUtf8();
                    if (bs.isValidUtf8())
                    {
                        eosPiece_ = s;
                    }
                    return s;
                }
                else
                {
                    return (String) ref;
                }
            }

            /**
             * <code>optional string eos_piece = 47 [default = "&lt;/s&gt;"];</code>
             *
             * @return The bytes for eosPiece.
             */
            public ByteString getEosPieceBytes()
            {
                Object ref = eosPiece_;
                if (ref instanceof String)
                {
                    ByteString b = ByteString.copyFromUtf8((String) ref);
                    eosPiece_ = b;
                    return b;
                }
                else
                {
                    return (ByteString) ref;
                }
            }

            /**
             * <code>optional string eos_piece = 47 [default = "&lt;/s&gt;"];</code>
             *
             * @param value The eosPiece to set.
             * @return This builder for chaining.
             */
            public Builder setEosPiece(String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                eosPiece_ = value;
                bitField1_ |= 0x00000200;
                onChanged();
                return this;
            }

            /**
             * <code>optional string eos_piece = 47 [default = "&lt;/s&gt;"];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearEosPiece()
            {
                eosPiece_ = getDefaultInstance().getEosPiece();
                bitField1_ = (bitField1_ & ~0x00000200);
                onChanged();
                return this;
            }

            /**
             * <code>optional string eos_piece = 47 [default = "&lt;/s&gt;"];</code>
             *
             * @param value The bytes for eosPiece to set.
             * @return This builder for chaining.
             */
            public Builder setEosPieceBytes(ByteString value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                eosPiece_ = value;
                bitField1_ |= 0x00000200;
                onChanged();
                return this;
            }

            private Object padPiece_ = "<pad>";

            /**
             * <code>optional string pad_piece = 48 [default = "&lt;pad&gt;"];</code>
             *
             * @return Whether the padPiece field is set.
             */
            public boolean hasPadPiece()
            {
                return ((bitField1_ & 0x00000400) != 0);
            }

            /**
             * <code>optional string pad_piece = 48 [default = "&lt;pad&gt;"];</code>
             *
             * @return The padPiece.
             */
            public String getPadPiece()
            {
                Object ref = padPiece_;
                if (!(ref instanceof String))
                {
                    ByteString bs = (ByteString) ref;
                    String s = bs.toStringUtf8();
                    if (bs.isValidUtf8())
                    {
                        padPiece_ = s;
                    }
                    return s;
                }
                else
                {
                    return (String) ref;
                }
            }

            /**
             * <code>optional string pad_piece = 48 [default = "&lt;pad&gt;"];</code>
             *
             * @return The bytes for padPiece.
             */
            public ByteString getPadPieceBytes()
            {
                Object ref = padPiece_;
                if (ref instanceof String)
                {
                    ByteString b = ByteString.copyFromUtf8((String) ref);
                    padPiece_ = b;
                    return b;
                }
                else
                {
                    return (ByteString) ref;
                }
            }

            /**
             * <code>optional string pad_piece = 48 [default = "&lt;pad&gt;"];</code>
             *
             * @param value The padPiece to set.
             * @return This builder for chaining.
             */
            public Builder setPadPiece(String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                padPiece_ = value;
                bitField1_ |= 0x00000400;
                onChanged();
                return this;
            }

            /**
             * <code>optional string pad_piece = 48 [default = "&lt;pad&gt;"];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearPadPiece()
            {
                padPiece_ = getDefaultInstance().getPadPiece();
                bitField1_ = (bitField1_ & ~0x00000400);
                onChanged();
                return this;
            }

            /**
             * <code>optional string pad_piece = 48 [default = "&lt;pad&gt;"];</code>
             *
             * @param value The bytes for padPiece to set.
             * @return This builder for chaining.
             */
            public Builder setPadPieceBytes(ByteString value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                padPiece_ = value;
                bitField1_ |= 0x00000400;
                onChanged();
                return this;
            }

            private Object unkSurface_ = Internal.stringDefaultValue(" \342\201\207 ");

            /**
             * <pre>
             * Encodes &lt;unk&gt; into U+2047 (DOUBLE QUESTION MARK),
             * since this character can be useful both for user and
             * developer. We can easily figure out that &lt;unk&gt; is emitted.
             * </pre>
             *
             * <code>optional string unk_surface = 44 [default = " &#92;342&#92;201&#92;207 "];</code>
             *
             * @return Whether the unkSurface field is set.
             */
            public boolean hasUnkSurface()
            {
                return ((bitField1_ & 0x00000800) != 0);
            }

            /**
             * <pre>
             * Encodes &lt;unk&gt; into U+2047 (DOUBLE QUESTION MARK),
             * since this character can be useful both for user and
             * developer. We can easily figure out that &lt;unk&gt; is emitted.
             * </pre>
             *
             * <code>optional string unk_surface = 44 [default = " &#92;342&#92;201&#92;207 "];</code>
             *
             * @return The unkSurface.
             */
            public String getUnkSurface()
            {
                Object ref = unkSurface_;
                if (!(ref instanceof String))
                {
                    ByteString bs = (ByteString) ref;
                    String s = bs.toStringUtf8();
                    if (bs.isValidUtf8())
                    {
                        unkSurface_ = s;
                    }
                    return s;
                }
                else
                {
                    return (String) ref;
                }
            }

            /**
             * <pre>
             * Encodes &lt;unk&gt; into U+2047 (DOUBLE QUESTION MARK),
             * since this character can be useful both for user and
             * developer. We can easily figure out that &lt;unk&gt; is emitted.
             * </pre>
             *
             * <code>optional string unk_surface = 44 [default = " &#92;342&#92;201&#92;207 "];</code>
             *
             * @return The bytes for unkSurface.
             */
            public ByteString getUnkSurfaceBytes()
            {
                Object ref = unkSurface_;
                if (ref instanceof String)
                {
                    ByteString b = ByteString.copyFromUtf8((String) ref);
                    unkSurface_ = b;
                    return b;
                }
                else
                {
                    return (ByteString) ref;
                }
            }

            /**
             * <pre>
             * Encodes &lt;unk&gt; into U+2047 (DOUBLE QUESTION MARK),
             * since this character can be useful both for user and
             * developer. We can easily figure out that &lt;unk&gt; is emitted.
             * </pre>
             *
             * <code>optional string unk_surface = 44 [default = " &#92;342&#92;201&#92;207 "];</code>
             *
             * @param value The unkSurface to set.
             * @return This builder for chaining.
             */
            public Builder setUnkSurface(String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                unkSurface_ = value;
                bitField1_ |= 0x00000800;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Encodes &lt;unk&gt; into U+2047 (DOUBLE QUESTION MARK),
             * since this character can be useful both for user and
             * developer. We can easily figure out that &lt;unk&gt; is emitted.
             * </pre>
             *
             * <code>optional string unk_surface = 44 [default = " &#92;342&#92;201&#92;207 "];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearUnkSurface()
            {
                unkSurface_ = getDefaultInstance().getUnkSurface();
                bitField1_ = (bitField1_ & ~0x00000800);
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Encodes &lt;unk&gt; into U+2047 (DOUBLE QUESTION MARK),
             * since this character can be useful both for user and
             * developer. We can easily figure out that &lt;unk&gt; is emitted.
             * </pre>
             *
             * <code>optional string unk_surface = 44 [default = " &#92;342&#92;201&#92;207 "];</code>
             *
             * @param value The bytes for unkSurface to set.
             * @return This builder for chaining.
             */
            public Builder setUnkSurfaceBytes(ByteString value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                unkSurface_ = value;
                bitField1_ |= 0x00000800;
                onChanged();
                return this;
            }

            private boolean trainExtremelyLargeCorpus_;

            /**
             * <pre>
             * Increase bit depth to allow unigram model training on large
             * (&gt;10M sentences) corpora. A Side-effect of enabling this flag
             * is increased memory usage.
             * </pre>
             *
             * <code>optional bool train_extremely_large_corpus = 49 [default = false];</code>
             *
             * @return Whether the trainExtremelyLargeCorpus field is set.
             */
            @Override
            public boolean hasTrainExtremelyLargeCorpus()
            {
                return ((bitField1_ & 0x00001000) != 0);
            }

            /**
             * <pre>
             * Increase bit depth to allow unigram model training on large
             * (&gt;10M sentences) corpora. A Side-effect of enabling this flag
             * is increased memory usage.
             * </pre>
             *
             * <code>optional bool train_extremely_large_corpus = 49 [default = false];</code>
             *
             * @return The trainExtremelyLargeCorpus.
             */
            @Override
            public boolean getTrainExtremelyLargeCorpus()
            {
                return trainExtremelyLargeCorpus_;
            }

            /**
             * <pre>
             * Increase bit depth to allow unigram model training on large
             * (&gt;10M sentences) corpora. A Side-effect of enabling this flag
             * is increased memory usage.
             * </pre>
             *
             * <code>optional bool train_extremely_large_corpus = 49 [default = false];</code>
             *
             * @param value The trainExtremelyLargeCorpus to set.
             * @return This builder for chaining.
             */
            public Builder setTrainExtremelyLargeCorpus(boolean value)
            {
                trainExtremelyLargeCorpus_ = value;
                bitField1_ |= 0x00001000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Increase bit depth to allow unigram model training on large
             * (&gt;10M sentences) corpora. A Side-effect of enabling this flag
             * is increased memory usage.
             * </pre>
             *
             * <code>optional bool train_extremely_large_corpus = 49 [default = false];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearTrainExtremelyLargeCorpus()
            {
                bitField1_ = (bitField1_ & ~0x00001000);
                trainExtremelyLargeCorpus_ = false;
                onChanged();
                return this;
            }

            private Object seedSentencepiecesFile_ = "";

            /**
             * <pre>
             * Path to a seed sentencepieces file, with one tab-separated
             * seed sentencepiece &lt;tab&gt; frequency per line.
             * </pre>
             *
             * <code>optional string seed_sentencepieces_file = 54 [default = ""];</code>
             *
             * @return Whether the seedSentencepiecesFile field is set.
             */
            public boolean hasSeedSentencepiecesFile()
            {
                return ((bitField1_ & 0x00002000) != 0);
            }

            /**
             * <pre>
             * Path to a seed sentencepieces file, with one tab-separated
             * seed sentencepiece &lt;tab&gt; frequency per line.
             * </pre>
             *
             * <code>optional string seed_sentencepieces_file = 54 [default = ""];</code>
             *
             * @return The seedSentencepiecesFile.
             */
            public String getSeedSentencepiecesFile()
            {
                Object ref = seedSentencepiecesFile_;
                if (!(ref instanceof String))
                {
                    ByteString bs = (ByteString) ref;
                    String s = bs.toStringUtf8();
                    if (bs.isValidUtf8())
                    {
                        seedSentencepiecesFile_ = s;
                    }
                    return s;
                }
                else
                {
                    return (String) ref;
                }
            }

            /**
             * <pre>
             * Path to a seed sentencepieces file, with one tab-separated
             * seed sentencepiece &lt;tab&gt; frequency per line.
             * </pre>
             *
             * <code>optional string seed_sentencepieces_file = 54 [default = ""];</code>
             *
             * @return The bytes for seedSentencepiecesFile.
             */
            public ByteString getSeedSentencepiecesFileBytes()
            {
                Object ref = seedSentencepiecesFile_;
                if (ref instanceof String)
                {
                    ByteString b = ByteString.copyFromUtf8((String) ref);
                    seedSentencepiecesFile_ = b;
                    return b;
                }
                else
                {
                    return (ByteString) ref;
                }
            }

            /**
             * <pre>
             * Path to a seed sentencepieces file, with one tab-separated
             * seed sentencepiece &lt;tab&gt; frequency per line.
             * </pre>
             *
             * <code>optional string seed_sentencepieces_file = 54 [default = ""];</code>
             *
             * @param value The seedSentencepiecesFile to set.
             * @return This builder for chaining.
             */
            public Builder setSeedSentencepiecesFile(String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                seedSentencepiecesFile_ = value;
                bitField1_ |= 0x00002000;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Path to a seed sentencepieces file, with one tab-separated
             * seed sentencepiece &lt;tab&gt; frequency per line.
             * </pre>
             *
             * <code>optional string seed_sentencepieces_file = 54 [default = ""];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearSeedSentencepiecesFile()
            {
                seedSentencepiecesFile_ = getDefaultInstance().getSeedSentencepiecesFile();
                bitField1_ = (bitField1_ & ~0x00002000);
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Path to a seed sentencepieces file, with one tab-separated
             * seed sentencepiece &lt;tab&gt; frequency per line.
             * </pre>
             *
             * <code>optional string seed_sentencepieces_file = 54 [default = ""];</code>
             *
             * @param value The bytes for seedSentencepiecesFile to set.
             * @return This builder for chaining.
             */
            public Builder setSeedSentencepiecesFileBytes(ByteString value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                seedSentencepiecesFile_ = value;
                bitField1_ |= 0x00002000;
                onChanged();
                return this;
            }
        }

        private static final TrainerSpec DEFAULT_INSTANCE;

        static
        {
            DEFAULT_INSTANCE = new TrainerSpec();
        }

        public static TrainerSpec getDefaultInstance()
        {
            return DEFAULT_INSTANCE;
        }

        private static final Parser<TrainerSpec> PARSER = new AbstractParser<>()
        {
            @Override
            public TrainerSpec parsePartialFrom(
                    CodedInputStream input,
                    ExtensionRegistryLite extensionRegistry)
                    throws InvalidProtocolBufferException
            {
                Builder builder = newBuilder();
                try
                {
                    builder.mergeFrom(input, extensionRegistry);
                }
                catch (InvalidProtocolBufferException e)
                {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                }
                catch (UninitializedMessageException e)
                {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                }
                catch (IOException e)
                {
                    throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };

        public static Parser<TrainerSpec> parser()
        {
            return PARSER;
        }

        @Override
        public Parser<TrainerSpec> getParserForType()
        {
            return PARSER;
        }

        @Override
        public TrainerSpec getDefaultInstanceForType()
        {
            return DEFAULT_INSTANCE;
        }
    }

    public interface NormalizerSpecOrBuilder extends GeneratedMessage.ExtendableMessageOrBuilder<NormalizerSpec>
    {
        /**
         * <pre>
         * name of normalization rule.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         *
         * @return Whether the name field is set.
         */
        boolean hasName();

        /**
         * <pre>
         * name of normalization rule.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         *
         * @return The name.
         */
        String getName();

        /**
         * <pre>
         * name of normalization rule.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         *
         * @return The bytes for name.
         */
        ByteString getNameBytes();

        /**
         * <pre>
         * Pre-compiled normalization rule created by
         * Builder::GetPrecompiledCharsMap() or Builder::CompileCharsMap() method.
         * Usually this field is set by Builder::GetNormalizerSpec() method.
         * </pre>
         *
         * <code>optional bytes precompiled_charsmap = 2;</code>
         *
         * @return Whether the precompiledCharsmap field is set.
         */
        boolean hasPrecompiledCharsmap();

        /**
         * <pre>
         * Pre-compiled normalization rule created by
         * Builder::GetPrecompiledCharsMap() or Builder::CompileCharsMap() method.
         * Usually this field is set by Builder::GetNormalizerSpec() method.
         * </pre>
         *
         * <code>optional bytes precompiled_charsmap = 2;</code>
         *
         * @return The precompiledCharsmap.
         */
        ByteString getPrecompiledCharsmap();

        /**
         * <pre>
         * Adds dummy whitespace at the beginning of text in order to
         * treat "world" in "world" and "hello world" in the same way.
         * </pre>
         *
         * <code>optional bool add_dummy_prefix = 3 [default = true];</code>
         *
         * @return Whether the addDummyPrefix field is set.
         */
        boolean hasAddDummyPrefix();

        /**
         * <pre>
         * Adds dummy whitespace at the beginning of text in order to
         * treat "world" in "world" and "hello world" in the same way.
         * </pre>
         *
         * <code>optional bool add_dummy_prefix = 3 [default = true];</code>
         *
         * @return The addDummyPrefix.
         */
        boolean getAddDummyPrefix();

        /**
         * <pre>
         * Removes leading, trailing, and duplicate internal whitespace.
         * </pre>
         *
         * <code>optional bool remove_extra_whitespaces = 4 [default = true];</code>
         *
         * @return Whether the removeExtraWhitespaces field is set.
         */
        boolean hasRemoveExtraWhitespaces();

        /**
         * <pre>
         * Removes leading, trailing, and duplicate internal whitespace.
         * </pre>
         *
         * <code>optional bool remove_extra_whitespaces = 4 [default = true];</code>
         *
         * @return The removeExtraWhitespaces.
         */
        boolean getRemoveExtraWhitespaces();

        /**
         * <pre>
         * Replaces whitespace with meta symbol.
         * This field must be true to train sentence piece model.
         * </pre>
         *
         * <code>optional bool escape_whitespaces = 5 [default = true];</code>
         *
         * @return Whether the escapeWhitespaces field is set.
         */
        boolean hasEscapeWhitespaces();

        /**
         * <pre>
         * Replaces whitespace with meta symbol.
         * This field must be true to train sentence piece model.
         * </pre>
         *
         * <code>optional bool escape_whitespaces = 5 [default = true];</code>
         *
         * @return The escapeWhitespaces.
         */
        boolean getEscapeWhitespaces();

        /**
         * <pre>
         * Custom normalization rule file in TSV format.
         * <a href="https://github.com/google/sentencepiece/blob/master/doc/normalization.md">...</a>
         * This field is only used in SentencePieceTrainer::Train() method, which
         * compiles the rule into the binary rule stored in `precompiled_charsmap`.
         * </pre>
         *
         * <code>optional string normalization_rule_tsv = 6;</code>
         *
         * @return Whether the normalizationRuleTsv field is set.
         */
        boolean hasNormalizationRuleTsv();

        /**
         * <pre>
         * Custom normalization rule file in TSV format.
         * <a href="https://github.com/google/sentencepiece/blob/master/doc/normalization.md">...</a>
         * This field is only used in SentencePieceTrainer::Train() method, which
         * compiles the rule into the binary rule stored in `precompiled_charsmap`.
         * </pre>
         *
         * <code>optional string normalization_rule_tsv = 6;</code>
         *
         * @return The normalizationRuleTsv.
         */
        String getNormalizationRuleTsv();

        /**
         * <pre>
         * Custom normalization rule file in TSV format.
         * <a href="https://github.com/google/sentencepiece/blob/master/doc/normalization.md">...</a>
         * This field is only used in SentencePieceTrainer::Train() method, which
         * compiles the rule into the binary rule stored in `precompiled_charsmap`.
         * </pre>
         *
         * <code>optional string normalization_rule_tsv = 6;</code>
         *
         * @return The bytes for normalizationRuleTsv.
         */
        ByteString getNormalizationRuleTsvBytes();
    }

    /**
     * <pre>
     * NormalizerSpec encodes a various parameters for string normalizaiton
     * </pre>
     * <p>
     * Protobuf type {@code sentencepiece.NormalizerSpec}
     */
    public static final class NormalizerSpec extends GeneratedMessage.ExtendableMessage<NormalizerSpec>
            implements NormalizerSpecOrBuilder
    {
        @Serial
        private static final long serialVersionUID = 0L;

        static
        {
            RuntimeVersion.validateProtobufGencodeVersion(
                    RuntimeVersion.RuntimeDomain.PUBLIC,
                    /* major= */ 4,
                    /* minor= */ 26,
                    /* patch= */ 1,
                    /* suffix= */ "",
                    NormalizerSpec.class.getName());
        }

        // Use NormalizerSpec.newBuilder() to construct.
        private NormalizerSpec(ExtendableBuilder<NormalizerSpec, ?> builder)
        {
            super(builder);
        }

        private NormalizerSpec()
        {
            name_ = "";
            normalizationRuleTsv_ = "";
        }

        public static Descriptors.Descriptor getDescriptor()
        {
            return internal_static_sentencepiece_NormalizerSpec_descriptor;
        }

        @Override
        protected FieldAccessorTable internalGetFieldAccessorTable()
        {
            return internal_static_sentencepiece_NormalizerSpec_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(NormalizerSpec.class, Builder.class);
        }

        private int bitField0_;
        public static final int NAME_FIELD_NUMBER = 1;
        private volatile Object name_ = "";

        /**
         * <pre>
         * name of normalization rule.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         *
         * @return Whether the name field is set.
         */
        @Override
        public boolean hasName()
        {
            return ((bitField0_ & 0x00000001) != 0);
        }

        /**
         * <pre>
         * name of normalization rule.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         *
         * @return The name.
         */
        @Override
        public String getName()
        {
            Object ref = name_;
            if (ref instanceof String)
            {
                return (String) ref;
            }
            else
            {
                ByteString bs = (ByteString) ref;
                String s = bs.toStringUtf8();
                if (bs.isValidUtf8())
                {
                    name_ = s;
                }
                return s;
            }
        }

        /**
         * <pre>
         * name of normalization rule.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         *
         * @return The bytes for name.
         */
        @Override
        public ByteString getNameBytes()
        {
            Object ref = name_;
            if (ref instanceof String)
            {
                ByteString b = ByteString.copyFromUtf8((String) ref);
                name_ = b;
                return b;
            }
            else
            {
                return (ByteString) ref;
            }
        }

        public static final int PRECOMPILED_CHARSMAP_FIELD_NUMBER = 2;
        private ByteString precompiledCharsmap_ = ByteString.EMPTY;

        /**
         * <pre>
         * Pre-compiled normalization rule created by
         * Builder::GetPrecompiledCharsMap() or Builder::CompileCharsMap() method.
         * Usually this field is set by Builder::GetNormalizerSpec() method.
         * </pre>
         *
         * <code>optional bytes precompiled_charsmap = 2;</code>
         *
         * @return Whether the precompiledCharsmap field is set.
         */
        @Override
        public boolean hasPrecompiledCharsmap()
        {
            return ((bitField0_ & 0x00000002) != 0);
        }

        /**
         * <pre>
         * Pre-compiled normalization rule created by
         * Builder::GetPrecompiledCharsMap() or Builder::CompileCharsMap() method.
         * Usually this field is set by Builder::GetNormalizerSpec() method.
         * </pre>
         *
         * <code>optional bytes precompiled_charsmap = 2;</code>
         *
         * @return The precompiledCharsmap.
         */
        @Override
        public ByteString getPrecompiledCharsmap()
        {
            return precompiledCharsmap_;
        }

        public static final int ADD_DUMMY_PREFIX_FIELD_NUMBER = 3;
        private boolean addDummyPrefix_ = true;

        /**
         * <pre>
         * Adds dummy whitespace at the beginning of text in order to
         * treat "world" in "world" and "hello world" in the same way.
         * </pre>
         *
         * <code>optional bool add_dummy_prefix = 3 [default = true];</code>
         *
         * @return Whether the addDummyPrefix field is set.
         */
        @Override
        public boolean hasAddDummyPrefix()
        {
            return ((bitField0_ & 0x00000004) != 0);
        }

        /**
         * <pre>
         * Adds dummy whitespace at the beginning of text in order to
         * treat "world" in "world" and "hello world" in the same way.
         * </pre>
         *
         * <code>optional bool add_dummy_prefix = 3 [default = true];</code>
         *
         * @return The addDummyPrefix.
         */
        @Override
        public boolean getAddDummyPrefix()
        {
            return addDummyPrefix_;
        }

        public static final int REMOVE_EXTRA_WHITESPACES_FIELD_NUMBER = 4;
        private boolean removeExtraWhitespaces_ = true;

        /**
         * <pre>
         * Removes leading, trailing, and duplicate internal whitespace.
         * </pre>
         *
         * <code>optional bool remove_extra_whitespaces = 4 [default = true];</code>
         *
         * @return Whether the removeExtraWhitespaces field is set.
         */
        @Override
        public boolean hasRemoveExtraWhitespaces()
        {
            return ((bitField0_ & 0x00000008) != 0);
        }

        /**
         * <pre>
         * Removes leading, trailing, and duplicate internal whitespace.
         * </pre>
         *
         * <code>optional bool remove_extra_whitespaces = 4 [default = true];</code>
         *
         * @return The removeExtraWhitespaces.
         */
        @Override
        public boolean getRemoveExtraWhitespaces()
        {
            return removeExtraWhitespaces_;
        }

        public static final int ESCAPE_WHITESPACES_FIELD_NUMBER = 5;
        private boolean escapeWhitespaces_ = true;

        /**
         * <pre>
         * Replaces whitespace with meta symbol.
         * This field must be true to train sentence piece model.
         * </pre>
         *
         * <code>optional bool escape_whitespaces = 5 [default = true];</code>
         *
         * @return Whether the escapeWhitespaces field is set.
         */
        @Override
        public boolean hasEscapeWhitespaces()
        {
            return ((bitField0_ & 0x00000010) != 0);
        }

        /**
         * <pre>
         * Replaces whitespace with meta symbol.
         * This field must be true to train sentence piece model.
         * </pre>
         *
         * <code>optional bool escape_whitespaces = 5 [default = true];</code>
         *
         * @return The escapeWhitespaces.
         */
        @Override
        public boolean getEscapeWhitespaces()
        {
            return escapeWhitespaces_;
        }

        public static final int NORMALIZATION_RULE_TSV_FIELD_NUMBER = 6;

        private volatile Object normalizationRuleTsv_ = "";

        /**
         * <pre>
         * Custom normalization rule file in TSV format.
         * <a href="https://github.com/google/sentencepiece/blob/master/doc/normalization.md">...</a>
         * This field is only used in SentencePieceTrainer::Train() method, which
         * compiles the rule into the binary rule stored in `precompiled_charsmap`.
         * </pre>
         *
         * <code>optional string normalization_rule_tsv = 6;</code>
         *
         * @return Whether the normalizationRuleTsv field is set.
         */
        @Override
        public boolean hasNormalizationRuleTsv()
        {
            return ((bitField0_ & 0x00000020) != 0);
        }

        /**
         * <pre>
         * Custom normalization rule file in TSV format.
         * <a href="https://github.com/google/sentencepiece/blob/master/doc/normalization.md">...</a>
         * This field is only used in SentencePieceTrainer::Train() method, which
         * compiles the rule into the binary rule stored in `precompiled_charsmap`.
         * </pre>
         *
         * <code>optional string normalization_rule_tsv = 6;</code>
         *
         * @return The normalizationRuleTsv.
         */
        @Override
        public String getNormalizationRuleTsv()
        {
            Object ref = normalizationRuleTsv_;
            if (ref instanceof String)
            {
                return (String) ref;
            }
            else
            {
                ByteString bs = (ByteString) ref;
                String s = bs.toStringUtf8();
                if (bs.isValidUtf8())
                {
                    normalizationRuleTsv_ = s;
                }
                return s;
            }
        }

        /**
         * <pre>
         * Custom normalization rule file in TSV format.
         * <a href="https://github.com/google/sentencepiece/blob/master/doc/normalization.md">...</a>
         * This field is only used in SentencePieceTrainer::Train() method, which
         * compiles the rule into the binary rule stored in `precompiled_charsmap`.
         * </pre>
         *
         * <code>optional string normalization_rule_tsv = 6;</code>
         *
         * @return The bytes for normalizationRuleTsv.
         */
        @Override
        public ByteString
        getNormalizationRuleTsvBytes()
        {
            Object ref = normalizationRuleTsv_;
            if (ref instanceof String)
            {
                ByteString b = ByteString.copyFromUtf8((String) ref);
                normalizationRuleTsv_ = b;
                return b;
            }
            else
            {
                return (ByteString) ref;
            }
        }

        private byte memoizedIsInitialized = -1;

        @Override
        public boolean isInitialized()
        {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;

            if (!extensionsAreInitialized())
            {
                memoizedIsInitialized = 0;
                return false;
            }
            memoizedIsInitialized = 1;
            return true;
        }

        @Override
        public void writeTo(CodedOutputStream output)
                throws IOException
        {
            ExtendableMessage<NormalizerSpec>.ExtensionWriter
                    extensionWriter = newExtensionWriter();
            if (((bitField0_ & 0x00000001) != 0))
            {
                GeneratedMessage.writeString(output, 1, name_);
            }
            if (((bitField0_ & 0x00000002) != 0))
            {
                output.writeBytes(2, precompiledCharsmap_);
            }
            if (((bitField0_ & 0x00000004) != 0))
            {
                output.writeBool(3, addDummyPrefix_);
            }
            if (((bitField0_ & 0x00000008) != 0))
            {
                output.writeBool(4, removeExtraWhitespaces_);
            }
            if (((bitField0_ & 0x00000010) != 0))
            {
                output.writeBool(5, escapeWhitespaces_);
            }
            if (((bitField0_ & 0x00000020) != 0))
            {
                GeneratedMessage.writeString(output, 6, normalizationRuleTsv_);
            }
            extensionWriter.writeUntil(536870912, output);
            getUnknownFields().writeTo(output);
        }

        @Override
        public int getSerializedSize()
        {
            int size = memoizedSize;
            if (size != -1) return size;

            size = 0;
            if (((bitField0_ & 0x00000001) != 0))
            {
                size += GeneratedMessage.computeStringSize(1, name_);
            }
            if (((bitField0_ & 0x00000002) != 0))
            {
                size += CodedOutputStream
                        .computeBytesSize(2, precompiledCharsmap_);
            }
            if (((bitField0_ & 0x00000004) != 0))
            {
                size += CodedOutputStream
                        .computeBoolSize(3, addDummyPrefix_);
            }
            if (((bitField0_ & 0x00000008) != 0))
            {
                size += CodedOutputStream
                        .computeBoolSize(4, removeExtraWhitespaces_);
            }
            if (((bitField0_ & 0x00000010) != 0))
            {
                size += CodedOutputStream
                        .computeBoolSize(5, escapeWhitespaces_);
            }
            if (((bitField0_ & 0x00000020) != 0))
            {
                size += GeneratedMessage.computeStringSize(6, normalizationRuleTsv_);
            }
            size += extensionsSerializedSize();
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }

        @Override
        public boolean equals(final Object obj)
        {
            if (obj == this)
            {
                return true;
            }
            if (!(obj instanceof NormalizerSpec other))
            {
                return super.equals(obj);
            }

            if (hasName() != other.hasName()) return false;
            if (hasName())
            {
                if (!getName()
                        .equals(other.getName())) return false;
            }
            if (hasPrecompiledCharsmap() != other.hasPrecompiledCharsmap()) return false;
            if (hasPrecompiledCharsmap())
            {
                if (!getPrecompiledCharsmap()
                        .equals(other.getPrecompiledCharsmap())) return false;
            }
            if (hasAddDummyPrefix() != other.hasAddDummyPrefix()) return false;
            if (hasAddDummyPrefix())
            {
                if (getAddDummyPrefix()
                        != other.getAddDummyPrefix()) return false;
            }
            if (hasRemoveExtraWhitespaces() != other.hasRemoveExtraWhitespaces()) return false;
            if (hasRemoveExtraWhitespaces())
            {
                if (getRemoveExtraWhitespaces()
                        != other.getRemoveExtraWhitespaces()) return false;
            }
            if (hasEscapeWhitespaces() != other.hasEscapeWhitespaces()) return false;
            if (hasEscapeWhitespaces())
            {
                if (getEscapeWhitespaces()
                        != other.getEscapeWhitespaces()) return false;
            }
            if (hasNormalizationRuleTsv() != other.hasNormalizationRuleTsv()) return false;
            if (hasNormalizationRuleTsv())
            {
                if (!getNormalizationRuleTsv()
                        .equals(other.getNormalizationRuleTsv())) return false;
            }
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return getExtensionFields().equals(other.getExtensionFields());
        }

        @Override
        public int hashCode()
        {
            if (memoizedHashCode != 0)
            {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasName())
            {
                hash = (37 * hash) + NAME_FIELD_NUMBER;
                hash = (53 * hash) + getName().hashCode();
            }
            if (hasPrecompiledCharsmap())
            {
                hash = (37 * hash) + PRECOMPILED_CHARSMAP_FIELD_NUMBER;
                hash = (53 * hash) + getPrecompiledCharsmap().hashCode();
            }
            if (hasAddDummyPrefix())
            {
                hash = (37 * hash) + ADD_DUMMY_PREFIX_FIELD_NUMBER;
                hash = (53 * hash) + Internal.hashBoolean(
                        getAddDummyPrefix());
            }
            if (hasRemoveExtraWhitespaces())
            {
                hash = (37 * hash) + REMOVE_EXTRA_WHITESPACES_FIELD_NUMBER;
                hash = (53 * hash) + Internal.hashBoolean(
                        getRemoveExtraWhitespaces());
            }
            if (hasEscapeWhitespaces())
            {
                hash = (37 * hash) + ESCAPE_WHITESPACES_FIELD_NUMBER;
                hash = (53 * hash) + Internal.hashBoolean(
                        getEscapeWhitespaces());
            }
            if (hasNormalizationRuleTsv())
            {
                hash = (37 * hash) + NORMALIZATION_RULE_TSV_FIELD_NUMBER;
                hash = (53 * hash) + getNormalizationRuleTsv().hashCode();
            }
            hash = hashFields(hash, getExtensionFields());
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }

        public static NormalizerSpec parseFrom(
                ByteBuffer data)
                throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data);
        }

        public static NormalizerSpec parseFrom(
                ByteBuffer data,
                ExtensionRegistryLite extensionRegistry)
                throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data, extensionRegistry);
        }

        public static NormalizerSpec parseFrom(
                ByteString data)
                throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data);
        }

        public static NormalizerSpec parseFrom(
                ByteString data,
                ExtensionRegistryLite extensionRegistry)
                throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data, extensionRegistry);
        }

        public static NormalizerSpec parseFrom(byte[] data)
                throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data);
        }

        public static NormalizerSpec parseFrom(
                byte[] data,
                ExtensionRegistryLite extensionRegistry)
                throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data, extensionRegistry);
        }

        public static NormalizerSpec parseFrom(InputStream input)
                throws IOException
        {
            return GeneratedMessage
                    .parseWithIOException(PARSER, input);
        }

        public static NormalizerSpec parseFrom(
                InputStream input,
                ExtensionRegistryLite extensionRegistry)
                throws IOException
        {
            return GeneratedMessage
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }

        public static NormalizerSpec parseDelimitedFrom(InputStream input)
                throws IOException
        {
            return GeneratedMessage
                    .parseDelimitedWithIOException(PARSER, input);
        }

        public static NormalizerSpec parseDelimitedFrom(
                InputStream input,
                ExtensionRegistryLite extensionRegistry)
                throws IOException
        {
            return GeneratedMessage
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }

        public static NormalizerSpec parseFrom(
                CodedInputStream input)
                throws IOException
        {
            return GeneratedMessage
                    .parseWithIOException(PARSER, input);
        }

        public static NormalizerSpec parseFrom(
                CodedInputStream input,
                ExtensionRegistryLite extensionRegistry)
                throws IOException
        {
            return GeneratedMessage
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }

        @Override
        public Builder newBuilderForType()
        {
            return newBuilder();
        }

        public static Builder newBuilder()
        {
            return DEFAULT_INSTANCE.toBuilder();
        }

        public static Builder newBuilder(NormalizerSpec prototype)
        {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }

        @Override
        public Builder toBuilder()
        {
            return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
        }

        @Override
        protected Builder newBuilderForType(
                BuilderParent parent)
        {
            return new Builder(parent);
        }

        /**
         * <pre>
         * NormalizerSpec encodes a various parameters for string normalizaiton
         * </pre>
         * <p>
         * Protobuf type {@code sentencepiece.NormalizerSpec}
         */
        public static final class Builder extends
                ExtendableBuilder<
                        NormalizerSpec, Builder> implements
                // @@protoc_insertion_point(builder_implements:sentencepiece.NormalizerSpec)
                NormalizerSpecOrBuilder
        {
            public static Descriptors.Descriptor
            getDescriptor()
            {
                return internal_static_sentencepiece_NormalizerSpec_descriptor;
            }

            @Override
            protected FieldAccessorTable
            internalGetFieldAccessorTable()
            {
                return internal_static_sentencepiece_NormalizerSpec_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                NormalizerSpec.class, Builder.class);
            }

            // Construct using NormalizerSpec.newBuilder()
            private Builder()
            {

            }

            private Builder(
                    BuilderParent parent)
            {
                super(parent);

            }

            @Override
            public Builder clear()
            {
                super.clear();
                bitField0_ = 0;
                name_ = "";
                precompiledCharsmap_ = ByteString.EMPTY;
                addDummyPrefix_ = true;
                removeExtraWhitespaces_ = true;
                escapeWhitespaces_ = true;
                normalizationRuleTsv_ = "";
                return this;
            }

            @Override
            public Descriptors.Descriptor
            getDescriptorForType()
            {
                return internal_static_sentencepiece_NormalizerSpec_descriptor;
            }

            @Override
            public NormalizerSpec getDefaultInstanceForType()
            {
                return NormalizerSpec.getDefaultInstance();
            }

            @Override
            public NormalizerSpec build()
            {
                NormalizerSpec result = buildPartial();
                if (!result.isInitialized())
                {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }

            @Override
            public NormalizerSpec buildPartial()
            {
                NormalizerSpec result = new NormalizerSpec(this);
                if (bitField0_ != 0)
                {
                    buildPartial0(result);
                }
                onBuilt();
                return result;
            }

            private void buildPartial0(NormalizerSpec result)
            {
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0))
                {
                    result.name_ = name_;
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000002) != 0))
                {
                    result.precompiledCharsmap_ = precompiledCharsmap_;
                    to_bitField0_ |= 0x00000002;
                }
                if (((from_bitField0_ & 0x00000004) != 0))
                {
                    result.addDummyPrefix_ = addDummyPrefix_;
                    to_bitField0_ |= 0x00000004;
                }
                if (((from_bitField0_ & 0x00000008) != 0))
                {
                    result.removeExtraWhitespaces_ = removeExtraWhitespaces_;
                    to_bitField0_ |= 0x00000008;
                }
                if (((from_bitField0_ & 0x00000010) != 0))
                {
                    result.escapeWhitespaces_ = escapeWhitespaces_;
                    to_bitField0_ |= 0x00000010;
                }
                if (((from_bitField0_ & 0x00000020) != 0))
                {
                    result.normalizationRuleTsv_ = normalizationRuleTsv_;
                    to_bitField0_ |= 0x00000020;
                }
                result.bitField0_ |= to_bitField0_;
            }

            @Override
            public Builder mergeFrom(Message other)
            {
                if (other instanceof NormalizerSpec)
                {
                    return mergeFrom((NormalizerSpec) other);
                }
                else
                {
                    super.mergeFrom(other);
                    return this;
                }
            }

            public Builder mergeFrom(NormalizerSpec other)
            {
                if (other == NormalizerSpec.getDefaultInstance()) return this;
                if (other.hasName())
                {
                    name_ = other.name_;
                    bitField0_ |= 0x00000001;
                    onChanged();
                }
                if (other.hasPrecompiledCharsmap())
                {
                    setPrecompiledCharsmap(other.getPrecompiledCharsmap());
                }
                if (other.hasAddDummyPrefix())
                {
                    setAddDummyPrefix(other.getAddDummyPrefix());
                }
                if (other.hasRemoveExtraWhitespaces())
                {
                    setRemoveExtraWhitespaces(other.getRemoveExtraWhitespaces());
                }
                if (other.hasEscapeWhitespaces())
                {
                    setEscapeWhitespaces(other.getEscapeWhitespaces());
                }
                if (other.hasNormalizationRuleTsv())
                {
                    normalizationRuleTsv_ = other.normalizationRuleTsv_;
                    bitField0_ |= 0x00000020;
                    onChanged();
                }
                this.mergeExtensionFields(other);
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }

            @Override
            public boolean isInitialized()
            {
                return extensionsAreInitialized();
            }

            @Override
            public Builder mergeFrom(
                    CodedInputStream input,
                    ExtensionRegistryLite extensionRegistry)
                    throws IOException
            {
                if (extensionRegistry == null)
                {
                    throw new NullPointerException();
                }
                try
                {
                    boolean done = false;
                    while (!done)
                    {
                        int tag = input.readTag();
                        switch (tag)
                        {
                            case 0:
                                done = true;
                                break;
                            case 10:
                            {
                                name_ = input.readBytes();
                                bitField0_ |= 0x00000001;
                                break;
                            } // case 10
                            case 18:
                            {
                                precompiledCharsmap_ = input.readBytes();
                                bitField0_ |= 0x00000002;
                                break;
                            } // case 18
                            case 24:
                            {
                                addDummyPrefix_ = input.readBool();
                                bitField0_ |= 0x00000004;
                                break;
                            } // case 24
                            case 32:
                            {
                                removeExtraWhitespaces_ = input.readBool();
                                bitField0_ |= 0x00000008;
                                break;
                            } // case 32
                            case 40:
                            {
                                escapeWhitespaces_ = input.readBool();
                                bitField0_ |= 0x00000010;
                                break;
                            } // case 40
                            case 50:
                            {
                                normalizationRuleTsv_ = input.readBytes();
                                bitField0_ |= 0x00000020;
                                break;
                            } // case 50
                            default:
                            {
                                if (!super.parseUnknownField(input, extensionRegistry, tag))
                                {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                } catch (InvalidProtocolBufferException e)
                {
                    throw e.unwrapIOException();
                } finally
                {
                    onChanged();
                } // finally
                return this;
            }

            private int bitField0_;

            private Object name_ = "";

            /**
             * <pre>
             * name of normalization rule.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             *
             * @return Whether the name field is set.
             */
            public boolean hasName()
            {
                return ((bitField0_ & 0x00000001) != 0);
            }

            /**
             * <pre>
             * name of normalization rule.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             *
             * @return The name.
             */
            public String getName()
            {
                Object ref = name_;
                if (!(ref instanceof String))
                {
                    ByteString bs =
                            (ByteString) ref;
                    String s = bs.toStringUtf8();
                    if (bs.isValidUtf8())
                    {
                        name_ = s;
                    }
                    return s;
                }
                else
                {
                    return (String) ref;
                }
            }

            /**
             * <pre>
             * name of normalization rule.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             *
             * @return The bytes for name.
             */
            public ByteString
            getNameBytes()
            {
                Object ref = name_;
                if (ref instanceof String)
                {
                    ByteString b =
                            ByteString.copyFromUtf8(
                                    (String) ref);
                    name_ = b;
                    return b;
                }
                else
                {
                    return (ByteString) ref;
                }
            }

            /**
             * <pre>
             * name of normalization rule.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             *
             * @param value The name to set.
             * @return This builder for chaining.
             */
            public Builder setName(
                    String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                name_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * name of normalization rule.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearName()
            {
                name_ = getDefaultInstance().getName();
                bitField0_ = (bitField0_ & ~0x00000001);
                onChanged();
                return this;
            }

            /**
             * <pre>
             * name of normalization rule.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             *
             * @param value The bytes for name to set.
             * @return This builder for chaining.
             */
            public Builder setNameBytes(
                    ByteString value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                name_ = value;
                bitField0_ |= 0x00000001;
                onChanged();
                return this;
            }

            private ByteString precompiledCharsmap_ = ByteString.EMPTY;

            /**
             * <pre>
             * Pre-compiled normalization rule created by
             * Builder::GetPrecompiledCharsMap() or Builder::CompileCharsMap() method.
             * Usually this field is set by Builder::GetNormalizerSpec() method.
             * </pre>
             *
             * <code>optional bytes precompiled_charsmap = 2;</code>
             *
             * @return Whether the precompiledCharsmap field is set.
             */
            @Override
            public boolean hasPrecompiledCharsmap()
            {
                return ((bitField0_ & 0x00000002) != 0);
            }

            /**
             * <pre>
             * Pre-compiled normalization rule created by
             * Builder::GetPrecompiledCharsMap() or Builder::CompileCharsMap() method.
             * Usually this field is set by Builder::GetNormalizerSpec() method.
             * </pre>
             *
             * <code>optional bytes precompiled_charsmap = 2;</code>
             *
             * @return The precompiledCharsmap.
             */
            @Override
            public ByteString getPrecompiledCharsmap()
            {
                return precompiledCharsmap_;
            }

            /**
             * <pre>
             * Pre-compiled normalization rule created by
             * Builder::GetPrecompiledCharsMap() or Builder::CompileCharsMap() method.
             * Usually this field is set by Builder::GetNormalizerSpec() method.
             * </pre>
             *
             * <code>optional bytes precompiled_charsmap = 2;</code>
             *
             * @param value The precompiledCharsmap to set.
             * @return This builder for chaining.
             */
            public Builder setPrecompiledCharsmap(ByteString value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                precompiledCharsmap_ = value;
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Pre-compiled normalization rule created by
             * Builder::GetPrecompiledCharsMap() or Builder::CompileCharsMap() method.
             * Usually this field is set by Builder::GetNormalizerSpec() method.
             * </pre>
             *
             * <code>optional bytes precompiled_charsmap = 2;</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearPrecompiledCharsmap()
            {
                bitField0_ = (bitField0_ & ~0x00000002);
                precompiledCharsmap_ = getDefaultInstance().getPrecompiledCharsmap();
                onChanged();
                return this;
            }

            private boolean addDummyPrefix_ = true;

            /**
             * <pre>
             * Adds dummy whitespace at the beginning of text in order to
             * treat "world" in "world" and "hello world" in the same way.
             * </pre>
             *
             * <code>optional bool add_dummy_prefix = 3 [default = true];</code>
             *
             * @return Whether the addDummyPrefix field is set.
             */
            @Override
            public boolean hasAddDummyPrefix()
            {
                return ((bitField0_ & 0x00000004) != 0);
            }

            /**
             * <pre>
             * Adds dummy whitespace at the beginning of text in order to
             * treat "world" in "world" and "hello world" in the same way.
             * </pre>
             *
             * <code>optional bool add_dummy_prefix = 3 [default = true];</code>
             *
             * @return The addDummyPrefix.
             */
            @Override
            public boolean getAddDummyPrefix()
            {
                return addDummyPrefix_;
            }

            /**
             * <pre>
             * Adds dummy whitespace at the beginning of text in order to
             * treat "world" in "world" and "hello world" in the same way.
             * </pre>
             *
             * <code>optional bool add_dummy_prefix = 3 [default = true];</code>
             *
             * @param value The addDummyPrefix to set.
             * @return This builder for chaining.
             */
            public Builder setAddDummyPrefix(boolean value)
            {

                addDummyPrefix_ = value;
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Adds dummy whitespace at the beginning of text in order to
             * treat "world" in "world" and "hello world" in the same way.
             * </pre>
             *
             * <code>optional bool add_dummy_prefix = 3 [default = true];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearAddDummyPrefix()
            {
                bitField0_ = (bitField0_ & ~0x00000004);
                addDummyPrefix_ = true;
                onChanged();
                return this;
            }

            private boolean removeExtraWhitespaces_ = true;

            /**
             * <pre>
             * Removes leading, trailing, and duplicate internal whitespace.
             * </pre>
             *
             * <code>optional bool remove_extra_whitespaces = 4 [default = true];</code>
             *
             * @return Whether the removeExtraWhitespaces field is set.
             */
            @Override
            public boolean hasRemoveExtraWhitespaces()
            {
                return ((bitField0_ & 0x00000008) != 0);
            }

            /**
             * <pre>
             * Removes leading, trailing, and duplicate internal whitespace.
             * </pre>
             *
             * <code>optional bool remove_extra_whitespaces = 4 [default = true];</code>
             *
             * @return The removeExtraWhitespaces.
             */
            @Override
            public boolean getRemoveExtraWhitespaces()
            {
                return removeExtraWhitespaces_;
            }

            /**
             * <pre>
             * Removes leading, trailing, and duplicate internal whitespace.
             * </pre>
             *
             * <code>optional bool remove_extra_whitespaces = 4 [default = true];</code>
             *
             * @param value The removeExtraWhitespaces to set.
             * @return This builder for chaining.
             */
            public Builder setRemoveExtraWhitespaces(boolean value)
            {

                removeExtraWhitespaces_ = value;
                bitField0_ |= 0x00000008;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Removes leading, trailing, and duplicate internal whitespace.
             * </pre>
             *
             * <code>optional bool remove_extra_whitespaces = 4 [default = true];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearRemoveExtraWhitespaces()
            {
                bitField0_ = (bitField0_ & ~0x00000008);
                removeExtraWhitespaces_ = true;
                onChanged();
                return this;
            }

            private boolean escapeWhitespaces_ = true;

            /**
             * <pre>
             * Replaces whitespace with meta symbol.
             * This field must be true to train sentence piece model.
             * </pre>
             *
             * <code>optional bool escape_whitespaces = 5 [default = true];</code>
             *
             * @return Whether the escapeWhitespaces field is set.
             */
            @Override
            public boolean hasEscapeWhitespaces()
            {
                return ((bitField0_ & 0x00000010) != 0);
            }

            /**
             * <pre>
             * Replaces whitespace with meta symbol.
             * This field must be true to train sentence piece model.
             * </pre>
             *
             * <code>optional bool escape_whitespaces = 5 [default = true];</code>
             *
             * @return The escapeWhitespaces.
             */
            @Override
            public boolean getEscapeWhitespaces()
            {
                return escapeWhitespaces_;
            }

            /**
             * <pre>
             * Replaces whitespace with meta symbol.
             * This field must be true to train sentence piece model.
             * </pre>
             *
             * <code>optional bool escape_whitespaces = 5 [default = true];</code>
             *
             * @param value The escapeWhitespaces to set.
             * @return This builder for chaining.
             */
            public Builder setEscapeWhitespaces(boolean value)
            {

                escapeWhitespaces_ = value;
                bitField0_ |= 0x00000010;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Replaces whitespace with meta symbol.
             * This field must be true to train sentence piece model.
             * </pre>
             *
             * <code>optional bool escape_whitespaces = 5 [default = true];</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearEscapeWhitespaces()
            {
                bitField0_ = (bitField0_ & ~0x00000010);
                escapeWhitespaces_ = true;
                onChanged();
                return this;
            }

            private Object normalizationRuleTsv_ = "";

            /**
             * <pre>
             * Custom normalization rule file in TSV format.
             * <a href="https://github.com/google/sentencepiece/blob/master/doc/normalization.md">...</a>
             * This field is only used in SentencePieceTrainer::Train() method, which
             * compiles the rule into the binary rule stored in `precompiled_charsmap`.
             * </pre>
             *
             * <code>optional string normalization_rule_tsv = 6;</code>
             *
             * @return Whether the normalizationRuleTsv field is set.
             */
            public boolean hasNormalizationRuleTsv()
            {
                return ((bitField0_ & 0x00000020) != 0);
            }

            /**
             * <pre>
             * Custom normalization rule file in TSV format.
             * <a href="https://github.com/google/sentencepiece/blob/master/doc/normalization.md">...</a>
             * This field is only used in SentencePieceTrainer::Train() method, which
             * compiles the rule into the binary rule stored in `precompiled_charsmap`.
             * </pre>
             *
             * <code>optional string normalization_rule_tsv = 6;</code>
             *
             * @return The normalizationRuleTsv.
             */
            public String getNormalizationRuleTsv()
            {
                Object ref = normalizationRuleTsv_;
                if (!(ref instanceof String))
                {
                    ByteString bs =
                            (ByteString) ref;
                    String s = bs.toStringUtf8();
                    if (bs.isValidUtf8())
                    {
                        normalizationRuleTsv_ = s;
                    }
                    return s;
                }
                else
                {
                    return (String) ref;
                }
            }

            /**
             * <pre>
             * Custom normalization rule file in TSV format.
             * <a href="https://github.com/google/sentencepiece/blob/master/doc/normalization.md">...</a>
             * This field is only used in SentencePieceTrainer::Train() method, which
             * compiles the rule into the binary rule stored in `precompiled_charsmap`.
             * </pre>
             *
             * <code>optional string normalization_rule_tsv = 6;</code>
             *
             * @return The bytes for normalizationRuleTsv.
             */
            public ByteString
            getNormalizationRuleTsvBytes()
            {
                Object ref = normalizationRuleTsv_;
                if (ref instanceof String)
                {
                    ByteString b =
                            ByteString.copyFromUtf8(
                                    (String) ref);
                    normalizationRuleTsv_ = b;
                    return b;
                }
                else
                {
                    return (ByteString) ref;
                }
            }

            /**
             * <pre>
             * Custom normalization rule file in TSV format.
             * <a href="https://github.com/google/sentencepiece/blob/master/doc/normalization.md">...</a>
             * This field is only used in SentencePieceTrainer::Train() method, which
             * compiles the rule into the binary rule stored in `precompiled_charsmap`.
             * </pre>
             *
             * <code>optional string normalization_rule_tsv = 6;</code>
             *
             * @param value The normalizationRuleTsv to set.
             * @return This builder for chaining.
             */
            public Builder setNormalizationRuleTsv(
                    String value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                normalizationRuleTsv_ = value;
                bitField0_ |= 0x00000020;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Custom normalization rule file in TSV format.
             * <a href="https://github.com/google/sentencepiece/blob/master/doc/normalization.md">...</a>
             * This field is only used in SentencePieceTrainer::Train() method, which
             * compiles the rule into the binary rule stored in `precompiled_charsmap`.
             * </pre>
             *
             * <code>optional string normalization_rule_tsv = 6;</code>
             *
             * @return This builder for chaining.
             */
            public Builder clearNormalizationRuleTsv()
            {
                normalizationRuleTsv_ = getDefaultInstance().getNormalizationRuleTsv();
                bitField0_ = (bitField0_ & ~0x00000020);
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Custom normalization rule file in TSV format.
             * <a href="https://github.com/google/sentencepiece/blob/master/doc/normalization.md">...</a>
             * This field is only used in SentencePieceTrainer::Train() method, which
             * compiles the rule into the binary rule stored in `precompiled_charsmap`.
             * </pre>
             *
             * <code>optional string normalization_rule_tsv = 6;</code>
             *
             * @param value The bytes for normalizationRuleTsv to set.
             * @return This builder for chaining.
             */
            public Builder setNormalizationRuleTsvBytes(
                    ByteString value)
            {
                if (value == null)
                {
                    throw new NullPointerException();
                }
                normalizationRuleTsv_ = value;
                bitField0_ |= 0x00000020;
                onChanged();
                return this;
            }

            // @@protoc_insertion_point(builder_scope:sentencepiece.NormalizerSpec)
        }

        // @@protoc_insertion_point(class_scope:sentencepiece.NormalizerSpec)
        private static final NormalizerSpec DEFAULT_INSTANCE;

        static
        {
            DEFAULT_INSTANCE = new NormalizerSpec();
        }

        public static NormalizerSpec getDefaultInstance()
        {
            return DEFAULT_INSTANCE;
        }

        private static final Parser<NormalizerSpec>
                PARSER = new AbstractParser<>()
        {
            @Override
            public NormalizerSpec parsePartialFrom(
                    CodedInputStream input,
                    ExtensionRegistryLite extensionRegistry)
                    throws InvalidProtocolBufferException
            {
                Builder builder = newBuilder();
                try
                {
                    builder.mergeFrom(input, extensionRegistry);
                } catch (InvalidProtocolBufferException e)
                {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                } catch (UninitializedMessageException e)
                {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                } catch (IOException e)
                {
                    throw new InvalidProtocolBufferException(e)
                            .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };

        public static Parser<NormalizerSpec> parser()
        {
            return PARSER;
        }

        @Override
        public Parser<NormalizerSpec> getParserForType()
        {
            return PARSER;
        }

        @Override
        public NormalizerSpec getDefaultInstanceForType()
        {
            return DEFAULT_INSTANCE;
        }

    }

    public interface SelfTestDataOrBuilder extends
            // @@protoc_insertion_point(interface_extends:sentencepiece.SelfTestData)
            GeneratedMessage.
                    ExtendableMessageOrBuilder<SelfTestData>
    {

        /**
         * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
         */
        List<SelfTestData.Sample>
        getSamplesList();

        /**
         * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
         */
        SelfTestData.Sample getSamples(int index);

        /**
         * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
         */
        int getSamplesCount();

        /**
         * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
         */
        List<? extends SelfTestData.SampleOrBuilder>
        getSamplesOrBuilderList();

        /**
         * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
         */
        SelfTestData.SampleOrBuilder getSamplesOrBuilder(
                int index);
    }

    /**
     * <pre>
     * Proto to store samples for self-testing.
     * </pre>
     * <p>
     * Protobuf type {@code sentencepiece.SelfTestData}
     */
    public static final class SelfTestData extends
            GeneratedMessage.ExtendableMessage<
                    SelfTestData> implements
            // @@protoc_insertion_point(message_implements:sentencepiece.SelfTestData)
            SelfTestDataOrBuilder
    {
        @Serial
        private static final long serialVersionUID = 0L;

        static
        {
            RuntimeVersion.validateProtobufGencodeVersion(
                    RuntimeVersion.RuntimeDomain.PUBLIC,
                    /* major= */ 4,
                    /* minor= */ 26,
                    /* patch= */ 1,
                    /* suffix= */ "",
                    SelfTestData.class.getName());
        }

        // Use SelfTestData.newBuilder() to construct.
        private SelfTestData(ExtendableBuilder<SelfTestData, ?> builder)
        {
            super(builder);
        }

        private SelfTestData()
        {
            samples_ = Collections.emptyList();
        }

        public static Descriptors.Descriptor
        getDescriptor()
        {
            return internal_static_sentencepiece_SelfTestData_descriptor;
        }

        @Override
        protected FieldAccessorTable
        internalGetFieldAccessorTable()
        {
            return internal_static_sentencepiece_SelfTestData_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                            SelfTestData.class, Builder.class);
        }

        public interface SampleOrBuilder extends
                // @@protoc_insertion_point(interface_extends:sentencepiece.SelfTestData.Sample)
                MessageOrBuilder
        {

            /**
             * <code>optional string input = 1;</code>
             *
             * @return Whether the input field is set.
             */
            boolean hasInput();

            /**
             * <code>optional string input = 1;</code>
             *
             * @return The input.
             */
            String getInput();

            /**
             * <code>optional string input = 1;</code>
             *
             * @return The bytes for input.
             */
            ByteString
            getInputBytes();

            /**
             * <code>optional string expected = 2;</code>
             *
             * @return Whether the expected field is set.
             */
            boolean hasExpected();

            /**
             * <code>optional string expected = 2;</code>
             *
             * @return The expected.
             */
            String getExpected();

            /**
             * <code>optional string expected = 2;</code>
             *
             * @return The bytes for expected.
             */
            ByteString
            getExpectedBytes();
        }

        /**
         * Protobuf type {@code sentencepiece.SelfTestData.Sample}
         */
        public static final class Sample extends
                GeneratedMessage implements
                // @@protoc_insertion_point(message_implements:sentencepiece.SelfTestData.Sample)
                SampleOrBuilder
        {
            @Serial
            private static final long serialVersionUID = 0L;

            static
            {
                RuntimeVersion.validateProtobufGencodeVersion(
                        RuntimeVersion.RuntimeDomain.PUBLIC,
                        /* major= */ 4,
                        /* minor= */ 26,
                        /* patch= */ 1,
                        /* suffix= */ "",
                        Sample.class.getName());
            }

            // Use Sample.newBuilder() to construct.
            private Sample(GeneratedMessage.Builder<?> builder)
            {
                super(builder);
            }

            private Sample()
            {
                input_ = "";
                expected_ = "";
            }

            public static Descriptors.Descriptor
            getDescriptor()
            {
                return internal_static_sentencepiece_SelfTestData_Sample_descriptor;
            }

            @Override
            protected FieldAccessorTable
            internalGetFieldAccessorTable()
            {
                return internal_static_sentencepiece_SelfTestData_Sample_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                Sample.class, Builder.class);
            }

            private int bitField0_;
            public static final int INPUT_FIELD_NUMBER = 1;

            private volatile Object input_ = "";

            /**
             * <code>optional string input = 1;</code>
             *
             * @return Whether the input field is set.
             */
            @Override
            public boolean hasInput()
            {
                return ((bitField0_ & 0x00000001) != 0);
            }

            /**
             * <code>optional string input = 1;</code>
             *
             * @return The input.
             */
            @Override
            public String getInput()
            {
                Object ref = input_;
                if (ref instanceof String)
                {
                    return (String) ref;
                }
                else
                {
                    ByteString bs =
                            (ByteString) ref;
                    String s = bs.toStringUtf8();
                    if (bs.isValidUtf8())
                    {
                        input_ = s;
                    }
                    return s;
                }
            }

            /**
             * <code>optional string input = 1;</code>
             *
             * @return The bytes for input.
             */
            @Override
            public ByteString
            getInputBytes()
            {
                Object ref = input_;
                if (ref instanceof String)
                {
                    ByteString b =
                            ByteString.copyFromUtf8(
                                    (String) ref);
                    input_ = b;
                    return b;
                }
                else
                {
                    return (ByteString) ref;
                }
            }

            public static final int EXPECTED_FIELD_NUMBER = 2;

            private volatile Object expected_ = "";

            /**
             * <code>optional string expected = 2;</code>
             *
             * @return Whether the expected field is set.
             */
            @Override
            public boolean hasExpected()
            {
                return ((bitField0_ & 0x00000002) != 0);
            }

            /**
             * <code>optional string expected = 2;</code>
             *
             * @return The expected.
             */
            @Override
            public String getExpected()
            {
                Object ref = expected_;
                if (ref instanceof String)
                {
                    return (String) ref;
                }
                else
                {
                    ByteString bs =
                            (ByteString) ref;
                    String s = bs.toStringUtf8();
                    if (bs.isValidUtf8())
                    {
                        expected_ = s;
                    }
                    return s;
                }
            }

            /**
             * <code>optional string expected = 2;</code>
             *
             * @return The bytes for expected.
             */
            @Override
            public ByteString
            getExpectedBytes()
            {
                Object ref = expected_;
                if (ref instanceof String)
                {
                    ByteString b =
                            ByteString.copyFromUtf8(
                                    (String) ref);
                    expected_ = b;
                    return b;
                }
                else
                {
                    return (ByteString) ref;
                }
            }

            private byte memoizedIsInitialized = -1;

            @Override
            public boolean isInitialized()
            {
                byte isInitialized = memoizedIsInitialized;
                if (isInitialized == 1) return true;
                if (isInitialized == 0) return false;

                memoizedIsInitialized = 1;
                return true;
            }

            @Override
            public void writeTo(CodedOutputStream output)
                    throws IOException
            {
                if (((bitField0_ & 0x00000001) != 0))
                {
                    GeneratedMessage.writeString(output, 1, input_);
                }
                if (((bitField0_ & 0x00000002) != 0))
                {
                    GeneratedMessage.writeString(output, 2, expected_);
                }
                getUnknownFields().writeTo(output);
            }

            @Override
            public int getSerializedSize()
            {
                int size = memoizedSize;
                if (size != -1) return size;

                size = 0;
                if (((bitField0_ & 0x00000001) != 0))
                {
                    size += GeneratedMessage.computeStringSize(1, input_);
                }
                if (((bitField0_ & 0x00000002) != 0))
                {
                    size += GeneratedMessage.computeStringSize(2, expected_);
                }
                size += getUnknownFields().getSerializedSize();
                memoizedSize = size;
                return size;
            }

            @Override
            public boolean equals(final Object obj)
            {
                if (obj == this)
                {
                    return true;
                }
                if (!(obj instanceof Sample other))
                {
                    return super.equals(obj);
                }

                if (hasInput() != other.hasInput()) return false;
                if (hasInput())
                {
                    if (!getInput()
                            .equals(other.getInput())) return false;
                }
                if (hasExpected() != other.hasExpected()) return false;
                if (hasExpected())
                {
                    if (!getExpected()
                            .equals(other.getExpected())) return false;
                }
                return getUnknownFields().equals(other.getUnknownFields());
            }

            @Override
            public int hashCode()
            {
                if (memoizedHashCode != 0)
                {
                    return memoizedHashCode;
                }
                int hash = 41;
                hash = (19 * hash) + getDescriptor().hashCode();
                if (hasInput())
                {
                    hash = (37 * hash) + INPUT_FIELD_NUMBER;
                    hash = (53 * hash) + getInput().hashCode();
                }
                if (hasExpected())
                {
                    hash = (37 * hash) + EXPECTED_FIELD_NUMBER;
                    hash = (53 * hash) + getExpected().hashCode();
                }
                hash = (29 * hash) + getUnknownFields().hashCode();
                memoizedHashCode = hash;
                return hash;
            }

            public static Sample parseFrom(
                    ByteBuffer data)
                    throws InvalidProtocolBufferException
            {
                return PARSER.parseFrom(data);
            }

            public static Sample parseFrom(
                    ByteBuffer data,
                    ExtensionRegistryLite extensionRegistry)
                    throws InvalidProtocolBufferException
            {
                return PARSER.parseFrom(data, extensionRegistry);
            }

            public static Sample parseFrom(
                    ByteString data)
                    throws InvalidProtocolBufferException
            {
                return PARSER.parseFrom(data);
            }

            public static Sample parseFrom(
                    ByteString data,
                    ExtensionRegistryLite extensionRegistry)
                    throws InvalidProtocolBufferException
            {
                return PARSER.parseFrom(data, extensionRegistry);
            }

            public static Sample parseFrom(byte[] data)
                    throws InvalidProtocolBufferException
            {
                return PARSER.parseFrom(data);
            }

            public static Sample parseFrom(
                    byte[] data,
                    ExtensionRegistryLite extensionRegistry)
                    throws InvalidProtocolBufferException
            {
                return PARSER.parseFrom(data, extensionRegistry);
            }

            public static Sample parseFrom(InputStream input)
                    throws IOException
            {
                return GeneratedMessage
                        .parseWithIOException(PARSER, input);
            }

            public static Sample parseFrom(
                    InputStream input,
                    ExtensionRegistryLite extensionRegistry)
                    throws IOException
            {
                return GeneratedMessage
                        .parseWithIOException(PARSER, input, extensionRegistry);
            }

            public static Sample parseDelimitedFrom(InputStream input)
                    throws IOException
            {
                return GeneratedMessage
                        .parseDelimitedWithIOException(PARSER, input);
            }

            public static Sample parseDelimitedFrom(
                    InputStream input,
                    ExtensionRegistryLite extensionRegistry)
                    throws IOException
            {
                return GeneratedMessage
                        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
            }

            public static Sample parseFrom(
                    CodedInputStream input)
                    throws IOException
            {
                return GeneratedMessage
                        .parseWithIOException(PARSER, input);
            }

            public static Sample parseFrom(
                    CodedInputStream input,
                    ExtensionRegistryLite extensionRegistry)
                    throws IOException
            {
                return GeneratedMessage
                        .parseWithIOException(PARSER, input, extensionRegistry);
            }

            @Override
            public Builder newBuilderForType()
            {
                return newBuilder();
            }

            public static Builder newBuilder()
            {
                return DEFAULT_INSTANCE.toBuilder();
            }

            public static Builder newBuilder(Sample prototype)
            {
                return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
            }

            @Override
            public Builder toBuilder()
            {
                return this == DEFAULT_INSTANCE
                        ? new Builder() : new Builder().mergeFrom(this);
            }

            @Override
            protected Builder newBuilderForType(
                    BuilderParent parent)
            {
                return new Builder(parent);
            }

            /**
             * Protobuf type {@code sentencepiece.SelfTestData.Sample}
             */
            public static final class Builder extends
                    GeneratedMessage.Builder<Builder> implements
                    // @@protoc_insertion_point(builder_implements:sentencepiece.SelfTestData.Sample)
                    SampleOrBuilder
            {
                public static Descriptors.Descriptor
                getDescriptor()
                {
                    return internal_static_sentencepiece_SelfTestData_Sample_descriptor;
                }

                @Override
                protected FieldAccessorTable
                internalGetFieldAccessorTable()
                {
                    return internal_static_sentencepiece_SelfTestData_Sample_fieldAccessorTable
                            .ensureFieldAccessorsInitialized(
                                    Sample.class, Builder.class);
                }

                // Construct using SelfTestData.Sample.newBuilder()
                private Builder()
                {

                }

                private Builder(
                        BuilderParent parent)
                {
                    super(parent);

                }

                @Override
                public Builder clear()
                {
                    super.clear();
                    bitField0_ = 0;
                    input_ = "";
                    expected_ = "";
                    return this;
                }

                @Override
                public Descriptors.Descriptor
                getDescriptorForType()
                {
                    return internal_static_sentencepiece_SelfTestData_Sample_descriptor;
                }

                @Override
                public Sample getDefaultInstanceForType()
                {
                    return Sample.getDefaultInstance();
                }

                @Override
                public Sample build()
                {
                    Sample result = buildPartial();
                    if (!result.isInitialized())
                    {
                        throw newUninitializedMessageException(result);
                    }
                    return result;
                }

                @Override
                public Sample buildPartial()
                {
                    Sample result = new Sample(this);
                    if (bitField0_ != 0)
                    {
                        buildPartial0(result);
                    }
                    onBuilt();
                    return result;
                }

                private void buildPartial0(Sample result)
                {
                    int from_bitField0_ = bitField0_;
                    int to_bitField0_ = 0;
                    if (((from_bitField0_ & 0x00000001) != 0))
                    {
                        result.input_ = input_;
                        to_bitField0_ |= 0x00000001;
                    }
                    if (((from_bitField0_ & 0x00000002) != 0))
                    {
                        result.expected_ = expected_;
                        to_bitField0_ |= 0x00000002;
                    }
                    result.bitField0_ |= to_bitField0_;
                }

                @Override
                public Builder mergeFrom(Message other)
                {
                    if (other instanceof Sample)
                    {
                        return mergeFrom((Sample) other);
                    }
                    else
                    {
                        super.mergeFrom(other);
                        return this;
                    }
                }

                public Builder mergeFrom(Sample other)
                {
                    if (other == Sample.getDefaultInstance()) return this;
                    if (other.hasInput())
                    {
                        input_ = other.input_;
                        bitField0_ |= 0x00000001;
                        onChanged();
                    }
                    if (other.hasExpected())
                    {
                        expected_ = other.expected_;
                        bitField0_ |= 0x00000002;
                        onChanged();
                    }
                    this.mergeUnknownFields(other.getUnknownFields());
                    onChanged();
                    return this;
                }

                @Override
                public boolean isInitialized()
                {
                    return true;
                }

                @Override
                public Builder mergeFrom(
                        CodedInputStream input,
                        ExtensionRegistryLite extensionRegistry)
                        throws IOException
                {
                    if (extensionRegistry == null)
                    {
                        throw new NullPointerException();
                    }
                    try
                    {
                        boolean done = false;
                        while (!done)
                        {
                            int tag = input.readTag();
                            switch (tag)
                            {
                                case 0:
                                    done = true;
                                    break;
                                case 10:
                                {
                                    input_ = input.readBytes();
                                    bitField0_ |= 0x00000001;
                                    break;
                                } // case 10
                                case 18:
                                {
                                    expected_ = input.readBytes();
                                    bitField0_ |= 0x00000002;
                                    break;
                                } // case 18
                                default:
                                {
                                    if (!super.parseUnknownField(input, extensionRegistry, tag))
                                    {
                                        done = true; // was an endgroup tag
                                    }
                                    break;
                                } // default:
                            } // switch (tag)
                        } // while (!done)
                    } catch (InvalidProtocolBufferException e)
                    {
                        throw e.unwrapIOException();
                    } finally
                    {
                        onChanged();
                    } // finally
                    return this;
                }

                private int bitField0_;

                private Object input_ = "";

                /**
                 * <code>optional string input = 1;</code>
                 *
                 * @return Whether the input field is set.
                 */
                public boolean hasInput()
                {
                    return ((bitField0_ & 0x00000001) != 0);
                }

                /**
                 * <code>optional string input = 1;</code>
                 *
                 * @return The input.
                 */
                public String getInput()
                {
                    Object ref = input_;
                    if (!(ref instanceof String))
                    {
                        ByteString bs =
                                (ByteString) ref;
                        String s = bs.toStringUtf8();
                        if (bs.isValidUtf8())
                        {
                            input_ = s;
                        }
                        return s;
                    }
                    else
                    {
                        return (String) ref;
                    }
                }

                /**
                 * <code>optional string input = 1;</code>
                 *
                 * @return The bytes for input.
                 */
                public ByteString
                getInputBytes()
                {
                    Object ref = input_;
                    if (ref instanceof String)
                    {
                        ByteString b =
                                ByteString.copyFromUtf8(
                                        (String) ref);
                        input_ = b;
                        return b;
                    }
                    else
                    {
                        return (ByteString) ref;
                    }
                }

                /**
                 * <code>optional string input = 1;</code>
                 *
                 * @param value The input to set.
                 * @return This builder for chaining.
                 */
                public Builder setInput(
                        String value)
                {
                    if (value == null)
                    {
                        throw new NullPointerException();
                    }
                    input_ = value;
                    bitField0_ |= 0x00000001;
                    onChanged();
                    return this;
                }

                /**
                 * <code>optional string input = 1;</code>
                 *
                 * @return This builder for chaining.
                 */
                public Builder clearInput()
                {
                    input_ = getDefaultInstance().getInput();
                    bitField0_ = (bitField0_ & ~0x00000001);
                    onChanged();
                    return this;
                }

                /**
                 * <code>optional string input = 1;</code>
                 *
                 * @param value The bytes for input to set.
                 * @return This builder for chaining.
                 */
                public Builder setInputBytes(
                        ByteString value)
                {
                    if (value == null)
                    {
                        throw new NullPointerException();
                    }
                    input_ = value;
                    bitField0_ |= 0x00000001;
                    onChanged();
                    return this;
                }

                private Object expected_ = "";

                /**
                 * <code>optional string expected = 2;</code>
                 *
                 * @return Whether the expected field is set.
                 */
                public boolean hasExpected()
                {
                    return ((bitField0_ & 0x00000002) != 0);
                }

                /**
                 * <code>optional string expected = 2;</code>
                 *
                 * @return The expected.
                 */
                public String getExpected()
                {
                    Object ref = expected_;
                    if (!(ref instanceof String))
                    {
                        ByteString bs =
                                (ByteString) ref;
                        String s = bs.toStringUtf8();
                        if (bs.isValidUtf8())
                        {
                            expected_ = s;
                        }
                        return s;
                    }
                    else
                    {
                        return (String) ref;
                    }
                }

                /**
                 * <code>optional string expected = 2;</code>
                 *
                 * @return The bytes for expected.
                 */
                public ByteString
                getExpectedBytes()
                {
                    Object ref = expected_;
                    if (ref instanceof String)
                    {
                        ByteString b =
                                ByteString.copyFromUtf8(
                                        (String) ref);
                        expected_ = b;
                        return b;
                    }
                    else
                    {
                        return (ByteString) ref;
                    }
                }

                /**
                 * <code>optional string expected = 2;</code>
                 *
                 * @param value The expected to set.
                 * @return This builder for chaining.
                 */
                public Builder setExpected(
                        String value)
                {
                    if (value == null)
                    {
                        throw new NullPointerException();
                    }
                    expected_ = value;
                    bitField0_ |= 0x00000002;
                    onChanged();
                    return this;
                }

                /**
                 * <code>optional string expected = 2;</code>
                 *
                 * @return This builder for chaining.
                 */
                public Builder clearExpected()
                {
                    expected_ = getDefaultInstance().getExpected();
                    bitField0_ = (bitField0_ & ~0x00000002);
                    onChanged();
                    return this;
                }

                /**
                 * <code>optional string expected = 2;</code>
                 *
                 * @param value The bytes for expected to set.
                 * @return This builder for chaining.
                 */
                public Builder setExpectedBytes(
                        ByteString value)
                {
                    if (value == null)
                    {
                        throw new NullPointerException();
                    }
                    expected_ = value;
                    bitField0_ |= 0x00000002;
                    onChanged();
                    return this;
                }

                // @@protoc_insertion_point(builder_scope:sentencepiece.SelfTestData.Sample)
            }

            // @@protoc_insertion_point(class_scope:sentencepiece.SelfTestData.Sample)
            private static final Sample DEFAULT_INSTANCE;

            static
            {
                DEFAULT_INSTANCE = new Sample();
            }

            public static Sample getDefaultInstance()
            {
                return DEFAULT_INSTANCE;
            }

            private static final Parser<Sample> PARSER = new AbstractParser<>()
            {
                @Override
                public Sample parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
                        throws InvalidProtocolBufferException
                {
                    Builder builder = newBuilder();
                    try
                    {
                        builder.mergeFrom(input, extensionRegistry);
                    }
                    catch (InvalidProtocolBufferException e)
                    {
                        throw e.setUnfinishedMessage(builder.buildPartial());
                    }
                    catch (UninitializedMessageException e)
                    {
                        throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                    }
                    catch (IOException e)
                    {
                        throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
                    }
                    return builder.buildPartial();
                }
            };

            public static Parser<Sample> parser()
            {
                return PARSER;
            }

            @Override
            public Parser<Sample> getParserForType()
            {
                return PARSER;
            }

            @Override
            public Sample getDefaultInstanceForType()
            {
                return DEFAULT_INSTANCE;
            }
        }

        public static final int SAMPLES_FIELD_NUMBER = 1;

        private List<Sample> samples_;

        /**
         * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
         */
        @Override
        public List<Sample> getSamplesList()
        {
            return samples_;
        }

        /**
         * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
         */
        @Override
        public List<? extends SampleOrBuilder> getSamplesOrBuilderList()
        {
            return samples_;
        }

        /**
         * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
         */
        @Override
        public int getSamplesCount()
        {
            return samples_.size();
        }

        /**
         * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
         */
        @Override
        public Sample getSamples(int index)
        {
            return samples_.get(index);
        }

        /**
         * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
         */
        @Override
        public SampleOrBuilder getSamplesOrBuilder(int index)
        {
            return samples_.get(index);
        }

        private byte memoizedIsInitialized = -1;

        @Override
        public boolean isInitialized()
        {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;

            if (!extensionsAreInitialized())
            {
                memoizedIsInitialized = 0;
                return false;
            }
            memoizedIsInitialized = 1;
            return true;
        }

        @Override
        public void writeTo(CodedOutputStream output) throws IOException
        {
            ExtendableMessage<SelfTestData>.ExtensionWriter extensionWriter = newExtensionWriter();
            for (Sample sample : samples_)
            {
                output.writeMessage(1, sample);
            }
            extensionWriter.writeUntil(536870912, output);
            getUnknownFields().writeTo(output);
        }

        @Override
        public int getSerializedSize()
        {
            int size = memoizedSize;
            if (size != -1) return size;

            size = 0;
            for (Sample sample : samples_)
            {
                size += CodedOutputStream.computeMessageSize(1, sample);
            }
            size += extensionsSerializedSize();
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }

        @Override
        public boolean equals(final Object obj)
        {
            if (obj == this)
            {
                return true;
            }
            if (!(obj instanceof SelfTestData other))
            {
                return super.equals(obj);
            }

            if (!getSamplesList().equals(other.getSamplesList())) return false;
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return getExtensionFields().equals(other.getExtensionFields());
        }

        @Override
        public int hashCode()
        {
            if (memoizedHashCode != 0)
            {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (getSamplesCount() > 0)
            {
                hash = (37 * hash) + SAMPLES_FIELD_NUMBER;
                hash = (53 * hash) + getSamplesList().hashCode();
            }
            hash = hashFields(hash, getExtensionFields());
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }

        public static SelfTestData parseFrom(ByteBuffer data) throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data);
        }

        public static SelfTestData parseFrom(ByteBuffer data, ExtensionRegistryLite extensionRegistry)
                throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data, extensionRegistry);
        }

        public static SelfTestData parseFrom(ByteString data) throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data);
        }

        public static SelfTestData parseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
                throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data, extensionRegistry);
        }

        public static SelfTestData parseFrom(byte[] data) throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data);
        }

        public static SelfTestData parseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
                throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data, extensionRegistry);
        }

        public static SelfTestData parseFrom(InputStream input) throws IOException
        {
            return GeneratedMessage.parseWithIOException(PARSER, input);
        }

        public static SelfTestData parseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
                throws IOException
        {
            return GeneratedMessage.parseWithIOException(PARSER, input, extensionRegistry);
        }

        public static SelfTestData parseDelimitedFrom(InputStream input) throws IOException
        {
            return GeneratedMessage.parseDelimitedWithIOException(PARSER, input);
        }

        public static SelfTestData parseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
                throws IOException
        {
            return GeneratedMessage.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }

        public static SelfTestData parseFrom(CodedInputStream input) throws IOException
        {
            return GeneratedMessage.parseWithIOException(PARSER, input);
        }

        public static SelfTestData parseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
                throws IOException
        {
            return GeneratedMessage.parseWithIOException(PARSER, input, extensionRegistry);
        }

        @Override
        public Builder newBuilderForType()
        {
            return newBuilder();
        }

        public static Builder newBuilder()
        {
            return DEFAULT_INSTANCE.toBuilder();
        }

        public static Builder newBuilder(SelfTestData prototype)
        {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }

        @Override
        public Builder toBuilder()
        {
            return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
        }

        @Override
        protected Builder newBuilderForType(BuilderParent parent)
        {
            return new Builder(parent);
        }

        /**
         * <pre>
         * Proto to store samples for self-testing.
         * </pre>
         * <p>
         * Protobuf type {@code sentencepiece.SelfTestData}
         */
        public static final class Builder extends ExtendableBuilder<SelfTestData, Builder>
                implements SelfTestDataOrBuilder
        {
            public static Descriptors.Descriptor getDescriptor()
            {
                return internal_static_sentencepiece_SelfTestData_descriptor;
            }

            @Override
            protected FieldAccessorTable internalGetFieldAccessorTable()
            {
                return internal_static_sentencepiece_SelfTestData_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(SelfTestData.class, Builder.class);
            }

            // Construct using SelfTestData.newBuilder()
            private Builder()
            {
            }

            private Builder(BuilderParent parent)
            {
                super(parent);
            }

            @Override
            public Builder clear()
            {
                super.clear();
                bitField0_ = 0;
                if (samplesBuilder_ == null)
                {
                    samples_ = Collections.emptyList();
                }
                else
                {
                    samples_ = null;
                    samplesBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000001);
                return this;
            }

            @Override
            public Descriptors.Descriptor
            getDescriptorForType()
            {
                return internal_static_sentencepiece_SelfTestData_descriptor;
            }

            @Override
            public SelfTestData getDefaultInstanceForType()
            {
                return SelfTestData.getDefaultInstance();
            }

            @Override
            public SelfTestData build()
            {
                SelfTestData result = buildPartial();
                if (!result.isInitialized())
                {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }

            @Override
            public SelfTestData buildPartial()
            {
                SelfTestData result = new SelfTestData(this);
                buildPartialRepeatedFields(result);
                if (bitField0_ != 0)
                {
                    buildPartial0(result);
                }
                onBuilt();
                return result;
            }

            private void buildPartialRepeatedFields(SelfTestData result)
            {
                if (samplesBuilder_ == null)
                {
                    if (((bitField0_ & 0x00000001) != 0))
                    {
                        samples_ = Collections.unmodifiableList(samples_);
                        bitField0_ = (bitField0_ & ~0x00000001);
                    }
                    result.samples_ = samples_;
                }
                else
                {
                    result.samples_ = samplesBuilder_.build();
                }
            }

            private void buildPartial0(SelfTestData result)
            {
                int from_bitField0_ = bitField0_;
            }

            @Override
            public Builder mergeFrom(Message other)
            {
                if (other instanceof SelfTestData)
                {
                    return mergeFrom((SelfTestData) other);
                }
                else
                {
                    super.mergeFrom(other);
                    return this;
                }
            }

            public Builder mergeFrom(SelfTestData other)
            {
                if (other == SelfTestData.getDefaultInstance()) return this;
                if (samplesBuilder_ == null)
                {
                    if (!other.samples_.isEmpty())
                    {
                        if (samples_.isEmpty())
                        {
                            samples_ = other.samples_;
                            bitField0_ = (bitField0_ & ~0x00000001);
                        }
                        else
                        {
                            ensureSamplesIsMutable();
                            samples_.addAll(other.samples_);
                        }
                        onChanged();
                    }
                }
                else
                {
                    if (!other.samples_.isEmpty())
                    {
                        if (samplesBuilder_.isEmpty())
                        {
                            samplesBuilder_.dispose();
                            samplesBuilder_ = null;
                            samples_ = other.samples_;
                            bitField0_ = (bitField0_ & ~0x00000001);
                            samplesBuilder_ = GeneratedMessage.alwaysUseFieldBuilders ? getSamplesFieldBuilder() : null;
                        }
                        else
                        {
                            samplesBuilder_.addAllMessages(other.samples_);
                        }
                    }
                }
                this.mergeExtensionFields(other);
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }

            @Override
            public boolean isInitialized()
            {
                return extensionsAreInitialized();
            }

            @Override
            public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry) throws IOException
            {
                if (extensionRegistry == null)
                {
                    throw new NullPointerException();
                }
                try
                {
                    boolean done = false;
                    while (!done)
                    {
                        int tag = input.readTag();
                        switch (tag)
                        {
                            case 0:
                                done = true;
                                break;
                            case 10:
                            {
                                Sample m = input.readMessage(Sample.parser(), extensionRegistry);
                                if (samplesBuilder_ == null)
                                {
                                    ensureSamplesIsMutable();
                                    samples_.add(m);
                                }
                                else
                                {
                                    samplesBuilder_.addMessage(m);
                                }
                                break;
                            } // case 10
                            default:
                            {
                                if (!super.parseUnknownField(input, extensionRegistry, tag))
                                {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                }
                catch (InvalidProtocolBufferException e)
                {
                    throw e.unwrapIOException();
                }
                finally
                {
                    onChanged();
                } // finally
                return this;
            }

            private int bitField0_;

            private List<Sample> samples_ = Collections.emptyList();

            private void ensureSamplesIsMutable()
            {
                if ((bitField0_ & 0x00000001) == 0)
                {
                    samples_ = new ArrayList<>(samples_);
                    bitField0_ |= 0x00000001;
                }
            }

            private RepeatedFieldBuilder<Sample, Sample.Builder, SampleOrBuilder> samplesBuilder_;

            /**
             * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
             */
            public List<Sample> getSamplesList()
            {
                if (samplesBuilder_ == null)
                {
                    return Collections.unmodifiableList(samples_);
                }
                else
                {
                    return samplesBuilder_.getMessageList();
                }
            }

            /**
             * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
             */
            public int getSamplesCount()
            {
                if (samplesBuilder_ == null)
                {
                    return samples_.size();
                }
                else
                {
                    return samplesBuilder_.getCount();
                }
            }

            /**
             * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
             */
            public Sample getSamples(int index)
            {
                if (samplesBuilder_ == null)
                {
                    return samples_.get(index);
                }
                else
                {
                    return samplesBuilder_.getMessage(index);
                }
            }

            /**
             * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
             */
            public Builder setSamples(int index, Sample value)
            {
                if (samplesBuilder_ == null)
                {
                    if (value == null)
                    {
                        throw new NullPointerException();
                    }
                    ensureSamplesIsMutable();
                    samples_.set(index, value);
                    onChanged();
                }
                else
                {
                    samplesBuilder_.setMessage(index, value);
                }
                return this;
            }

            /**
             * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
             */
            public Builder setSamples(int index, Sample.Builder builderForValue)
            {
                if (samplesBuilder_ == null)
                {
                    ensureSamplesIsMutable();
                    samples_.set(index, builderForValue.build());
                    onChanged();
                }
                else
                {
                    samplesBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }

            /**
             * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
             */
            public Builder addSamples(Sample value)
            {
                if (samplesBuilder_ == null)
                {
                    if (value == null)
                    {
                        throw new NullPointerException();
                    }
                    ensureSamplesIsMutable();
                    samples_.add(value);
                    onChanged();
                }
                else
                {
                    samplesBuilder_.addMessage(value);
                }
                return this;
            }

            /**
             * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
             */
            public Builder addSamples(int index, Sample value)
            {
                if (samplesBuilder_ == null)
                {
                    if (value == null)
                    {
                        throw new NullPointerException();
                    }
                    ensureSamplesIsMutable();
                    samples_.add(index, value);
                    onChanged();
                }
                else
                {
                    samplesBuilder_.addMessage(index, value);
                }
                return this;
            }

            /**
             * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
             */
            public Builder addSamples(Sample.Builder builderForValue)
            {
                if (samplesBuilder_ == null)
                {
                    ensureSamplesIsMutable();
                    samples_.add(builderForValue.build());
                    onChanged();
                }
                else
                {
                    samplesBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }

            /**
             * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
             */
            public Builder addSamples(int index, Sample.Builder builderForValue)
            {
                if (samplesBuilder_ == null)
                {
                    ensureSamplesIsMutable();
                    samples_.add(index, builderForValue.build());
                    onChanged();
                }
                else
                {
                    samplesBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }

            /**
             * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
             */
            public Builder addAllSamples(Iterable<? extends Sample> values)
            {
                if (samplesBuilder_ == null)
                {
                    ensureSamplesIsMutable();
                    AbstractMessageLite.Builder.addAll( values, samples_);
                    onChanged();
                }
                else
                {
                    samplesBuilder_.addAllMessages(values);
                }
                return this;
            }

            /**
             * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
             */
            public Builder clearSamples()
            {
                if (samplesBuilder_ == null)
                {
                    samples_ = Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000001);
                    onChanged();
                }
                else
                {
                    samplesBuilder_.clear();
                }
                return this;
            }

            /**
             * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
             */
            public Builder removeSamples(int index)
            {
                if (samplesBuilder_ == null)
                {
                    ensureSamplesIsMutable();
                    samples_.remove(index);
                    onChanged();
                }
                else
                {
                    samplesBuilder_.remove(index);
                }
                return this;
            }

            /**
             * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
             */
            public Sample.Builder getSamplesBuilder(int index)
            {
                return getSamplesFieldBuilder().getBuilder(index);
            }

            /**
             * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
             */
            public SampleOrBuilder getSamplesOrBuilder( int index)
            {
                if (samplesBuilder_ == null)
                {
                    return samples_.get(index);
                }
                else
                {
                    return samplesBuilder_.getMessageOrBuilder(index);
                }
            }

            /**
             * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
             */
            public List<? extends SampleOrBuilder> getSamplesOrBuilderList()
            {
                if (samplesBuilder_ != null)
                {
                    return samplesBuilder_.getMessageOrBuilderList();
                }
                else
                {
                    return Collections.unmodifiableList(samples_);
                }
            }

            /**
             * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
             */
            public Sample.Builder addSamplesBuilder()
            {
                return getSamplesFieldBuilder().addBuilder(Sample.getDefaultInstance());
            }

            /**
             * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
             */
            public Sample.Builder addSamplesBuilder(int index)
            {
                return getSamplesFieldBuilder().addBuilder(index, Sample.getDefaultInstance());
            }

            /**
             * <code>repeated .sentencepiece.SelfTestData.Sample samples = 1;</code>
             */
            public List<Sample.Builder> getSamplesBuilderList()
            {
                return getSamplesFieldBuilder().getBuilderList();
            }

            private RepeatedFieldBuilder<Sample, Sample.Builder, SampleOrBuilder> getSamplesFieldBuilder()
            {
                if (samplesBuilder_ == null)
                {
                    samplesBuilder_ = new RepeatedFieldBuilder<>(
                            samples_,
                            ((bitField0_ & 0x00000001) != 0),
                            getParentForChildren(),
                            isClean());
                    samples_ = null;
                }
                return samplesBuilder_;
            }
        }

        private static final SelfTestData DEFAULT_INSTANCE;

        static
        {
            DEFAULT_INSTANCE = new SelfTestData();
        }

        public static SelfTestData getDefaultInstance()
        {
            return DEFAULT_INSTANCE;
        }

        private static final Parser<SelfTestData> PARSER = new AbstractParser<>()
        {
            @Override
            public SelfTestData parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
                    throws InvalidProtocolBufferException
            {
                Builder builder = newBuilder();
                try
                {
                    builder.mergeFrom(input, extensionRegistry);
                }
                catch (InvalidProtocolBufferException e)
                {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                }
                catch (UninitializedMessageException e)
                {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                }
                catch (IOException e)
                {
                    throw new InvalidProtocolBufferException(e)
                            .setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };

        public static Parser<SelfTestData> parser()
        {
            return PARSER;
        }

        @Override
        public Parser<SelfTestData> getParserForType()
        {
            return PARSER;
        }

        @Override
        public SelfTestData getDefaultInstanceForType()
        {
            return DEFAULT_INSTANCE;
        }
    }

    public interface ModelProtoOrBuilder extends GeneratedMessage.ExtendableMessageOrBuilder<ModelProto>
    {
        /**
         * <pre>
         * Sentence pieces with scores.
         * </pre>
         *
         * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
         */
        List<ModelProto.SentencePiece> getPiecesList();

        /**
         * <pre>
         * Sentence pieces with scores.
         * </pre>
         *
         * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
         */
        ModelProto.SentencePiece getPieces(int index);

        /**
         * <pre>
         * Sentence pieces with scores.
         * </pre>
         *
         * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
         */
        int getPiecesCount();

        /**
         * <pre>
         * Sentence pieces with scores.
         * </pre>
         *
         * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
         */
        List<? extends ModelProto.SentencePieceOrBuilder> getPiecesOrBuilderList();

        /**
         * <pre>
         * Sentence pieces with scores.
         * </pre>
         *
         * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
         */
        ModelProto.SentencePieceOrBuilder getPiecesOrBuilder(int index);

        /**
         * <pre>
         * Spec used to generate this model file.
         * </pre>
         *
         * <code>optional .sentencepiece.TrainerSpec trainer_spec = 2;</code>
         *
         * @return Whether the trainerSpec field is set.
         */
        boolean hasTrainerSpec();

        /**
         * <pre>
         * Spec used to generate this model file.
         * </pre>
         *
         * <code>optional .sentencepiece.TrainerSpec trainer_spec = 2;</code>
         *
         * @return The trainerSpec.
         */
        TrainerSpec getTrainerSpec();

        /**
         * <pre>
         * Spec used to generate this model file.
         * </pre>
         *
         * <code>optional .sentencepiece.TrainerSpec trainer_spec = 2;</code>
         */
        TrainerSpecOrBuilder getTrainerSpecOrBuilder();

        /**
         * <pre>
         * Spec for text normalization.
         * </pre>
         *
         * <code>optional .sentencepiece.NormalizerSpec normalizer_spec = 3;</code>
         *
         * @return Whether the normalizerSpec field is set.
         */
        boolean hasNormalizerSpec();

        /**
         * <pre>
         * Spec for text normalization.
         * </pre>
         *
         * <code>optional .sentencepiece.NormalizerSpec normalizer_spec = 3;</code>
         *
         * @return The normalizerSpec.
         */
        NormalizerSpec getNormalizerSpec();

        /**
         * <pre>
         * Spec for text normalization.
         * </pre>
         *
         * <code>optional .sentencepiece.NormalizerSpec normalizer_spec = 3;</code>
         */
        NormalizerSpecOrBuilder getNormalizerSpecOrBuilder();

        /**
         * <pre>
         * Stores sample input and its expected segmentation to verify the model.
         * </pre>
         *
         * <code>optional .sentencepiece.SelfTestData self_test_data = 4;</code>
         *
         * @return Whether the selfTestData field is set.
         */
        boolean hasSelfTestData();

        /**
         * <pre>
         * Stores sample input and its expected segmentation to verify the model.
         * </pre>
         *
         * <code>optional .sentencepiece.SelfTestData self_test_data = 4;</code>
         *
         * @return The selfTestData.
         */
        SelfTestData getSelfTestData();

        /**
         * <pre>
         * Stores sample input and its expected segmentation to verify the model.
         * </pre>
         *
         * <code>optional .sentencepiece.SelfTestData self_test_data = 4;</code>
         */
        SelfTestDataOrBuilder getSelfTestDataOrBuilder();

        /**
         * <pre>
         * Spec for text de-normalization.
         * </pre>
         *
         * <code>optional .sentencepiece.NormalizerSpec denormalizer_spec = 5;</code>
         *
         * @return Whether the denormalizerSpec field is set.
         */
        boolean hasDenormalizerSpec();

        /**
         * <pre>
         * Spec for text de-normalization.
         * </pre>
         *
         * <code>optional .sentencepiece.NormalizerSpec denormalizer_spec = 5;</code>
         *
         * @return The denormalizerSpec.
         */
        NormalizerSpec getDenormalizerSpec();

        /**
         * <pre>
         * Spec for text de-normalization.
         * </pre>
         *
         * <code>optional .sentencepiece.NormalizerSpec denormalizer_spec = 5;</code>
         */
        NormalizerSpecOrBuilder getDenormalizerSpecOrBuilder();
    }

    /**
     * <pre>
     * ModelProto stores model parameters.
     * SentencePieceProcessor is supposed to be self-contained.
     * All settings/parameters which may change the behavior must be encoded
     * in ModelProto.
     * </pre>
     * <p>
     * Protobuf type {@code sentencepiece.ModelProto}
     */
    public static final class ModelProto extends GeneratedMessage.ExtendableMessage<ModelProto>
            implements ModelProtoOrBuilder
    {
        @Serial
        private static final long serialVersionUID = 0L;

        static
        {
            RuntimeVersion.validateProtobufGencodeVersion(
                    RuntimeVersion.RuntimeDomain.PUBLIC,
                    /* major= */ 4,
                    /* minor= */ 26,
                    /* patch= */ 1,
                    /* suffix= */ "",
                    ModelProto.class.getName());
        }

        // Use ModelProto.newBuilder() to construct.
        private ModelProto(ExtendableBuilder<ModelProto, ?> builder)
        {
            super(builder);
        }

        private ModelProto()
        {
            pieces_ = Collections.emptyList();
        }

        public static Descriptors.Descriptor getDescriptor()
        {
            return internal_static_sentencepiece_ModelProto_descriptor;
        }

        @Override
        protected FieldAccessorTable internalGetFieldAccessorTable()
        {
            return internal_static_sentencepiece_ModelProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(ModelProto.class, Builder.class);
        }

        public interface SentencePieceOrBuilder extends ExtendableMessageOrBuilder<SentencePiece>
        {
            /**
             * <pre>
             * piece must not be empty.
             * </pre>
             *
             * <code>optional string piece = 1;</code>
             *
             * @return Whether the piece field is set.
             */
            boolean hasPiece();

            /**
             * <pre>
             * piece must not be empty.
             * </pre>
             *
             * <code>optional string piece = 1;</code>
             *
             * @return The piece.
             */
            String getPiece();

            /**
             * <pre>
             * piece must not be empty.
             * </pre>
             *
             * <code>optional string piece = 1;</code>
             *
             * @return The bytes for piece.
             */
            ByteString getPieceBytes();

            /**
             * <code>optional float score = 2;</code>
             *
             * @return Whether the score field is set.
             */
            boolean hasScore();

            /**
             * <code>optional float score = 2;</code>
             *
             * @return The score.
             */
            float getScore();

            /**
             * <code>optional .sentencepiece.ModelProto.SentencePiece.Type type = 3 [default = NORMAL];</code>
             *
             * @return Whether the type field is set.
             */
            boolean hasType();

            /**
             * <code>optional .sentencepiece.ModelProto.SentencePiece.Type type = 3 [default = NORMAL];</code>
             *
             * @return The type.
             */
            SentencePiece.Type getType();
        }

        /**
         * Protobuf type {@code sentencepiece.ModelProto.SentencePiece}
         */
        public static final class SentencePiece extends ExtendableMessage<SentencePiece>
                implements SentencePieceOrBuilder
        {
            @Serial
            private static final long serialVersionUID = 0L;

            static
            {
                RuntimeVersion.validateProtobufGencodeVersion(
                        RuntimeVersion.RuntimeDomain.PUBLIC,
                        /* major= */ 4,
                        /* minor= */ 26,
                        /* patch= */ 1,
                        /* suffix= */ "",
                        SentencePiece.class.getName());
            }

            // Use SentencePiece.newBuilder() to construct.
            private SentencePiece(ExtendableBuilder<SentencePiece, ?> builder)
            {
                super(builder);
            }

            private SentencePiece()
            {
                piece_ = "";
            }

            public static Descriptors.Descriptor getDescriptor()
            {
                return internal_static_sentencepiece_ModelProto_SentencePiece_descriptor;
            }

            @Override
            protected FieldAccessorTable internalGetFieldAccessorTable()
            {
                return internal_static_sentencepiece_ModelProto_SentencePiece_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(SentencePiece.class, Builder.class);
            }

            /**
             * Protobuf enum {@code sentencepiece.ModelProto.SentencePiece.Type}
             */
            public enum Type implements ProtocolMessageEnum
            {
                /**
                 * <pre>
                 * normal symbol
                 * </pre>
                 *
                 * <code>NORMAL = 1;</code>
                 */
                NORMAL(1),
                /**
                 * <pre>
                 * unknown symbol. only &lt;unk&gt; for now.
                 * </pre>
                 *
                 * <code>UNKNOWN = 2;</code>
                 */
                UNKNOWN(2),
                /**
                 * <pre>
                 * control symbols. &lt;/s&gt;, &lt;s&gt;, &lt;2ja&gt; etc.
                 * </pre>
                 *
                 * <code>CONTROL = 3;</code>
                 */
                CONTROL(3),
                /**
                 * <pre>
                 * user defined symbols.
                 * </pre>
                 *
                 * <code>USER_DEFINED = 4;</code>
                 */
                USER_DEFINED(4),
                /**
                 * <pre>
                 * Typical usage of USER_DEFINED symbol
                 * is placeholder.
                 * </pre>
                 *
                 * <code>BYTE = 6;</code>
                 */
                BYTE(6),
                /**
                 * <pre>
                 * this piece is not used.
                 * </pre>
                 *
                 * <code>UNUSED = 5;</code>
                 */
                UNUSED(5);

                static
                {
                    RuntimeVersion.validateProtobufGencodeVersion(
                            RuntimeVersion.RuntimeDomain.PUBLIC,
                            /* major= */ 4,
                            /* minor= */ 26,
                            /* patch= */ 1,
                            /* suffix= */ "",
                            Type.class.getName());
                }

                /**
                 * <pre>
                 * normal symbol
                 * </pre>
                 *
                 * <code>NORMAL = 1;</code>
                 */
                public static final int NORMAL_VALUE = 1;
                /**
                 * <pre>
                 * unknown symbol. only &lt;unk&gt; for now.
                 * </pre>
                 *
                 * <code>UNKNOWN = 2;</code>
                 */
                public static final int UNKNOWN_VALUE = 2;
                /**
                 * <pre>
                 * control symbols. &lt;/s&gt;, &lt;s&gt;, &lt;2ja&gt; etc.
                 * </pre>
                 *
                 * <code>CONTROL = 3;</code>
                 */
                public static final int CONTROL_VALUE = 3;
                /**
                 * <pre>
                 * user defined symbols.
                 * </pre>
                 *
                 * <code>USER_DEFINED = 4;</code>
                 */
                public static final int USER_DEFINED_VALUE = 4;
                /**
                 * <pre>
                 * Typical usage of USER_DEFINED symbol
                 * is placeholder.
                 * </pre>
                 *
                 * <code>BYTE = 6;</code>
                 */
                public static final int BYTE_VALUE = 6;
                /**
                 * <pre>
                 * this piece is not used.
                 * </pre>
                 *
                 * <code>UNUSED = 5;</code>
                 */
                public static final int UNUSED_VALUE = 5;

                public final int getNumber()
                {
                    return value;
                }

                /**
                 * @param value The numeric wire value of the corresponding enum entry.
                 * @return The enum associated with the given numeric wire value.
                 * @deprecated Use {@link #forNumber(int)} instead.
                 */
                @Deprecated
                public static Type valueOf(int value)
                {
                    return forNumber(value);
                }

                /**
                 * @param value The numeric wire value of the corresponding enum entry.
                 * @return The enum associated with the given numeric wire value.
                 */
                public static Type forNumber(int value)
                {
                    return switch (value)
                    {
                        case 1 -> NORMAL;
                        case 2 -> UNKNOWN;
                        case 3 -> CONTROL;
                        case 4 -> USER_DEFINED;
                        case 6 -> BYTE;
                        case 5 -> UNUSED;
                        default -> null;
                    };
                }

                public static Internal.EnumLiteMap<Type> internalGetValueMap()
                {
                    return internalValueMap;
                }

                private static final Internal.EnumLiteMap<Type> internalValueMap = Type::forNumber;

                public final Descriptors.EnumValueDescriptor getValueDescriptor()
                {
                    return getDescriptor().getValues().get(ordinal());
                }

                public final Descriptors.EnumDescriptor getDescriptorForType()
                {
                    return getDescriptor();
                }

                public static Descriptors.EnumDescriptor getDescriptor()
                {
                    return SentencePiece.getDescriptor().getEnumTypes().getFirst();
                }

                private static final Type[] VALUES = values();

                public static Type valueOf(Descriptors.EnumValueDescriptor desc)
                {
                    if (desc.getType() != getDescriptor())
                    {
                        throw new IllegalArgumentException(
                                "EnumValueDescriptor is not for this type.");
                    }
                    return VALUES[desc.getIndex()];
                }

                private final int value;

                Type(int value)
                {
                    this.value = value;
                }
            }

            private int bitField0_;
            public static final int PIECE_FIELD_NUMBER = 1;
            private volatile Object piece_ = "";

            /**
             * <pre>
             * piece must not be empty.
             * </pre>
             *
             * <code>optional string piece = 1;</code>
             *
             * @return Whether the piece field is set.
             */
            @Override
            public boolean hasPiece()
            {
                return ((bitField0_ & 0x00000001) != 0);
            }

            /**
             * <pre>
             * piece must not be empty.
             * </pre>
             *
             * <code>optional string piece = 1;</code>
             *
             * @return The piece.
             */
            @Override
            public String getPiece()
            {
                Object ref = piece_;
                if (ref instanceof String)
                {
                    return (String) ref;
                }
                else
                {
                    ByteString bs = (ByteString) ref;
                    String s = bs.toStringUtf8();
                    if (bs.isValidUtf8())
                    {
                        piece_ = s;
                    }
                    return s;
                }
            }

            /**
             * <pre>
             * piece must not be empty.
             * </pre>
             *
             * <code>optional string piece = 1;</code>
             *
             * @return The bytes for piece.
             */
            @Override
            public ByteString
            getPieceBytes()
            {
                Object ref = piece_;
                if (ref instanceof String)
                {
                    ByteString b = ByteString.copyFromUtf8((String) ref);
                    piece_ = b;
                    return b;
                }
                else
                {
                    return (ByteString) ref;
                }
            }

            public static final int SCORE_FIELD_NUMBER = 2;
            private float score_ = 0F;

            /**
             * <code>optional float score = 2;</code>
             *
             * @return Whether the score field is set.
             */
            @Override
            public boolean hasScore()
            {
                return ((bitField0_ & 0x00000002) != 0);
            }

            /**
             * <code>optional float score = 2;</code>
             *
             * @return The score.
             */
            @Override
            public float getScore()
            {
                return score_;
            }

            public static final int TYPE_FIELD_NUMBER = 3;
            private int type_ = 1;

            /**
             * <code>optional .sentencepiece.ModelProto.SentencePiece.Type type = 3 [default = NORMAL];</code>
             *
             * @return Whether the type field is set.
             */
            @Override
            public boolean hasType()
            {
                return ((bitField0_ & 0x00000004) != 0);
            }

            /**
             * <code>optional .sentencepiece.ModelProto.SentencePiece.Type type = 3 [default = NORMAL];</code>
             *
             * @return The type.
             */
            @Override
            public Type getType()
            {
                Type result = Type.forNumber(type_);
                return result == null ? Type.NORMAL : result;
            }

            private byte memoizedIsInitialized = -1;

            @Override
            public boolean isInitialized()
            {
                byte isInitialized = memoizedIsInitialized;
                if (isInitialized == 1) return true;
                if (isInitialized == 0) return false;

                if (!extensionsAreInitialized())
                {
                    memoizedIsInitialized = 0;
                    return false;
                }
                memoizedIsInitialized = 1;
                return true;
            }

            @Override
            public void writeTo(CodedOutputStream output) throws IOException
            {
                ExtendableMessage<ModelProto.SentencePiece>.ExtensionWriter extensionWriter = newExtensionWriter();
                if (((bitField0_ & 0x00000001) != 0))
                {
                    GeneratedMessage.writeString(output, 1, piece_);
                }
                if (((bitField0_ & 0x00000002) != 0))
                {
                    output.writeFloat(2, score_);
                }
                if (((bitField0_ & 0x00000004) != 0))
                {
                    output.writeEnum(3, type_);
                }
                extensionWriter.writeUntil(536870912, output);
                getUnknownFields().writeTo(output);
            }

            @Override
            public int getSerializedSize()
            {
                int size = memoizedSize;
                if (size != -1) return size;

                size = 0;
                if (((bitField0_ & 0x00000001) != 0))
                {
                    size += GeneratedMessage.computeStringSize(1, piece_);
                }
                if (((bitField0_ & 0x00000002) != 0))
                {
                    size += CodedOutputStream.computeFloatSize(2, score_);
                }
                if (((bitField0_ & 0x00000004) != 0))
                {
                    size += CodedOutputStream.computeEnumSize(3, type_);
                }
                size += extensionsSerializedSize();
                size += getUnknownFields().getSerializedSize();
                memoizedSize = size;
                return size;
            }

            @Override
            public boolean equals(final Object obj)
            {
                if (obj == this)
                {
                    return true;
                }
                if (!(obj instanceof SentencePiece other))
                {
                    return super.equals(obj);
                }

                if (hasPiece() != other.hasPiece()) return false;
                if (hasPiece())
                {
                    if (!getPiece().equals(other.getPiece())) return false;
                }
                if (hasScore() != other.hasScore()) return false;
                if (hasScore())
                {
                    if (Float.floatToIntBits(getScore()) != Float.floatToIntBits(other.getScore())) return false;
                }
                if (hasType() != other.hasType()) return false;
                if (hasType())
                {
                    if (type_ != other.type_) return false;
                }
                if (!getUnknownFields().equals(other.getUnknownFields())) return false;
                return getExtensionFields().equals(other.getExtensionFields());
            }

            @Override
            public int hashCode()
            {
                if (memoizedHashCode != 0)
                {
                    return memoizedHashCode;
                }
                int hash = 41;
                hash = (19 * hash) + getDescriptor().hashCode();
                if (hasPiece())
                {
                    hash = (37 * hash) + PIECE_FIELD_NUMBER;
                    hash = (53 * hash) + getPiece().hashCode();
                }
                if (hasScore())
                {
                    hash = (37 * hash) + SCORE_FIELD_NUMBER;
                    hash = (53 * hash) + Float.floatToIntBits(getScore());
                }
                if (hasType())
                {
                    hash = (37 * hash) + TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + type_;
                }
                hash = hashFields(hash, getExtensionFields());
                hash = (29 * hash) + getUnknownFields().hashCode();
                memoizedHashCode = hash;
                return hash;
            }

            public static SentencePiece parseFrom(ByteBuffer data) throws InvalidProtocolBufferException
            {
                return PARSER.parseFrom(data);
            }

            public static SentencePiece parseFrom(ByteBuffer data, ExtensionRegistryLite extensionRegistry)
                    throws InvalidProtocolBufferException
            {
                return PARSER.parseFrom(data, extensionRegistry);
            }

            public static SentencePiece parseFrom(ByteString data) throws InvalidProtocolBufferException
            {
                return PARSER.parseFrom(data);
            }

            public static SentencePiece parseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
                    throws InvalidProtocolBufferException
            {
                return PARSER.parseFrom(data, extensionRegistry);
            }

            public static SentencePiece parseFrom(byte[] data) throws InvalidProtocolBufferException
            {
                return PARSER.parseFrom(data);
            }

            public static SentencePiece parseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
                    throws InvalidProtocolBufferException
            {
                return PARSER.parseFrom(data, extensionRegistry);
            }

            public static SentencePiece parseFrom(InputStream input) throws IOException
            {
                return GeneratedMessage.parseWithIOException(PARSER, input);
            }

            public static SentencePiece parseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
                    throws IOException
            {
                return GeneratedMessage.parseWithIOException(PARSER, input, extensionRegistry);
            }

            public static SentencePiece parseDelimitedFrom(InputStream input) throws IOException
            {
                return GeneratedMessage.parseDelimitedWithIOException(PARSER, input);
            }

            public static SentencePiece parseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
                    throws IOException
            {
                return GeneratedMessage.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
            }

            public static SentencePiece parseFrom(CodedInputStream input) throws IOException
            {
                return GeneratedMessage.parseWithIOException(PARSER, input);
            }

            public static SentencePiece parseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
                    throws IOException
            {
                return GeneratedMessage.parseWithIOException(PARSER, input, extensionRegistry);
            }

            @Override
            public Builder newBuilderForType()
            {
                return newBuilder();
            }

            public static Builder newBuilder()
            {
                return DEFAULT_INSTANCE.toBuilder();
            }

            public static Builder newBuilder(SentencePiece prototype)
            {
                return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
            }

            @Override
            public Builder toBuilder()
            {
                return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
            }

            @Override
            protected Builder newBuilderForType(BuilderParent parent)
            {
                return new Builder(parent);
            }

            /**
             * Protobuf type {@code sentencepiece.ModelProto.SentencePiece}
             */
            public static final class Builder extends ExtendableBuilder<SentencePiece, Builder>
                    implements SentencePieceOrBuilder
            {
                public static Descriptors.Descriptor getDescriptor()
                {
                    return internal_static_sentencepiece_ModelProto_SentencePiece_descriptor;
                }

                @Override
                protected FieldAccessorTable internalGetFieldAccessorTable()
                {
                    return internal_static_sentencepiece_ModelProto_SentencePiece_fieldAccessorTable
                            .ensureFieldAccessorsInitialized(SentencePiece.class, Builder.class);
                }

                // Construct using ModelProto.SentencePiece.newBuilder()
                private Builder()
                {
                }

                private Builder(BuilderParent parent)
                {
                    super(parent);
                }

                @Override
                public Builder clear()
                {
                    super.clear();
                    bitField0_ = 0;
                    piece_ = "";
                    score_ = 0F;
                    type_ = 1;
                    return this;
                }

                @Override
                public Descriptors.Descriptor getDescriptorForType()
                {
                    return internal_static_sentencepiece_ModelProto_SentencePiece_descriptor;
                }

                @Override
                public SentencePiece getDefaultInstanceForType()
                {
                    return SentencePiece.getDefaultInstance();
                }

                @Override
                public SentencePiece build()
                {
                    SentencePiece result = buildPartial();
                    if (!result.isInitialized())
                    {
                        throw newUninitializedMessageException(result);
                    }
                    return result;
                }

                @Override
                public SentencePiece buildPartial()
                {
                    SentencePiece result = new SentencePiece(this);
                    if (bitField0_ != 0)
                    {
                        buildPartial0(result);
                    }
                    onBuilt();
                    return result;
                }

                private void buildPartial0(SentencePiece result)
                {
                    int from_bitField0_ = bitField0_;
                    int to_bitField0_ = 0;
                    if (((from_bitField0_ & 0x00000001) != 0))
                    {
                        result.piece_ = piece_;
                        to_bitField0_ |= 0x00000001;
                    }
                    if (((from_bitField0_ & 0x00000002) != 0))
                    {
                        result.score_ = score_;
                        to_bitField0_ |= 0x00000002;
                    }
                    if (((from_bitField0_ & 0x00000004) != 0))
                    {
                        result.type_ = type_;
                        to_bitField0_ |= 0x00000004;
                    }
                    result.bitField0_ |= to_bitField0_;
                }

                @Override
                public Builder mergeFrom(Message other)
                {
                    if (other instanceof SentencePiece)
                    {
                        return mergeFrom((SentencePiece) other);
                    }
                    else
                    {
                        super.mergeFrom(other);
                        return this;
                    }
                }

                public Builder mergeFrom(SentencePiece other)
                {
                    if (other == SentencePiece.getDefaultInstance()) return this;
                    if (other.hasPiece())
                    {
                        piece_ = other.piece_;
                        bitField0_ |= 0x00000001;
                        onChanged();
                    }
                    if (other.hasScore())
                    {
                        setScore(other.getScore());
                    }
                    if (other.hasType())
                    {
                        setType(other.getType());
                    }
                    this.mergeExtensionFields(other);
                    this.mergeUnknownFields(other.getUnknownFields());
                    onChanged();
                    return this;
                }

                @Override
                public boolean isInitialized()
                {
                    return extensionsAreInitialized();
                }

                @Override
                public Builder mergeFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
                        throws IOException
                {
                    if (extensionRegistry == null)
                    {
                        throw new NullPointerException();
                    }
                    try
                    {
                        boolean done = false;
                        while (!done)
                        {
                            int tag = input.readTag();
                            switch (tag)
                            {
                                case 0:
                                    done = true;
                                    break;
                                case 10:
                                {
                                    piece_ = input.readBytes();
                                    bitField0_ |= 0x00000001;
                                    break;
                                } // case 10
                                case 21:
                                {
                                    score_ = input.readFloat();
                                    bitField0_ |= 0x00000002;
                                    break;
                                } // case 21
                                case 24:
                                {
                                    int tmpRaw = input.readEnum();
                                    Type tmpValue = Type.forNumber(tmpRaw);
                                    if (tmpValue == null)
                                    {
                                        mergeUnknownVarintField(3, tmpRaw);
                                    }
                                    else
                                    {
                                        type_ = tmpRaw;
                                        bitField0_ |= 0x00000004;
                                    }
                                    break;
                                } // case 24
                                default:
                                {
                                    if (!super.parseUnknownField(input, extensionRegistry, tag))
                                    {
                                        done = true; // was an endgroup tag
                                    }
                                    break;
                                } // default:
                            } // switch (tag)
                        } // while (!done)
                    }
                    catch (InvalidProtocolBufferException e)
                    {
                        throw e.unwrapIOException();
                    }
                    finally
                    {
                        onChanged();
                    } // finally
                    return this;
                }

                private int bitField0_;

                private Object piece_ = "";

                /**
                 * <pre>
                 * piece must not be empty.
                 * </pre>
                 *
                 * <code>optional string piece = 1;</code>
                 *
                 * @return Whether the piece field is set.
                 */
                public boolean hasPiece()
                {
                    return ((bitField0_ & 0x00000001) != 0);
                }

                /**
                 * <pre>
                 * piece must not be empty.
                 * </pre>
                 *
                 * <code>optional string piece = 1;</code>
                 *
                 * @return The piece.
                 */
                public String getPiece()
                {
                    Object ref = piece_;
                    if (!(ref instanceof String))
                    {
                        ByteString bs = (ByteString) ref;
                        String s = bs.toStringUtf8();
                        if (bs.isValidUtf8())
                        {
                            piece_ = s;
                        }
                        return s;
                    }
                    else
                    {
                        return (String) ref;
                    }
                }

                /**
                 * <pre>
                 * piece must not be empty.
                 * </pre>
                 *
                 * <code>optional string piece = 1;</code>
                 *
                 * @return The bytes for piece.
                 */
                public ByteString
                getPieceBytes()
                {
                    Object ref = piece_;
                    if (ref instanceof String)
                    {
                        ByteString b = ByteString.copyFromUtf8((String) ref);
                        piece_ = b;
                        return b;
                    }
                    else
                    {
                        return (ByteString) ref;
                    }
                }

                /**
                 * <pre>
                 * piece must not be empty.
                 * </pre>
                 *
                 * <code>optional string piece = 1;</code>
                 *
                 * @param value The piece to set.
                 * @return This builder for chaining.
                 */
                public Builder setPiece(String value)
                {
                    if (value == null)
                    {
                        throw new NullPointerException();
                    }
                    piece_ = value;
                    bitField0_ |= 0x00000001;
                    onChanged();
                    return this;
                }

                /**
                 * <pre>
                 * piece must not be empty.
                 * </pre>
                 *
                 * <code>optional string piece = 1;</code>
                 *
                 * @return This builder for chaining.
                 */
                public Builder clearPiece()
                {
                    piece_ = getDefaultInstance().getPiece();
                    bitField0_ = (bitField0_ & ~0x00000001);
                    onChanged();
                    return this;
                }

                /**
                 * <pre>
                 * piece must not be empty.
                 * </pre>
                 *
                 * <code>optional string piece = 1;</code>
                 *
                 * @param value The bytes for piece to set.
                 * @return This builder for chaining.
                 */
                public Builder setPieceBytes(ByteString value)
                {
                    if (value == null)
                    {
                        throw new NullPointerException();
                    }
                    piece_ = value;
                    bitField0_ |= 0x00000001;
                    onChanged();
                    return this;
                }

                private float score_;

                /**
                 * <code>optional float score = 2;</code>
                 *
                 * @return Whether the score field is set.
                 */
                @Override
                public boolean hasScore()
                {
                    return ((bitField0_ & 0x00000002) != 0);
                }

                /**
                 * <code>optional float score = 2;</code>
                 *
                 * @return The score.
                 */
                @Override
                public float getScore()
                {
                    return score_;
                }

                /**
                 * <code>optional float score = 2;</code>
                 *
                 * @param value The score to set.
                 * @return This builder for chaining.
                 */
                public Builder setScore(float value)
                {

                    score_ = value;
                    bitField0_ |= 0x00000002;
                    onChanged();
                    return this;
                }

                /**
                 * <code>optional float score = 2;</code>
                 *
                 * @return This builder for chaining.
                 */
                public Builder clearScore()
                {
                    bitField0_ = (bitField0_ & ~0x00000002);
                    score_ = 0F;
                    onChanged();
                    return this;
                }

                private int type_ = 1;

                /**
                 * <code>optional .sentencepiece.ModelProto.SentencePiece.Type type = 3 [default = NORMAL];</code>
                 *
                 * @return Whether the type field is set.
                 */
                @Override
                public boolean hasType()
                {
                    return ((bitField0_ & 0x00000004) != 0);
                }

                /**
                 * <code>optional .sentencepiece.ModelProto.SentencePiece.Type type = 3 [default = NORMAL];</code>
                 *
                 * @return The type.
                 */
                @Override
                public Type getType()
                {
                    Type result = Type.forNumber(type_);
                    return result == null ? Type.NORMAL : result;
                }

                /**
                 * <code>optional .sentencepiece.ModelProto.SentencePiece.Type type = 3 [default = NORMAL];</code>
                 *
                 * @param value The type to set.
                 * @return This builder for chaining.
                 */
                public Builder setType(Type value)
                {
                    if (value == null)
                    {
                        throw new NullPointerException();
                    }
                    bitField0_ |= 0x00000004;
                    type_ = value.getNumber();
                    onChanged();
                    return this;
                }

                /**
                 * <code>optional .sentencepiece.ModelProto.SentencePiece.Type type = 3 [default = NORMAL];</code>
                 *
                 * @return This builder for chaining.
                 */
                public Builder clearType()
                {
                    bitField0_ = (bitField0_ & ~0x00000004);
                    type_ = 1;
                    onChanged();
                    return this;
                }

                // @@protoc_insertion_point(builder_scope:sentencepiece.ModelProto.SentencePiece)
            }

            // @@protoc_insertion_point(class_scope:sentencepiece.ModelProto.SentencePiece)
            private static final SentencePiece DEFAULT_INSTANCE;

            static
            {
                DEFAULT_INSTANCE = new SentencePiece();
            }

            public static SentencePiece getDefaultInstance()
            {
                return DEFAULT_INSTANCE;
            }

            private static final Parser<SentencePiece> PARSER = new AbstractParser<>()
            {
                @Override
                public SentencePiece parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
                        throws InvalidProtocolBufferException
                {
                    Builder builder = newBuilder();
                    try
                    {
                        builder.mergeFrom(input, extensionRegistry);
                    }
                    catch (InvalidProtocolBufferException e)
                    {
                        throw e.setUnfinishedMessage(builder.buildPartial());
                    }
                    catch (UninitializedMessageException e)
                    {
                        throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                    }
                    catch (IOException e)
                    {
                        throw new InvalidProtocolBufferException(e)
                                .setUnfinishedMessage(builder.buildPartial());
                    }
                    return builder.buildPartial();
                }
            };

            public static Parser<SentencePiece> parser()
            {
                return PARSER;
            }

            @Override
            public Parser<SentencePiece> getParserForType()
            {
                return PARSER;
            }

            @Override
            public SentencePiece getDefaultInstanceForType()
            {
                return DEFAULT_INSTANCE;
            }
        }

        private int bitField0_;
        public static final int PIECES_FIELD_NUMBER = 1;
        private List<SentencePiece> pieces_;

        /**
         * <pre>
         * Sentence pieces with scores.
         * </pre>
         *
         * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
         */
        @Override
        public List<SentencePiece> getPiecesList()
        {
            return pieces_;
        }

        /**
         * <pre>
         * Sentence pieces with scores.
         * </pre>
         *
         * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
         */
        @Override
        public List<? extends SentencePieceOrBuilder> getPiecesOrBuilderList()
        {
            return pieces_;
        }

        /**
         * <pre>
         * Sentence pieces with scores.
         * </pre>
         *
         * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
         */
        @Override
        public int getPiecesCount()
        {
            return pieces_.size();
        }

        /**
         * <pre>
         * Sentence pieces with scores.
         * </pre>
         *
         * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
         */
        @Override
        public SentencePiece getPieces(int index)
        {
            return pieces_.get(index);
        }

        /**
         * <pre>
         * Sentence pieces with scores.
         * </pre>
         *
         * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
         */
        @Override
        public SentencePieceOrBuilder getPiecesOrBuilder(int index)
        {
            return pieces_.get(index);
        }

        public static final int TRAINER_SPEC_FIELD_NUMBER = 2;
        private TrainerSpec trainerSpec_;

        /**
         * <pre>
         * Spec used to generate this model file.
         * </pre>
         *
         * <code>optional .sentencepiece.TrainerSpec trainer_spec = 2;</code>
         *
         * @return Whether the trainerSpec field is set.
         */
        @Override
        public boolean hasTrainerSpec()
        {
            return ((bitField0_ & 0x00000001) != 0);
        }

        /**
         * <pre>
         * Spec used to generate this model file.
         * </pre>
         *
         * <code>optional .sentencepiece.TrainerSpec trainer_spec = 2;</code>
         *
         * @return The trainerSpec.
         */
        @Override
        public TrainerSpec getTrainerSpec()
        {
            return trainerSpec_ == null ? TrainerSpec.getDefaultInstance() : trainerSpec_;
        }

        /**
         * <pre>
         * Spec used to generate this model file.
         * </pre>
         *
         * <code>optional .sentencepiece.TrainerSpec trainer_spec = 2;</code>
         */
        @Override
        public TrainerSpecOrBuilder getTrainerSpecOrBuilder()
        {
            return trainerSpec_ == null ? TrainerSpec.getDefaultInstance() : trainerSpec_;
        }

        public static final int NORMALIZER_SPEC_FIELD_NUMBER = 3;
        private NormalizerSpec normalizerSpec_;

        /**
         * <pre>
         * Spec for text normalization.
         * </pre>
         *
         * <code>optional .sentencepiece.NormalizerSpec normalizer_spec = 3;</code>
         *
         * @return Whether the normalizerSpec field is set.
         */
        @Override
        public boolean hasNormalizerSpec()
        {
            return ((bitField0_ & 0x00000002) != 0);
        }

        /**
         * <pre>
         * Spec for text normalization.
         * </pre>
         *
         * <code>optional .sentencepiece.NormalizerSpec normalizer_spec = 3;</code>
         *
         * @return The normalizerSpec.
         */
        @Override
        public NormalizerSpec getNormalizerSpec()
        {
            return normalizerSpec_ == null ? NormalizerSpec.getDefaultInstance() : normalizerSpec_;
        }

        /**
         * <pre>
         * Spec for text normalization.
         * </pre>
         *
         * <code>optional .sentencepiece.NormalizerSpec normalizer_spec = 3;</code>
         */
        @Override
        public NormalizerSpecOrBuilder getNormalizerSpecOrBuilder()
        {
            return normalizerSpec_ == null ? NormalizerSpec.getDefaultInstance() : normalizerSpec_;
        }

        public static final int SELF_TEST_DATA_FIELD_NUMBER = 4;
        private SelfTestData selfTestData_;

        /**
         * <pre>
         * Stores sample input and its expected segmentation to verify the model.
         * </pre>
         *
         * <code>optional .sentencepiece.SelfTestData self_test_data = 4;</code>
         *
         * @return Whether the selfTestData field is set.
         */
        @Override
        public boolean hasSelfTestData()
        {
            return ((bitField0_ & 0x00000004) != 0);
        }

        /**
         * <pre>
         * Stores sample input and its expected segmentation to verify the model.
         * </pre>
         *
         * <code>optional .sentencepiece.SelfTestData self_test_data = 4;</code>
         *
         * @return The selfTestData.
         */
        @Override
        public SelfTestData getSelfTestData()
        {
            return selfTestData_ == null ? SelfTestData.getDefaultInstance() : selfTestData_;
        }

        /**
         * <pre>
         * Stores sample input and its expected segmentation to verify the model.
         * </pre>
         *
         * <code>optional .sentencepiece.SelfTestData self_test_data = 4;</code>
         */
        @Override
        public SelfTestDataOrBuilder getSelfTestDataOrBuilder()
        {
            return selfTestData_ == null ? SelfTestData.getDefaultInstance() : selfTestData_;
        }

        public static final int DENORMALIZER_SPEC_FIELD_NUMBER = 5;
        private NormalizerSpec denormalizerSpec_;

        /**
         * <pre>
         * Spec for text de-normalization.
         * </pre>
         *
         * <code>optional .sentencepiece.NormalizerSpec denormalizer_spec = 5;</code>
         *
         * @return Whether the denormalizerSpec field is set.
         */
        @Override
        public boolean hasDenormalizerSpec()
        {
            return ((bitField0_ & 0x00000008) != 0);
        }

        /**
         * <pre>
         * Spec for text de-normalization.
         * </pre>
         *
         * <code>optional .sentencepiece.NormalizerSpec denormalizer_spec = 5;</code>
         *
         * @return The denormalizerSpec.
         */
        @Override
        public NormalizerSpec getDenormalizerSpec()
        {
            return denormalizerSpec_ == null ? NormalizerSpec.getDefaultInstance() : denormalizerSpec_;
        }

        /**
         * <pre>
         * Spec for text de-normalization.
         * </pre>
         *
         * <code>optional .sentencepiece.NormalizerSpec denormalizer_spec = 5;</code>
         */
        @Override
        public NormalizerSpecOrBuilder getDenormalizerSpecOrBuilder()
        {
            return denormalizerSpec_ == null ? NormalizerSpec.getDefaultInstance() : denormalizerSpec_;
        }

        private byte memoizedIsInitialized = -1;

        @Override
        public boolean isInitialized()
        {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;

            for (int i = 0; i < getPiecesCount(); i++)
            {
                if (!getPieces(i).isInitialized())
                {
                    memoizedIsInitialized = 0;
                    return false;
                }
            }
            if (hasTrainerSpec())
            {
                if (!getTrainerSpec().isInitialized())
                {
                    memoizedIsInitialized = 0;
                    return false;
                }
            }
            if (hasNormalizerSpec())
            {
                if (!getNormalizerSpec().isInitialized())
                {
                    memoizedIsInitialized = 0;
                    return false;
                }
            }
            if (hasSelfTestData())
            {
                if (!getSelfTestData().isInitialized())
                {
                    memoizedIsInitialized = 0;
                    return false;
                }
            }
            if (hasDenormalizerSpec())
            {
                if (!getDenormalizerSpec().isInitialized())
                {
                    memoizedIsInitialized = 0;
                    return false;
                }
            }
            if (!extensionsAreInitialized())
            {
                memoizedIsInitialized = 0;
                return false;
            }
            memoizedIsInitialized = 1;
            return true;
        }

        @Override
        public void writeTo(CodedOutputStream output) throws IOException
        {
            ExtendableMessage<ModelProto>.ExtensionWriter extensionWriter = newExtensionWriter();
            for (SentencePiece sentencePiece : pieces_)
            {
                output.writeMessage(1, sentencePiece);
            }
            if (((bitField0_ & 0x00000001) != 0))
            {
                output.writeMessage(2, getTrainerSpec());
            }
            if (((bitField0_ & 0x00000002) != 0))
            {
                output.writeMessage(3, getNormalizerSpec());
            }
            if (((bitField0_ & 0x00000004) != 0))
            {
                output.writeMessage(4, getSelfTestData());
            }
            if (((bitField0_ & 0x00000008) != 0))
            {
                output.writeMessage(5, getDenormalizerSpec());
            }
            extensionWriter.writeUntil(536870912, output);
            getUnknownFields().writeTo(output);
        }

        @Override
        public int getSerializedSize()
        {
            int size = memoizedSize;
            if (size != -1) return size;

            size = 0;
            for (SentencePiece sentencePiece : pieces_)
            {
                size += CodedOutputStream.computeMessageSize(1, sentencePiece);
            }
            if (((bitField0_ & 0x00000001) != 0))
            {
                size += CodedOutputStream.computeMessageSize(2, getTrainerSpec());
            }
            if (((bitField0_ & 0x00000002) != 0))
            {
                size += CodedOutputStream.computeMessageSize(3, getNormalizerSpec());
            }
            if (((bitField0_ & 0x00000004) != 0))
            {
                size += CodedOutputStream.computeMessageSize(4, getSelfTestData());
            }
            if (((bitField0_ & 0x00000008) != 0))
            {
                size += CodedOutputStream.computeMessageSize(5, getDenormalizerSpec());
            }
            size += extensionsSerializedSize();
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
        }

        @Override
        public boolean equals(final Object obj)
        {
            if (obj == this)
            {
                return true;
            }
            if (!(obj instanceof ModelProto other))
            {
                return super.equals(obj);
            }

            if (!getPiecesList().equals(other.getPiecesList())) return false;
            if (hasTrainerSpec() != other.hasTrainerSpec()) return false;
            if (hasTrainerSpec())
            {
                if (!getTrainerSpec().equals(other.getTrainerSpec())) return false;
            }
            if (hasNormalizerSpec() != other.hasNormalizerSpec()) return false;
            if (hasNormalizerSpec())
            {
                if (!getNormalizerSpec().equals(other.getNormalizerSpec())) return false;
            }
            if (hasSelfTestData() != other.hasSelfTestData()) return false;
            if (hasSelfTestData())
            {
                if (!getSelfTestData().equals(other.getSelfTestData())) return false;
            }
            if (hasDenormalizerSpec() != other.hasDenormalizerSpec()) return false;
            if (hasDenormalizerSpec())
            {
                if (!getDenormalizerSpec().equals(other.getDenormalizerSpec())) return false;
            }
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return getExtensionFields().equals(other.getExtensionFields());
        }

        @Override
        public int hashCode()
        {
            if (memoizedHashCode != 0)
            {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (getPiecesCount() > 0)
            {
                hash = (37 * hash) + PIECES_FIELD_NUMBER;
                hash = (53 * hash) + getPiecesList().hashCode();
            }
            if (hasTrainerSpec())
            {
                hash = (37 * hash) + TRAINER_SPEC_FIELD_NUMBER;
                hash = (53 * hash) + getTrainerSpec().hashCode();
            }
            if (hasNormalizerSpec())
            {
                hash = (37 * hash) + NORMALIZER_SPEC_FIELD_NUMBER;
                hash = (53 * hash) + getNormalizerSpec().hashCode();
            }
            if (hasSelfTestData())
            {
                hash = (37 * hash) + SELF_TEST_DATA_FIELD_NUMBER;
                hash = (53 * hash) + getSelfTestData().hashCode();
            }
            if (hasDenormalizerSpec())
            {
                hash = (37 * hash) + DENORMALIZER_SPEC_FIELD_NUMBER;
                hash = (53 * hash) + getDenormalizerSpec().hashCode();
            }
            hash = hashFields(hash, getExtensionFields());
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
        }

        public static ModelProto parseFrom(ByteBuffer data) throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data);
        }

        public static ModelProto parseFrom(ByteBuffer data, ExtensionRegistryLite extensionRegistry)
                throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data, extensionRegistry);
        }

        public static ModelProto parseFrom(ByteString data) throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data);
        }

        public static ModelProto parseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
                throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data, extensionRegistry);
        }

        public static ModelProto parseFrom(byte[] data) throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data);
        }

        public static ModelProto parseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
                throws InvalidProtocolBufferException
        {
            return PARSER.parseFrom(data, extensionRegistry);
        }

        public static ModelProto parseFrom(InputStream input) throws IOException
        {
            return GeneratedMessage.parseWithIOException(PARSER, input);
        }

        public static ModelProto parseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
                throws IOException
        {
            return GeneratedMessage.parseWithIOException(PARSER, input, extensionRegistry);
        }

        public static ModelProto parseDelimitedFrom(InputStream input) throws IOException
        {
            return GeneratedMessage.parseDelimitedWithIOException(PARSER, input);
        }

        public static ModelProto parseDelimitedFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
                throws IOException
        {
            return GeneratedMessage.parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }

        public static ModelProto parseFrom(CodedInputStream input) throws IOException
        {
            return GeneratedMessage.parseWithIOException(PARSER, input);
        }

        public static ModelProto parseFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
                throws IOException
        {
            return GeneratedMessage.parseWithIOException(PARSER, input, extensionRegistry);
        }

        @Override
        public Builder newBuilderForType()
        {
            return newBuilder();
        }

        public static Builder newBuilder()
        {
            return DEFAULT_INSTANCE.toBuilder();
        }

        public static Builder newBuilder(ModelProto prototype)
        {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }

        @Override
        public Builder toBuilder()
        {
            return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
        }

        @Override
        protected Builder newBuilderForType(BuilderParent parent)
        {
            return new Builder(parent);
        }

        /**
         * <pre>
         * ModelProto stores model parameters.
         * SentencePieceProcessor is supposed to be self-contained.
         * All settings/parameters which may change the behavior must be encoded
         * in ModelProto.
         * </pre>
         * <p>
         * Protobuf type {@code sentencepiece.ModelProto}
         */
        public static final class Builder extends ExtendableBuilder<ModelProto, Builder> implements ModelProtoOrBuilder
        {
            public static Descriptors.Descriptor getDescriptor()
            {
                return internal_static_sentencepiece_ModelProto_descriptor;
            }

            @Override
            protected FieldAccessorTable internalGetFieldAccessorTable()
            {
                return internal_static_sentencepiece_ModelProto_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(ModelProto.class, Builder.class);
            }

            // Construct using ModelProto.newBuilder()
            private Builder()
            {
                maybeForceBuilderInitialization();
            }

            private Builder(BuilderParent parent)
            {
                super(parent);
                maybeForceBuilderInitialization();
            }

            private void maybeForceBuilderInitialization()
            {
                if (GeneratedMessage.alwaysUseFieldBuilders)
                {
                    getPiecesFieldBuilder();
                    getTrainerSpecFieldBuilder();
                    getNormalizerSpecFieldBuilder();
                    getSelfTestDataFieldBuilder();
                    getDenormalizerSpecFieldBuilder();
                }
            }

            @Override
            public Builder clear()
            {
                super.clear();
                bitField0_ = 0;
                if (piecesBuilder_ == null)
                {
                    pieces_ = Collections.emptyList();
                }
                else
                {
                    pieces_ = null;
                    piecesBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000001);
                trainerSpec_ = null;
                if (trainerSpecBuilder_ != null)
                {
                    trainerSpecBuilder_.dispose();
                    trainerSpecBuilder_ = null;
                }
                normalizerSpec_ = null;
                if (normalizerSpecBuilder_ != null)
                {
                    normalizerSpecBuilder_.dispose();
                    normalizerSpecBuilder_ = null;
                }
                selfTestData_ = null;
                if (selfTestDataBuilder_ != null)
                {
                    selfTestDataBuilder_.dispose();
                    selfTestDataBuilder_ = null;
                }
                denormalizerSpec_ = null;
                if (denormalizerSpecBuilder_ != null)
                {
                    denormalizerSpecBuilder_.dispose();
                    denormalizerSpecBuilder_ = null;
                }
                return this;
            }

            @Override
            public Descriptors.Descriptor
            getDescriptorForType()
            {
                return internal_static_sentencepiece_ModelProto_descriptor;
            }

            @Override
            public ModelProto getDefaultInstanceForType()
            {
                return ModelProto.getDefaultInstance();
            }

            @Override
            public ModelProto build()
            {
                ModelProto result = buildPartial();
                if (!result.isInitialized())
                {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }

            @Override
            public ModelProto buildPartial()
            {
                ModelProto result = new ModelProto(this);
                buildPartialRepeatedFields(result);
                if (bitField0_ != 0)
                {
                    buildPartial0(result);
                }
                onBuilt();
                return result;
            }

            private void buildPartialRepeatedFields(ModelProto result)
            {
                if (piecesBuilder_ == null)
                {
                    if (((bitField0_ & 0x00000001) != 0))
                    {
                        pieces_ = Collections.unmodifiableList(pieces_);
                        bitField0_ = (bitField0_ & ~0x00000001);
                    }
                    result.pieces_ = pieces_;
                }
                else
                {
                    result.pieces_ = piecesBuilder_.build();
                }
            }

            private void buildPartial0(ModelProto result)
            {
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000002) != 0))
                {
                    result.trainerSpec_ = trainerSpecBuilder_ == null
                            ? trainerSpec_
                            : trainerSpecBuilder_.build();
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000004) != 0))
                {
                    result.normalizerSpec_ = normalizerSpecBuilder_ == null
                            ? normalizerSpec_
                            : normalizerSpecBuilder_.build();
                    to_bitField0_ |= 0x00000002;
                }
                if (((from_bitField0_ & 0x00000008) != 0))
                {
                    result.selfTestData_ = selfTestDataBuilder_ == null
                            ? selfTestData_
                            : selfTestDataBuilder_.build();
                    to_bitField0_ |= 0x00000004;
                }
                if (((from_bitField0_ & 0x00000010) != 0))
                {
                    result.denormalizerSpec_ = denormalizerSpecBuilder_ == null
                            ? denormalizerSpec_
                            : denormalizerSpecBuilder_.build();
                    to_bitField0_ |= 0x00000008;
                }
                result.bitField0_ |= to_bitField0_;
            }

            @Override
            public Builder mergeFrom(Message other)
            {
                if (other instanceof ModelProto)
                {
                    return mergeFrom((ModelProto) other);
                }
                else
                {
                    super.mergeFrom(other);
                    return this;
                }
            }

            public Builder mergeFrom(ModelProto other)
            {
                if (other == ModelProto.getDefaultInstance()) return this;
                if (piecesBuilder_ == null)
                {
                    if (!other.pieces_.isEmpty())
                    {
                        if (pieces_.isEmpty())
                        {
                            pieces_ = other.pieces_;
                            bitField0_ = (bitField0_ & ~0x00000001);
                        }
                        else
                        {
                            ensurePiecesIsMutable();
                            pieces_.addAll(other.pieces_);
                        }
                        onChanged();
                    }
                }
                else
                {
                    if (!other.pieces_.isEmpty())
                    {
                        if (piecesBuilder_.isEmpty())
                        {
                            piecesBuilder_.dispose();
                            piecesBuilder_ = null;
                            pieces_ = other.pieces_;
                            bitField0_ = (bitField0_ & ~0x00000001);
                            piecesBuilder_ = GeneratedMessage.alwaysUseFieldBuilders ? getPiecesFieldBuilder() : null;
                        }
                        else
                        {
                            piecesBuilder_.addAllMessages(other.pieces_);
                        }
                    }
                }
                if (other.hasTrainerSpec())
                {
                    mergeTrainerSpec(other.getTrainerSpec());
                }
                if (other.hasNormalizerSpec())
                {
                    mergeNormalizerSpec(other.getNormalizerSpec());
                }
                if (other.hasSelfTestData())
                {
                    mergeSelfTestData(other.getSelfTestData());
                }
                if (other.hasDenormalizerSpec())
                {
                    mergeDenormalizerSpec(other.getDenormalizerSpec());
                }
                this.mergeExtensionFields(other);
                this.mergeUnknownFields(other.getUnknownFields());
                onChanged();
                return this;
            }

            @Override
            public boolean isInitialized()
            {
                for (int i = 0; i < getPiecesCount(); i++)
                {
                    if (!getPieces(i).isInitialized())
                    {
                        return false;
                    }
                }
                if (hasTrainerSpec())
                {
                    if (!getTrainerSpec().isInitialized())
                    {
                        return false;
                    }
                }
                if (hasNormalizerSpec())
                {
                    if (!getNormalizerSpec().isInitialized())
                    {
                        return false;
                    }
                }
                if (hasSelfTestData())
                {
                    if (!getSelfTestData().isInitialized())
                    {
                        return false;
                    }
                }
                if (hasDenormalizerSpec())
                {
                    if (!getDenormalizerSpec().isInitialized())
                    {
                        return false;
                    }
                }
                return extensionsAreInitialized();
            }

            @Override
            public Builder mergeFrom( CodedInputStream input, ExtensionRegistryLite extensionRegistry)
                    throws IOException
            {
                if (extensionRegistry == null)
                {
                    throw new NullPointerException();
                }
                try
                {
                    boolean done = false;
                    while (!done)
                    {
                        int tag = input.readTag();
                        switch (tag)
                        {
                            case 0: done = true;
                                  break;
                            case 10:
                            {
                                SentencePiece m = input.readMessage(SentencePiece.parser(), extensionRegistry);
                                if (piecesBuilder_ == null)
                                {
                                    ensurePiecesIsMutable();
                                    pieces_.add(m);
                                }
                                else
                                {
                                    piecesBuilder_.addMessage(m);
                                }
                                break;
                            } // case 10
                            case 18:
                            {
                                input.readMessage(getTrainerSpecFieldBuilder().getBuilder(), extensionRegistry);
                                bitField0_ |= 0x00000002;
                                break;
                            } // case 18
                            case 26:
                            {
                                input.readMessage(getNormalizerSpecFieldBuilder().getBuilder(), extensionRegistry);
                                bitField0_ |= 0x00000004;
                                break;
                            } // case 26
                            case 34:
                            {
                                input.readMessage(getSelfTestDataFieldBuilder().getBuilder(), extensionRegistry);
                                bitField0_ |= 0x00000008;
                                break;
                            } // case 34
                            case 42:
                            {
                                input.readMessage(getDenormalizerSpecFieldBuilder().getBuilder(), extensionRegistry);
                                bitField0_ |= 0x00000010;
                                break;
                            } // case 42
                            default:
                            {
                                if (!super.parseUnknownField(input, extensionRegistry, tag))
                                {
                                    done = true; // was an endgroup tag
                                }
                                break;
                            } // default:
                        } // switch (tag)
                    } // while (!done)
                }
                catch (InvalidProtocolBufferException e)
                {
                    throw e.unwrapIOException();
                }
                finally
                {
                    onChanged();
                } // finally
                return this;
            }

            private int bitField0_;

            private List<SentencePiece> pieces_ = Collections.emptyList();

            private void ensurePiecesIsMutable()
            {
                if ((bitField0_ & 0x00000001) == 0)
                {
                    pieces_ = new ArrayList<>(pieces_);
                    bitField0_ |= 0x00000001;
                }
            }

            private RepeatedFieldBuilder<SentencePiece, SentencePiece.Builder, SentencePieceOrBuilder> piecesBuilder_;

            /**
             * <pre>
             * Sentence pieces with scores.
             * </pre>
             *
             * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
             */
            public List<SentencePiece> getPiecesList()
            {
                if (piecesBuilder_ == null)
                {
                    return Collections.unmodifiableList(pieces_);
                }
                else
                {
                    return piecesBuilder_.getMessageList();
                }
            }

            /**
             * <pre>
             * Sentence pieces with scores.
             * </pre>
             *
             * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
             */
            public int getPiecesCount()
            {
                if (piecesBuilder_ == null)
                {
                    return pieces_.size();
                }
                else
                {
                    return piecesBuilder_.getCount();
                }
            }

            /**
             * <pre>
             * Sentence pieces with scores.
             * </pre>
             *
             * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
             */
            public SentencePiece getPieces(int index)
            {
                if (piecesBuilder_ == null)
                {
                    return pieces_.get(index);
                }
                else
                {
                    return piecesBuilder_.getMessage(index);
                }
            }

            /**
             * <pre>
             * Sentence pieces with scores.
             * </pre>
             *
             * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
             */
            public Builder setPieces(int index, SentencePiece value)
            {
                if (piecesBuilder_ == null)
                {
                    if (value == null)
                    {
                        throw new NullPointerException();
                    }
                    ensurePiecesIsMutable();
                    pieces_.set(index, value);
                    onChanged();
                }
                else
                {
                    piecesBuilder_.setMessage(index, value);
                }
                return this;
            }

            /**
             * <pre>
             * Sentence pieces with scores.
             * </pre>
             *
             * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
             */
            public Builder setPieces(int index, SentencePiece.Builder builderForValue)
            {
                if (piecesBuilder_ == null)
                {
                    ensurePiecesIsMutable();
                    pieces_.set(index, builderForValue.build());
                    onChanged();
                }
                else
                {
                    piecesBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }

            /**
             * <pre>
             * Sentence pieces with scores.
             * </pre>
             *
             * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
             */
            public Builder addPieces(SentencePiece value)
            {
                if (piecesBuilder_ == null)
                {
                    if (value == null)
                    {
                        throw new NullPointerException();
                    }
                    ensurePiecesIsMutable();
                    pieces_.add(value);
                    onChanged();
                }
                else
                {
                    piecesBuilder_.addMessage(value);
                }
                return this;
            }

            /**
             * <pre>
             * Sentence pieces with scores.
             * </pre>
             *
             * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
             */
            public Builder addPieces(int index, SentencePiece value)
            {
                if (piecesBuilder_ == null)
                {
                    if (value == null)
                    {
                        throw new NullPointerException();
                    }
                    ensurePiecesIsMutable();
                    pieces_.add(index, value);
                    onChanged();
                }
                else
                {
                    piecesBuilder_.addMessage(index, value);
                }
                return this;
            }

            /**
             * <pre>
             * Sentence pieces with scores.
             * </pre>
             *
             * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
             */
            public Builder addPieces(SentencePiece.Builder builderForValue)
            {
                if (piecesBuilder_ == null)
                {
                    ensurePiecesIsMutable();
                    pieces_.add(builderForValue.build());
                    onChanged();
                }
                else
                {
                    piecesBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }

            /**
             * <pre>
             * Sentence pieces with scores.
             * </pre>
             *
             * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
             */
            public Builder addPieces(int index, SentencePiece.Builder builderForValue)
            {
                if (piecesBuilder_ == null)
                {
                    ensurePiecesIsMutable();
                    pieces_.add(index, builderForValue.build());
                    onChanged();
                }
                else
                {
                    piecesBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }

            /**
             * <pre>
             * Sentence pieces with scores.
             * </pre>
             *
             * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
             */
            public Builder addAllPieces(Iterable<? extends SentencePiece> values)
            {
                if (piecesBuilder_ == null)
                {
                    ensurePiecesIsMutable();
                    AbstractMessageLite.Builder.addAll(values, pieces_);
                    onChanged();
                }
                else
                {
                    piecesBuilder_.addAllMessages(values);
                }
                return this;
            }

            /**
             * <pre>
             * Sentence pieces with scores.
             * </pre>
             *
             * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
             */
            public Builder clearPieces()
            {
                if (piecesBuilder_ == null)
                {
                    pieces_ = Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000001);
                    onChanged();
                }
                else
                {
                    piecesBuilder_.clear();
                }
                return this;
            }

            /**
             * <pre>
             * Sentence pieces with scores.
             * </pre>
             *
             * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
             */
            public Builder removePieces(int index)
            {
                if (piecesBuilder_ == null)
                {
                    ensurePiecesIsMutable();
                    pieces_.remove(index);
                    onChanged();
                }
                else
                {
                    piecesBuilder_.remove(index);
                }
                return this;
            }

            /**
             * <pre>
             * Sentence pieces with scores.
             * </pre>
             *
             * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
             */
            public SentencePiece.Builder getPiecesBuilder(int index)
            {
                return getPiecesFieldBuilder().getBuilder(index);
            }

            /**
             * <pre>
             * Sentence pieces with scores.
             * </pre>
             *
             * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
             */
            public SentencePieceOrBuilder getPiecesOrBuilder(int index)
            {
                if (piecesBuilder_ == null)
                {
                    return pieces_.get(index);
                }
                else
                {
                    return piecesBuilder_.getMessageOrBuilder(index);
                }
            }

            /**
             * <pre>
             * Sentence pieces with scores.
             * </pre>
             *
             * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
             */
            public List<? extends SentencePieceOrBuilder> getPiecesOrBuilderList()
            {
                if (piecesBuilder_ != null)
                {
                    return piecesBuilder_.getMessageOrBuilderList();
                }
                else
                {
                    return Collections.unmodifiableList(pieces_);
                }
            }

            /**
             * <pre>
             * Sentence pieces with scores.
             * </pre>
             *
             * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
             */
            public SentencePiece.Builder addPiecesBuilder()
            {
                return getPiecesFieldBuilder().addBuilder(SentencePiece.getDefaultInstance());
            }

            /**
             * <pre>
             * Sentence pieces with scores.
             * </pre>
             *
             * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
             */
            public SentencePiece.Builder addPiecesBuilder(int index)
            {
                return getPiecesFieldBuilder().addBuilder(index, SentencePiece.getDefaultInstance());
            }

            /**
             * <pre>
             * Sentence pieces with scores.
             * </pre>
             *
             * <code>repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;</code>
             */
            public List<SentencePiece.Builder> getPiecesBuilderList()
            {
                return getPiecesFieldBuilder().getBuilderList();
            }

            private RepeatedFieldBuilder<SentencePiece, SentencePiece.Builder, SentencePieceOrBuilder> getPiecesFieldBuilder()
            {
                if (piecesBuilder_ == null)
                {
                    piecesBuilder_ = new RepeatedFieldBuilder<>(pieces_, ((bitField0_ & 0x00000001) != 0),
                            getParentForChildren(), isClean());
                    pieces_ = null;
                }
                return piecesBuilder_;
            }

            private TrainerSpec trainerSpec_;
            private SingleFieldBuilder<TrainerSpec, TrainerSpec.Builder, TrainerSpecOrBuilder> trainerSpecBuilder_;

            /**
             * <pre>
             * Spec used to generate this model file.
             * </pre>
             *
             * <code>optional .sentencepiece.TrainerSpec trainer_spec = 2;</code>
             *
             * @return Whether the trainerSpec field is set.
             */
            public boolean hasTrainerSpec()
            {
                return ((bitField0_ & 0x00000002) != 0);
            }

            /**
             * <pre>
             * Spec used to generate this model file.
             * </pre>
             *
             * <code>optional .sentencepiece.TrainerSpec trainer_spec = 2;</code>
             *
             * @return The trainerSpec.
             */
            public TrainerSpec getTrainerSpec()
            {
                if (trainerSpecBuilder_ == null)
                {
                    return trainerSpec_ == null ? TrainerSpec.getDefaultInstance() : trainerSpec_;
                }
                else
                {
                    return trainerSpecBuilder_.getMessage();
                }
            }

            /**
             * <pre>
             * Spec used to generate this model file.
             * </pre>
             *
             * <code>optional .sentencepiece.TrainerSpec trainer_spec = 2;</code>
             */
            public Builder setTrainerSpec(TrainerSpec value)
            {
                if (trainerSpecBuilder_ == null)
                {
                    if (value == null)
                    {
                        throw new NullPointerException();
                    }
                    trainerSpec_ = value;
                }
                else
                {
                    trainerSpecBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Spec used to generate this model file.
             * </pre>
             *
             * <code>optional .sentencepiece.TrainerSpec trainer_spec = 2;</code>
             */
            public Builder setTrainerSpec(TrainerSpec.Builder builderForValue)
            {
                if (trainerSpecBuilder_ == null)
                {
                    trainerSpec_ = builderForValue.build();
                }
                else
                {
                    trainerSpecBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000002;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Spec used to generate this model file.
             * </pre>
             *
             * <code>optional .sentencepiece.TrainerSpec trainer_spec = 2;</code>
             */
            public Builder mergeTrainerSpec(TrainerSpec value)
            {
                if (trainerSpecBuilder_ == null)
                {
                    if (((bitField0_ & 0x00000002) != 0) && trainerSpec_ != null &&
                            trainerSpec_ != TrainerSpec.getDefaultInstance())
                    {
                        getTrainerSpecBuilder().mergeFrom(value);
                    }
                    else
                    {
                        trainerSpec_ = value;
                    }
                }
                else
                {
                    trainerSpecBuilder_.mergeFrom(value);
                }
                if (trainerSpec_ != null)
                {
                    bitField0_ |= 0x00000002;
                    onChanged();
                }
                return this;
            }

            /**
             * <pre>
             * Spec used to generate this model file.
             * </pre>
             *
             * <code>optional .sentencepiece.TrainerSpec trainer_spec = 2;</code>
             */
            public Builder clearTrainerSpec()
            {
                bitField0_ = (bitField0_ & ~0x00000002);
                trainerSpec_ = null;
                if (trainerSpecBuilder_ != null)
                {
                    trainerSpecBuilder_.dispose();
                    trainerSpecBuilder_ = null;
                }
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Spec used to generate this model file.
             * </pre>
             *
             * <code>optional .sentencepiece.TrainerSpec trainer_spec = 2;</code>
             */
            public TrainerSpec.Builder getTrainerSpecBuilder()
            {
                bitField0_ |= 0x00000002;
                onChanged();
                return getTrainerSpecFieldBuilder().getBuilder();
            }

            /**
             * <pre>
             * Spec used to generate this model file.
             * </pre>
             *
             * <code>optional .sentencepiece.TrainerSpec trainer_spec = 2;</code>
             */
            public TrainerSpecOrBuilder getTrainerSpecOrBuilder()
            {
                if (trainerSpecBuilder_ != null)
                {
                    return trainerSpecBuilder_.getMessageOrBuilder();
                }
                else
                {
                    return trainerSpec_ == null ? TrainerSpec.getDefaultInstance() : trainerSpec_;
                }
            }

            /**
             * <pre>
             * Spec used to generate this model file.
             * </pre>
             *
             * <code>optional .sentencepiece.TrainerSpec trainer_spec = 2;</code>
             */
            private SingleFieldBuilder<TrainerSpec, TrainerSpec.Builder, TrainerSpecOrBuilder> getTrainerSpecFieldBuilder()
            {
                if (trainerSpecBuilder_ == null)
                {
                    trainerSpecBuilder_ = new SingleFieldBuilder<>(getTrainerSpec(), getParentForChildren(), isClean());
                    trainerSpec_ = null;
                }
                return trainerSpecBuilder_;
            }

            private NormalizerSpec normalizerSpec_;
            private SingleFieldBuilder<NormalizerSpec, NormalizerSpec.Builder, NormalizerSpecOrBuilder> normalizerSpecBuilder_;

            /**
             * <pre>
             * Spec for text normalization.
             * </pre>
             *
             * <code>optional .sentencepiece.NormalizerSpec normalizer_spec = 3;</code>
             *
             * @return Whether the normalizerSpec field is set.
             */
            public boolean hasNormalizerSpec()
            {
                return ((bitField0_ & 0x00000004) != 0);
            }

            /**
             * <pre>
             * Spec for text normalization.
             * </pre>
             *
             * <code>optional .sentencepiece.NormalizerSpec normalizer_spec = 3;</code>
             *
             * @return The normalizerSpec.
             */
            public NormalizerSpec getNormalizerSpec()
            {
                if (normalizerSpecBuilder_ == null)
                {
                    return normalizerSpec_ == null ? NormalizerSpec.getDefaultInstance() : normalizerSpec_;
                }
                else
                {
                    return normalizerSpecBuilder_.getMessage();
                }
            }

            /**
             * <pre>
             * Spec for text normalization.
             * </pre>
             *
             * <code>optional .sentencepiece.NormalizerSpec normalizer_spec = 3;</code>
             */
            public Builder setNormalizerSpec(NormalizerSpec value)
            {
                if (normalizerSpecBuilder_ == null)
                {
                    if (value == null)
                    {
                        throw new NullPointerException();
                    }
                    normalizerSpec_ = value;
                }
                else
                {
                    normalizerSpecBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Spec for text normalization.
             * </pre>
             *
             * <code>optional .sentencepiece.NormalizerSpec normalizer_spec = 3;</code>
             */
            public Builder setNormalizerSpec(NormalizerSpec.Builder builderForValue)
            {
                if (normalizerSpecBuilder_ == null)
                {
                    normalizerSpec_ = builderForValue.build();
                }
                else
                {
                    normalizerSpecBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000004;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Spec for text normalization.
             * </pre>
             *
             * <code>optional .sentencepiece.NormalizerSpec normalizer_spec = 3;</code>
             */
            public Builder mergeNormalizerSpec(NormalizerSpec value)
            {
                if (normalizerSpecBuilder_ == null)
                {
                    if (((bitField0_ & 0x00000004) != 0) && normalizerSpec_ != null &&
                            normalizerSpec_ != NormalizerSpec.getDefaultInstance())
                    {
                        getNormalizerSpecBuilder().mergeFrom(value);
                    }
                    else
                    {
                        normalizerSpec_ = value;
                    }
                }
                else
                {
                    normalizerSpecBuilder_.mergeFrom(value);
                }
                if (normalizerSpec_ != null)
                {
                    bitField0_ |= 0x00000004;
                    onChanged();
                }
                return this;
            }

            /**
             * <pre>
             * Spec for text normalization.
             * </pre>
             *
             * <code>optional .sentencepiece.NormalizerSpec normalizer_spec = 3;</code>
             */
            public Builder clearNormalizerSpec()
            {
                bitField0_ = (bitField0_ & ~0x00000004);
                normalizerSpec_ = null;
                if (normalizerSpecBuilder_ != null)
                {
                    normalizerSpecBuilder_.dispose();
                    normalizerSpecBuilder_ = null;
                }
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Spec for text normalization.
             * </pre>
             *
             * <code>optional .sentencepiece.NormalizerSpec normalizer_spec = 3;</code>
             */
            public NormalizerSpec.Builder getNormalizerSpecBuilder()
            {
                bitField0_ |= 0x00000004;
                onChanged();
                return getNormalizerSpecFieldBuilder().getBuilder();
            }

            /**
             * <pre>
             * Spec for text normalization.
             * </pre>
             *
             * <code>optional .sentencepiece.NormalizerSpec normalizer_spec = 3;</code>
             */
            public NormalizerSpecOrBuilder getNormalizerSpecOrBuilder()
            {
                if (normalizerSpecBuilder_ != null)
                {
                    return normalizerSpecBuilder_.getMessageOrBuilder();
                }
                else
                {
                    return normalizerSpec_ == null ? NormalizerSpec.getDefaultInstance() : normalizerSpec_;
                }
            }

            /**
             * <pre>
             * Spec for text normalization.
             * </pre>
             *
             * <code>optional .sentencepiece.NormalizerSpec normalizer_spec = 3;</code>
             */
            private SingleFieldBuilder<NormalizerSpec, NormalizerSpec.Builder, NormalizerSpecOrBuilder> getNormalizerSpecFieldBuilder()
            {
                if (normalizerSpecBuilder_ == null)
                {
                    normalizerSpecBuilder_ =
                            new SingleFieldBuilder<>(getNormalizerSpec(), getParentForChildren(), isClean());
                    normalizerSpec_ = null;
                }
                return normalizerSpecBuilder_;
            }

            private SelfTestData selfTestData_;
            private SingleFieldBuilder<SelfTestData, SelfTestData.Builder, SelfTestDataOrBuilder> selfTestDataBuilder_;

            /**
             * <pre>
             * Stores sample input and its expected segmentation to verify the model.
             * </pre>
             *
             * <code>optional .sentencepiece.SelfTestData self_test_data = 4;</code>
             *
             * @return Whether the selfTestData field is set.
             */
            public boolean hasSelfTestData()
            {
                return ((bitField0_ & 0x00000008) != 0);
            }

            /**
             * <pre>
             * Stores sample input and its expected segmentation to verify the model.
             * </pre>
             *
             * <code>optional .sentencepiece.SelfTestData self_test_data = 4;</code>
             *
             * @return The selfTestData.
             */
            public SelfTestData getSelfTestData()
            {
                if (selfTestDataBuilder_ == null)
                {
                    return selfTestData_ == null ? SelfTestData.getDefaultInstance() : selfTestData_;
                }
                else
                {
                    return selfTestDataBuilder_.getMessage();
                }
            }

            /**
             * <pre>
             * Stores sample input and its expected segmentation to verify the model.
             * </pre>
             *
             * <code>optional .sentencepiece.SelfTestData self_test_data = 4;</code>
             */
            public Builder setSelfTestData(SelfTestData value)
            {
                if (selfTestDataBuilder_ == null)
                {
                    if (value == null)
                    {
                        throw new NullPointerException();
                    }
                    selfTestData_ = value;
                }
                else
                {
                    selfTestDataBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000008;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Stores sample input and its expected segmentation to verify the model.
             * </pre>
             *
             * <code>optional .sentencepiece.SelfTestData self_test_data = 4;</code>
             */
            public Builder setSelfTestData(
                    SelfTestData.Builder builderForValue)
            {
                if (selfTestDataBuilder_ == null)
                {
                    selfTestData_ = builderForValue.build();
                }
                else
                {
                    selfTestDataBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000008;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Stores sample input and its expected segmentation to verify the model.
             * </pre>
             *
             * <code>optional .sentencepiece.SelfTestData self_test_data = 4;</code>
             */
            public Builder mergeSelfTestData(SelfTestData value)
            {
                if (selfTestDataBuilder_ == null)
                {
                    if (((bitField0_ & 0x00000008) != 0) && selfTestData_ != null &&
                            selfTestData_ != SelfTestData.getDefaultInstance())
                    {
                        getSelfTestDataBuilder().mergeFrom(value);
                    }
                    else
                    {
                        selfTestData_ = value;
                    }
                }
                else
                {
                    selfTestDataBuilder_.mergeFrom(value);
                }
                if (selfTestData_ != null)
                {
                    bitField0_ |= 0x00000008;
                    onChanged();
                }
                return this;
            }

            /**
             * <pre>
             * Stores sample input and its expected segmentation to verify the model.
             * </pre>
             *
             * <code>optional .sentencepiece.SelfTestData self_test_data = 4;</code>
             */
            public Builder clearSelfTestData()
            {
                bitField0_ = (bitField0_ & ~0x00000008);
                selfTestData_ = null;
                if (selfTestDataBuilder_ != null)
                {
                    selfTestDataBuilder_.dispose();
                    selfTestDataBuilder_ = null;
                }
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Stores sample input and its expected segmentation to verify the model.
             * </pre>
             *
             * <code>optional .sentencepiece.SelfTestData self_test_data = 4;</code>
             */
            public SelfTestData.Builder getSelfTestDataBuilder()
            {
                bitField0_ |= 0x00000008;
                onChanged();
                return getSelfTestDataFieldBuilder().getBuilder();
            }

            /**
             * <pre>
             * Stores sample input and its expected segmentation to verify the model.
             * </pre>
             *
             * <code>optional .sentencepiece.SelfTestData self_test_data = 4;</code>
             */
            public SelfTestDataOrBuilder getSelfTestDataOrBuilder()
            {
                if (selfTestDataBuilder_ != null)
                {
                    return selfTestDataBuilder_.getMessageOrBuilder();
                }
                else
                {
                    return selfTestData_ == null ? SelfTestData.getDefaultInstance() : selfTestData_;
                }
            }

            /**
             * <pre>
             * Stores sample input and its expected segmentation to verify the model.
             * </pre>
             *
             * <code>optional .sentencepiece.SelfTestData self_test_data = 4;</code>
             */
            private SingleFieldBuilder<SelfTestData, SelfTestData.Builder, SelfTestDataOrBuilder> getSelfTestDataFieldBuilder()
            {
                if (selfTestDataBuilder_ == null)
                {
                    selfTestDataBuilder_ =
                            new SingleFieldBuilder<>(getSelfTestData(), getParentForChildren(), isClean());
                    selfTestData_ = null;
                }
                return selfTestDataBuilder_;
            }

            private NormalizerSpec denormalizerSpec_;
            private SingleFieldBuilder<NormalizerSpec, NormalizerSpec.Builder, NormalizerSpecOrBuilder> denormalizerSpecBuilder_;

            /**
             * <pre>
             * Spec for text de-normalization.
             * </pre>
             *
             * <code>optional .sentencepiece.NormalizerSpec denormalizer_spec = 5;</code>
             *
             * @return Whether the denormalizerSpec field is set.
             */
            public boolean hasDenormalizerSpec()
            {
                return ((bitField0_ & 0x00000010) != 0);
            }

            /**
             * <pre>
             * Spec for text de-normalization.
             * </pre>
             *
             * <code>optional .sentencepiece.NormalizerSpec denormalizer_spec = 5;</code>
             *
             * @return The denormalizerSpec.
             */
            public NormalizerSpec getDenormalizerSpec()
            {
                if (denormalizerSpecBuilder_ == null)
                {
                    return denormalizerSpec_ == null ? NormalizerSpec.getDefaultInstance() : denormalizerSpec_;
                }
                else
                {
                    return denormalizerSpecBuilder_.getMessage();
                }
            }

            /**
             * <pre>
             * Spec for text de-normalization.
             * </pre>
             *
             * <code>optional .sentencepiece.NormalizerSpec denormalizer_spec = 5;</code>
             */
            public Builder setDenormalizerSpec(NormalizerSpec value)
            {
                if (denormalizerSpecBuilder_ == null)
                {
                    if (value == null)
                    {
                        throw new NullPointerException();
                    }
                    denormalizerSpec_ = value;
                }
                else
                {
                    denormalizerSpecBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000010;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Spec for text de-normalization.
             * </pre>
             *
             * <code>optional .sentencepiece.NormalizerSpec denormalizer_spec = 5;</code>
             */
            public Builder setDenormalizerSpec(NormalizerSpec.Builder builderForValue)
            {
                if (denormalizerSpecBuilder_ == null)
                {
                    denormalizerSpec_ = builderForValue.build();
                }
                else
                {
                    denormalizerSpecBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000010;
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Spec for text de-normalization.
             * </pre>
             *
             * <code>optional .sentencepiece.NormalizerSpec denormalizer_spec = 5;</code>
             */
            public Builder mergeDenormalizerSpec(NormalizerSpec value)
            {
                if (denormalizerSpecBuilder_ == null)
                {
                    if (((bitField0_ & 0x00000010) != 0) && denormalizerSpec_ != null &&
                            denormalizerSpec_ != NormalizerSpec.getDefaultInstance())
                    {
                        getDenormalizerSpecBuilder().mergeFrom(value);
                    }
                    else
                    {
                        denormalizerSpec_ = value;
                    }
                }
                else
                {
                    denormalizerSpecBuilder_.mergeFrom(value);
                }
                if (denormalizerSpec_ != null)
                {
                    bitField0_ |= 0x00000010;
                    onChanged();
                }
                return this;
            }

            /**
             * <pre>
             * Spec for text de-normalization.
             * </pre>
             *
             * <code>optional .sentencepiece.NormalizerSpec denormalizer_spec = 5;</code>
             */
            public Builder clearDenormalizerSpec()
            {
                bitField0_ = (bitField0_ & ~0x00000010);
                denormalizerSpec_ = null;
                if (denormalizerSpecBuilder_ != null)
                {
                    denormalizerSpecBuilder_.dispose();
                    denormalizerSpecBuilder_ = null;
                }
                onChanged();
                return this;
            }

            /**
             * <pre>
             * Spec for text de-normalization.
             * </pre>
             *
             * <code>optional .sentencepiece.NormalizerSpec denormalizer_spec = 5;</code>
             */
            public NormalizerSpec.Builder getDenormalizerSpecBuilder()
            {
                bitField0_ |= 0x00000010;
                onChanged();
                return getDenormalizerSpecFieldBuilder().getBuilder();
            }

            /**
             * <pre>
             * Spec for text de-normalization.
             * </pre>
             *
             * <code>optional .sentencepiece.NormalizerSpec denormalizer_spec = 5;</code>
             */
            public NormalizerSpecOrBuilder getDenormalizerSpecOrBuilder()
            {
                if (denormalizerSpecBuilder_ != null)
                {
                    return denormalizerSpecBuilder_.getMessageOrBuilder();
                }
                else
                {
                    return denormalizerSpec_ == null ?
                            NormalizerSpec.getDefaultInstance() : denormalizerSpec_;
                }
            }

            /**
             * <pre>
             * Spec for text de-normalization.
             * </pre>
             *
             * <code>optional .sentencepiece.NormalizerSpec denormalizer_spec = 5;</code>
             */
            private SingleFieldBuilder<NormalizerSpec, NormalizerSpec.Builder, NormalizerSpecOrBuilder>
            getDenormalizerSpecFieldBuilder()
            {
                if (denormalizerSpecBuilder_ == null)
                {
                    denormalizerSpecBuilder_ =
                            new SingleFieldBuilder<>(getDenormalizerSpec(), getParentForChildren(), isClean());
                    denormalizerSpec_ = null;
                }
                return denormalizerSpecBuilder_;
            }
        }

        private static final ModelProto DEFAULT_INSTANCE;

        static
        {
            DEFAULT_INSTANCE = new ModelProto();
        }

        public static ModelProto getDefaultInstance()
        {
            return DEFAULT_INSTANCE;
        }

        private static final Parser<ModelProto> PARSER = new AbstractParser<>()
        {
            @Override
            public ModelProto parsePartialFrom(CodedInputStream input, ExtensionRegistryLite extensionRegistry)
                    throws InvalidProtocolBufferException
            {
                Builder builder = newBuilder();
                try
                {
                    builder.mergeFrom(input, extensionRegistry);
                }
                catch (InvalidProtocolBufferException e)
                {
                    throw e.setUnfinishedMessage(builder.buildPartial());
                }
                catch (UninitializedMessageException e)
                {
                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
                }
                catch (IOException e)
                {
                    throw new InvalidProtocolBufferException(e).setUnfinishedMessage(builder.buildPartial());
                }
                return builder.buildPartial();
            }
        };

        public static Parser<ModelProto> parser()
        {
            return PARSER;
        }

        @Override
        public Parser<ModelProto> getParserForType()
        {
            return PARSER;
        }

        @Override
        public ModelProto getDefaultInstanceForType()
        {
            return DEFAULT_INSTANCE;
        }
    }

    private static final Descriptors.Descriptor internal_static_sentencepiece_TrainerSpec_descriptor;
    private static final GeneratedMessage.FieldAccessorTable internal_static_sentencepiece_TrainerSpec_fieldAccessorTable;
    private static final Descriptors.Descriptor internal_static_sentencepiece_NormalizerSpec_descriptor;
    private static final GeneratedMessage.FieldAccessorTable internal_static_sentencepiece_NormalizerSpec_fieldAccessorTable;
    private static final Descriptors.Descriptor internal_static_sentencepiece_SelfTestData_descriptor;
    private static final GeneratedMessage.FieldAccessorTable internal_static_sentencepiece_SelfTestData_fieldAccessorTable;
    private static final Descriptors.Descriptor internal_static_sentencepiece_SelfTestData_Sample_descriptor;
    private static final GeneratedMessage.FieldAccessorTable internal_static_sentencepiece_SelfTestData_Sample_fieldAccessorTable;
    private static final Descriptors.Descriptor internal_static_sentencepiece_ModelProto_descriptor;
    private static final GeneratedMessage.FieldAccessorTable internal_static_sentencepiece_ModelProto_fieldAccessorTable;
    private static final Descriptors.Descriptor internal_static_sentencepiece_ModelProto_SentencePiece_descriptor;
    private static final GeneratedMessage.FieldAccessorTable internal_static_sentencepiece_ModelProto_SentencePiece_fieldAccessorTable;

    public static Descriptors.FileDescriptor getDescriptor()
    {
        return descriptor;
    }

    private static final Descriptors.FileDescriptor descriptor;

    static
    {
        String[] descriptorData = {
                "\n\031sentencepiece_model.proto\022\rsentencepie" +
                        "ce\"\244\014\n\013TrainerSpec\022\r\n\005input\030\001 \003(\t\022\024\n\014inp" +
                        "ut_format\030\007 \001(\t\022\024\n\014model_prefix\030\002 \001(\t\022A\n" +
                        "\nmodel_type\030\003 \001(\0162$.sentencepiece.Traine" +
                        "rSpec.ModelType:\007UNIGRAM\022\030\n\nvocab_size\030\004" +
                        " \001(\005:\0048000\022\027\n\017accept_language\030\005 \003(\t\022 \n\025s" +
                        "elf_test_sample_size\030\006 \001(\005:\0010\022*\n\033enable_" +
                        "differential_privacy\0302 \001(\010:\005false\022+\n dif" +
                        "ferential_privacy_noise_level\0303 \001(\002:\0010\0222" +
                        "\n'differential_privacy_clipping_threshol" +
                        "d\0304 \001(\004:\0010\022\"\n\022character_coverage\030\n \001(\002:\006" +
                        "0.9995\022\036\n\023input_sentence_size\030\013 \001(\004:\0010\022$" +
                        "\n\026shuffle_input_sentence\030\023 \001(\010:\004true\022 \n\024" +
                        "mining_sentence_size\030\014 \001(\005B\002\030\001\022\"\n\026traini" +
                        "ng_sentence_size\030\r \001(\005B\002\030\001\022(\n\027seed_sente" +
                        "ncepiece_size\030\016 \001(\005:\0071000000\022\036\n\020shrinkin" +
                        "g_factor\030\017 \001(\002:\0040.75\022!\n\023max_sentence_len" +
                        "gth\030\022 \001(\005:\0044192\022\027\n\013num_threads\030\020 \001(\005:\00216" +
                        "\022\035\n\022num_sub_iterations\030\021 \001(\005:\0012\022$\n\030max_s" +
                        "entencepiece_length\030\024 \001(\005:\00216\022%\n\027split_b" +
                        "y_unicode_script\030\025 \001(\010:\004true\022\035\n\017split_by" +
                        "_number\030\027 \001(\010:\004true\022!\n\023split_by_whitespa" +
                        "ce\030\026 \001(\010:\004true\022)\n\032treat_whitespace_as_su" +
                        "ffix\030\030 \001(\010:\005false\022+\n\034allow_whitespace_on" +
                        "ly_pieces\030\032 \001(\010:\005false\022\033\n\014split_digits\030\031" +
                        " \001(\010:\005false\022#\n\031pretokenization_delimiter" +
                        "\0305 \001(\t:\000\022\027\n\017control_symbols\030\036 \003(\t\022\034\n\024use" +
                        "r_defined_symbols\030\037 \003(\t\022\026\n\016required_char" +
                        "s\030$ \001(\t\022\034\n\rbyte_fallback\030# \001(\010:\005false\022+\n" +
                        "\035vocabulary_output_piece_score\030  \001(\010:\004tr" +
                        "ue\022\036\n\020hard_vocab_limit\030! \001(\010:\004true\022\034\n\rus" +
                        "e_all_vocab\030\" \001(\010:\005false\022\021\n\006unk_id\030( \001(\005" +
                        ":\0010\022\021\n\006bos_id\030) \001(\005:\0011\022\021\n\006eos_id\030* \001(\005:\001" +
                        "2\022\022\n\006pad_id\030+ \001(\005:\002-1\022\030\n\tunk_piece\030- \001(\t" +
                        ":\005<unk>\022\026\n\tbos_piece\030. \001(\t:\003<s>\022\027\n\teos_p" +
                        "iece\030/ \001(\t:\004</s>\022\030\n\tpad_piece\0300 \001(\t:\005<pa" +
                        "d>\022\032\n\013unk_surface\030, \001(\t:\005 \342\201\207 \022+\n\034train_" +
                        "extremely_large_corpus\0301 \001(\010:\005false\022\"\n\030s" +
                        "eed_sentencepieces_file\0306 \001(\t:\000\"5\n\tModel" +
                        "Type\022\013\n\007UNIGRAM\020\001\022\007\n\003BPE\020\002\022\010\n\004WORD\020\003\022\010\n\004" +
                        "CHAR\020\004*\t\010\310\001\020\200\200\200\200\002\"\321\001\n\016NormalizerSpec\022\014\n\004" +
                        "name\030\001 \001(\t\022\034\n\024precompiled_charsmap\030\002 \001(\014" +
                        "\022\036\n\020add_dummy_prefix\030\003 \001(\010:\004true\022&\n\030remo" +
                        "ve_extra_whitespaces\030\004 \001(\010:\004true\022 \n\022esca" +
                        "pe_whitespaces\030\005 \001(\010:\004true\022\036\n\026normalizat" +
                        "ion_rule_tsv\030\006 \001(\t*\t\010\310\001\020\200\200\200\200\002\"y\n\014SelfTes" +
                        "tData\0223\n\007samples\030\001 \003(\0132\".sentencepiece.S" +
                        "elfTestData.Sample\032)\n\006Sample\022\r\n\005input\030\001 " +
                        "\001(\t\022\020\n\010expected\030\002 \001(\t*\t\010\310\001\020\200\200\200\200\002\"\376\003\n\nMod" +
                        "elProto\0227\n\006pieces\030\001 \003(\0132'.sentencepiece." +
                        "ModelProto.SentencePiece\0220\n\014trainer_spec" +
                        "\030\002 \001(\0132\032.sentencepiece.TrainerSpec\0226\n\017no" +
                        "rmalizer_spec\030\003 \001(\0132\035.sentencepiece.Norm" +
                        "alizerSpec\0223\n\016self_test_data\030\004 \001(\0132\033.sen" +
                        "tencepiece.SelfTestData\0228\n\021denormalizer_" +
                        "spec\030\005 \001(\0132\035.sentencepiece.NormalizerSpe" +
                        "c\032\322\001\n\rSentencePiece\022\r\n\005piece\030\001 \001(\t\022\r\n\005sc" +
                        "ore\030\002 \001(\002\022B\n\004type\030\003 \001(\0162,.sentencepiece." +
                        "ModelProto.SentencePiece.Type:\006NORMAL\"T\n" +
                        "\004Type\022\n\n\006NORMAL\020\001\022\013\n\007UNKNOWN\020\002\022\013\n\007CONTRO" +
                        "L\020\003\022\020\n\014USER_DEFINED\020\004\022\010\n\004BYTE\020\006\022\n\n\006UNUSE" +
                        "D\020\005*\t\010\310\001\020\200\200\200\200\002*\t\010\310\001\020\200\200\200\200\002B\002H\003"
        };
        descriptor = Descriptors.FileDescriptor.internalBuildGeneratedFileFrom(descriptorData,
                        new Descriptors.FileDescriptor[]{
                        });
        internal_static_sentencepiece_TrainerSpec_descriptor = getDescriptor().getMessageTypes().get(0);
        internal_static_sentencepiece_TrainerSpec_fieldAccessorTable = new
                GeneratedMessage.FieldAccessorTable(
                internal_static_sentencepiece_TrainerSpec_descriptor,
                new String[]{"Input", "InputFormat", "ModelPrefix", "ModelType", "VocabSize", "AcceptLanguage", "SelfTestSampleSize", "EnableDifferentialPrivacy", "DifferentialPrivacyNoiseLevel", "DifferentialPrivacyClippingThreshold", "CharacterCoverage", "InputSentenceSize", "ShuffleInputSentence", "MiningSentenceSize", "TrainingSentenceSize", "SeedSentencepieceSize", "ShrinkingFactor", "MaxSentenceLength", "NumThreads", "NumSubIterations", "MaxSentencepieceLength", "SplitByUnicodeScript", "SplitByNumber", "SplitByWhitespace", "TreatWhitespaceAsSuffix", "AllowWhitespaceOnlyPieces", "SplitDigits", "PretokenizationDelimiter", "ControlSymbols", "UserDefinedSymbols", "RequiredChars", "ByteFallback", "VocabularyOutputPieceScore", "HardVocabLimit", "UseAllVocab", "UnkId", "BosId", "EosId", "PadId", "UnkPiece", "BosPiece", "EosPiece", "PadPiece", "UnkSurface", "TrainExtremelyLargeCorpus", "SeedSentencepiecesFile",});
        internal_static_sentencepiece_NormalizerSpec_descriptor =
                getDescriptor().getMessageTypes().get(1);
        internal_static_sentencepiece_NormalizerSpec_fieldAccessorTable = new
                GeneratedMessage.FieldAccessorTable(
                internal_static_sentencepiece_NormalizerSpec_descriptor,
                new String[]{"Name", "PrecompiledCharsmap", "AddDummyPrefix", "RemoveExtraWhitespaces", "EscapeWhitespaces", "NormalizationRuleTsv",});
        internal_static_sentencepiece_SelfTestData_descriptor =
                getDescriptor().getMessageTypes().get(2);
        internal_static_sentencepiece_SelfTestData_fieldAccessorTable = new
                GeneratedMessage.FieldAccessorTable(
                internal_static_sentencepiece_SelfTestData_descriptor,
                new String[]{"Samples",});
        internal_static_sentencepiece_SelfTestData_Sample_descriptor =
                internal_static_sentencepiece_SelfTestData_descriptor.getNestedTypes().getFirst();
        internal_static_sentencepiece_SelfTestData_Sample_fieldAccessorTable = new
                GeneratedMessage.FieldAccessorTable(
                internal_static_sentencepiece_SelfTestData_Sample_descriptor,
                new String[]{"Input", "Expected",});
        internal_static_sentencepiece_ModelProto_descriptor =
                getDescriptor().getMessageTypes().get(3);
        internal_static_sentencepiece_ModelProto_fieldAccessorTable = new
                GeneratedMessage.FieldAccessorTable(
                internal_static_sentencepiece_ModelProto_descriptor,
                new String[]{"Pieces", "TrainerSpec", "NormalizerSpec", "SelfTestData", "DenormalizerSpec",});
        internal_static_sentencepiece_ModelProto_SentencePiece_descriptor =
                internal_static_sentencepiece_ModelProto_descriptor.getNestedTypes().getFirst();
        internal_static_sentencepiece_ModelProto_SentencePiece_fieldAccessorTable =
                new GeneratedMessage.FieldAccessorTable(internal_static_sentencepiece_ModelProto_SentencePiece_descriptor,
                new String[]{"Piece", "Score", "Type",});
        descriptor.resolveAllFeaturesImmutable();
    }
}
